<% AUTOGEN_PMAX = 15 %>
!-------------------------------------------------------------------------------
! Warning: This file was generated from <%=__FILE__%>.
!          Do not edit this file.
!-------------------------------------------------------------------------------
!-------------------------------------------------------------------------------
!> module FElib / Element / Operation with 3D tensor product elements
!!
!! @par Description
!!           A module for providing mathematical operations assuming a 3D tensor product element with (p+1)^3 DOF
!!
!! @author Yuta Kawai, Xuanzhengbo Ren, and Team SCALE
!!
!<
#include "scaleFElib.h"
module scale_element_operation_tensorprod3D

  !-----------------------------------------------------------------------------
  !
  !++ used modules
  !
  use scale_precision
  use scale_io

  use scale_element_base, only: &
    ElementBase3D, &
    ElementBase3D_Init, ElementBase3D_Final

  use scale_element_operation_base, only: ElementOperationBase3D
  use scale_element_modalfilter, only: ModalFilter  

  !-----------------------------------------------------------------------------
  implicit none
  private

  !-----------------------------------------------------------------------------
  !
  !++ Public type & procedure
  !  

  type, public, abstract, extends(ElementOperationBase3D) :: ElementOperationTensorProd3D
  contains
    procedure(ElementOperationTensorProd3D_Init), deferred, public :: Init
    procedure(ElementOperationTensorProd3D_Final), deferred, public :: Final
  end type ElementOperationTensorProd3D

  interface
    subroutine ElementOperationTensorProd3D_Init( this, elem3D )
      import ElementOperationTensorProd3D
      import ElementBase3D
      class(ElementOperationTensorProd3D), intent(inout) :: this
      class(ElementBase3D), intent(in), target :: elem3D
    end subroutine ElementOperationTensorProd3D_Init

    subroutine ElementOperationTensorProd3D_Final( this )
      import ElementOperationTensorProd3D
      class(ElementOperationTensorProd3D), intent(inout) :: this
    end subroutine ElementOperationTensorProd3D_Final
  end interface

  public :: ElementOperationTensorprod3D_create

% for p in 1..AUTOGEN_PMAX
% np = p+1  
  type, public, extends(ElementOperationTensorProd3D) :: ElementOperationTensorProd3D_P<%=p%>
    real(RP) :: D1D(<%=np%>,<%=np%>)
    real(RP) :: D1D_tr(<%=np%>,<%=np%>)
    real(RP) :: Lift_mat(<%=np%>,<%=np%>,<%=np%>,6)
    real(RP) :: IntrpMat_VPOrdM1_tr(<%=np%>,<%=np%>)

    real(RP) :: MFilter_h1D(<%=np%>,<%=np%>)
    real(RP) :: MFilter_h1D_tr(<%=np%>,<%=np%>)
    real(RP) :: MFilter_v1D_tr(<%=np%>,<%=np%>)

    real(RP) :: MFilter_tracer_h1D(<%=np%>,<%=np%>)
    real(RP) :: MFilter_tracer_h1D_tr(<%=np%>,<%=np%>)
    real(RP) :: MFilter_tracer_v1D_tr(<%=np%>,<%=np%>)
  contains
    procedure, public :: Init => element_operation_tensorprod3D_Init_P<%=p%>
    procedure, public :: Final => element_operation_tensorprod3D_Final_P<%=p%>
    procedure, public :: Dx => element_operation_tensorprod3D_Dx_P<%=p%>
    procedure, public :: Dy => element_operation_tensorprod3D_Dy_P<%=p%>
    procedure, public :: Dz => element_operation_tensorprod3D_Dz_P<%=p%>
    procedure, public :: Lift => element_operation_tensorprod3D_Lift_P<%=p%>
    procedure, public :: DxDyDzLift => element_operation_tensorprod3D_DxDyDzLift_P<%=p%>
    procedure, public :: Div => element_operation_tensorprod3D_Div_P<%=p%>
    procedure, public :: Div_var5 => element_operation_tensorprod3D_Div_var5_P<%=p%>
    procedure, public :: Div_var5_2 => element_operation_tensorprod3D_Div_var5_2_P<%=p%>
    procedure, public :: VFilterPM1 => element_operation_tensorprod3D_VFilterPM1_P<%=p%>
    !-
    procedure, public :: Setup_ModalFilter => element_operation_tensorprod3D_Setup_ModalFilter_P<%=p%>
    procedure, public :: Setup_ModalFilter_tracer => element_operation_tensorprod3D_Setup_ModalFilter_tracer_P<%=p%>
    procedure, public :: ModalFilter_tracer => element_operation_tensorprod3D_ModalFilter_tracer_P<%=p%>
    procedure, public :: ModalFilter_var5 => element_operation_tensorprod3D_ModalFilter_var5_P<%=p%>
  end type ElementOperationTensorProd3D_P<%=p%>
% end

contains
!OCL SERIAL
  subroutine ElementOperationTensorprod3D_create( elem3D, obj )
    use scale_prc, only: PRC_abort
    implicit none
    class(ElementBase3D), intent(in) :: elem3D
    class(ElementOperationTensorProd3D), intent(out), allocatable :: obj
    !-----------------------------------------------------

    if ( elem3D%PolyOrder_h /= elem3D%PolyOrder_v ) then
      LOG_INFO('ElemenetOperationTensorprod3D_create',*) 'PolyOrder_h and PolyOrder_v should be same in this module. ElemenetOperationGeneral should be used!'
      call PRC_abort
    end if

    select case( elem3D%PolyOrder_h )
% for p in 1..AUTOGEN_PMAX
    case(<%=p%>)
      allocate( ElementOperationTensorProd3D_P<%=p%> :: obj )
% end
    case default
      LOG_INFO('ElemenetOperationTensorprod3D_create',*) 'The specified polynomial order execceds <%=AUTOGEN_PMAX%> and is not supported in this module. ElemenetOperationGeneral should be used!'
      call PRC_abort
    end select
    call obj%Init( elem3D )

    return
  end subroutine ElementOperationTensorprod3D_create
  
% for p in 1..AUTOGEN_PMAX
% np = p+1

!--- For p=<%=p%> ------------------------------------

!> Initialization
!!
!OCL SERIAL
  subroutine element_operation_tensorprod3D_Init_P<%=p%>( this, elem3D )
    implicit none
    class(ElementOperationTensorProd3D_P<%=p%>), intent(inout) :: this
    class(ElementBase3D), intent(in), target :: elem3D
    !----------------------------------------------------------

    this%elem3D => elem3D

    call setup_elem_operator( this%D1D, this%D1D_tr, this%Lift_mat, this%IntrpMat_VPOrdM1_tr, &
      <%=np%>, elem3D )
    return
  end subroutine element_operation_tensorprod3D_Init_P<%=p%>

  !> Setup modal filter
  !!
!OCL SERIAL
  subroutine element_operation_tensorprod3D_Setup_ModalFilter_P<%=p%>( this, &
    MF_ETAC_h, MF_ALPHA_h, MF_ORDER_h, &
    MF_ETAC_v, MF_ALPHA_v, MF_ORDER_v )
    use scale_element_hexahedral, only: HexahedralElement
    use scale_element_line, only: LineElement
    implicit none
    class(ElementOperationTensorProd3D_P<%=p%>), intent(inout) :: this
    real(RP), intent(in) :: MF_ETAC_h
    real(RP), intent(in) :: MF_ALPHA_h
    integer, intent(in) :: MF_ORDER_h
    real(RP), intent(in) :: MF_ETAC_v
    real(RP), intent(in) :: MF_ALPHA_v
    integer, intent(in) :: MF_ORDER_v
    !--------------------------------------------------------

    call setup_ModalFilter( this%MFilter_h1D, this%MFilter_h1D_tr, this%MFilter_v1D_tr, &
      MF_ETAC_h, MF_ALPHA_h, MF_ORDER_h,               &
      MF_ETAC_v, MF_ALPHA_v, MF_ORDER_v,               &
      this%elem3D%PolyOrder_h, this%elem3D%PolyOrder_v )
    
    return
  end subroutine element_operation_tensorprod3D_Setup_ModalFilter_P<%=p%> 

  !> Setup modal filter for tracer
  !!
!OCL SERIAL
  subroutine element_operation_tensorprod3D_Setup_ModalFilter_tracer_P<%=p%>( this, &
    MF_ETAC_h, MF_ALPHA_h, MF_ORDER_h, &
    MF_ETAC_v, MF_ALPHA_v, MF_ORDER_v )
    use scale_element_hexahedral, only: HexahedralElement
    use scale_element_line, only: LineElement
    implicit none
    class(ElementOperationTensorProd3D_P<%=p%>), intent(inout) :: this
    real(RP), intent(in) :: MF_ETAC_h
    real(RP), intent(in) :: MF_ALPHA_h
    integer, intent(in) :: MF_ORDER_h
    real(RP), intent(in) :: MF_ETAC_v
    real(RP), intent(in) :: MF_ALPHA_v
    integer, intent(in) :: MF_ORDER_v
    !--------------------------------------------------------

    call setup_ModalFilter( this%MFilter_tracer_h1D, this%MFilter_tracer_h1D_tr, this%MFilter_tracer_v1D_tr, &
      MF_ETAC_h, MF_ALPHA_h, MF_ORDER_h,               &
      MF_ETAC_v, MF_ALPHA_v, MF_ORDER_v,               &
      this%elem3D%PolyOrder_h, this%elem3D%PolyOrder_v )
    
    return
  end subroutine element_operation_tensorprod3D_Setup_ModalFilter_tracer_P<%=p%> 

!> Finalization
!!
!OCL SERIAL
  subroutine element_operation_tensorprod3D_Final_P<%=p%>( this )
    implicit none
    class(ElementOperationTensorProd3D_P<%=p%>), intent(inout) :: this
    !----------------------------------------------------------
    nullify( this%elem3D )
    return
  end subroutine element_operation_tensorprod3D_Final_P<%=p%>

!> Calculate the differential in x-direction
!!
!OCL SERIAL
  subroutine element_operation_tensorprod3D_Dx_P<%=p%>( this, vec_in, vec_out )
    use scale_element_operation_tensorprod3D_kernel, only: element_operation_kernel_matvec_dirX_P<%=p%>
    implicit none
    class(ElementOperationTensorProd3D_P<%=p%>), intent(in) :: this
    real(RP), intent(in) :: vec_in(this%elem3D%Np)
    real(RP), intent(out) :: vec_out(this%elem3D%Np)
    !----------------------------------------------------------
    call element_operation_kernel_matvec_dirX_P<%=p%>( this%D1D, vec_in, vec_out )
    return
  end subroutine element_operation_tensorprod3D_Dx_P<%=p%>

!> Calculate the differential in z-direction
!!
!OCL SERIAL
  subroutine element_operation_tensorprod3D_Dy_P<%=p%>( this, vec_in, vec_out )
    use scale_element_operation_tensorprod3D_kernel, only: element_operation_kernel_matvec_dirY_P<%=p%>
    implicit none
    class(ElementOperationTensorProd3D_P<%=p%>), intent(in) :: this
    real(RP), intent(in) :: vec_in(this%elem3D%Np)
    real(RP), intent(out) :: vec_out(this%elem3D%Np)
    !----------------------------------------------------------
    call element_operation_kernel_matvec_dirY_P<%=p%>( this%D1D_tr, vec_in, vec_out )
    return
  end subroutine element_operation_tensorprod3D_Dy_P<%=p%>

!> Calculate the differential in z-direction
!!
!OCL SERIAL
  subroutine element_operation_tensorprod3D_Dz_P<%=p%>( this, vec_in, vec_out )
    use scale_element_operation_tensorprod3D_kernel, only: element_operation_kernel_matvec_dirZ_P<%=p%>
    implicit none
    class(ElementOperationTensorProd3D_P<%=p%>), intent(in) :: this
    real(RP), intent(in) :: vec_in(this%elem3D%Np)
    real(RP), intent(out) :: vec_out(this%elem3D%Np)
    !----------------------------------------------------------
    call element_operation_kernel_matvec_dirZ_P<%=p%>( this%D1D_tr, vec_in, vec_out )
    return
  end subroutine element_operation_tensorprod3D_Dz_P<%=p%>

!> Calculate the Lifting term
!!
!OCL SERIAL
  subroutine element_operation_tensorprod3D_Lift_P<%=p%>( this, vec_in, vec_out )
    use scale_element_operation_tensorprod3D_kernel, only: element_operation_kernel_matvec_Lift_hexahedral_P<%=p%>
    implicit none
    class(ElementOperationTensorProd3D_P<%=p%>), intent(in) :: this
    real(RP), intent(in) :: vec_in(this%elem3D%NfpTot)
    real(RP), intent(out) :: vec_out(this%elem3D%Np)
    !----------------------------------------------------------
    call element_operation_kernel_matvec_Lift_hexahedral_P<%=p%>( this%Lift_mat, vec_in, vec_out )
    return
  end subroutine element_operation_tensorprod3D_Lift_P<%=p%>

!> Calculate the 3D gradient
!!
!OCL SERIAL
  subroutine element_operation_tensorprod3D_DxDyDzLift_P<%=p%>( this, vec_in, vec_in_lift, vec_out_dx, vec_out_dy, vec_out_dz, vec_out_lift )
    use scale_element_operation_tensorprod3D_kernel, only: &
      element_operation_kernel_matvec_gradlike_dirXYZ_P<%=p%>, &
      element_operation_kernel_matvec_Lift_hexahedral_P<%=p%>
    implicit none
    class(ElementOperationTensorProd3D_P<%=p%>), intent(in) :: this
    real(RP), intent(in) :: vec_in(this%elem3D%Np)
    real(RP), intent(in) :: vec_in_lift(this%elem3D%NfpTot)
    real(RP), intent(out) :: vec_out_dx(this%elem3D%Np)
    real(RP), intent(out) :: vec_out_dy(this%elem3D%Np)
    real(RP), intent(out) :: vec_out_dz(this%elem3D%Np)
    real(RP), intent(out) :: vec_out_lift(this%elem3D%Np)
    !----------------------------------------------------------
    call element_operation_kernel_matvec_gradlike_dirXYZ_P<%=p%>( this%D1D, this%D1D_tr, vec_in, vec_in, &
      vec_out_dx, vec_out_dy, vec_out_dz )
    call element_operation_kernel_matvec_Lift_hexahedral_P<%=p%>( this%Lift_mat, vec_in_lift, &
      vec_out_lift )      

    return
  end subroutine element_operation_tensorprod3D_DxDyDzLift_P<%=p%>

!> Calculate the 3D divergence
!!
!! @param vec_in Array storing flux data (Fx,Fy,Fz) at nodes that we apply the differential matrices Dx, Dy, and Dz, respectively
!! @param vec_in_lift Array storing surface flux data (Fs) at nodes that we apply the lifting operator
!! @param vec_out Array storing the resulting data (Dx Fx, Dy Fy, Dz Fz, Lift Fs)
!!
!OCL SERIAL
  subroutine element_operation_tensorprod3D_Div_P<%=p%>(  this, vec_in, vec_in_lift, &
    vec_out )
    use scale_element_operation_tensorprod3D_kernel, only: &
      element_operation_kernel_matvec_divlike_dirXYZ_P<%=p%>, &
      element_operation_kernel_matvec_Lift_hexahedral_P<%=p%>
    implicit none
    class(ElementOperationTensorProd3D_P<%=p%>), intent(in) :: this
    real(RP), intent(in) :: vec_in(this%elem3D%Np,3)
    real(RP), intent(in) :: vec_in_lift(this%elem3D%NfpTot)
    real(RP), intent(out) :: vec_out(this%elem3D%Np,4)
    !----------------------------------------------------------

    call element_operation_kernel_matvec_Lift_hexahedral_P<%=p%>( this%Lift_mat, vec_in_lift, &
      vec_out(:,4) )      

    call element_operation_kernel_matvec_divlike_dirXYZ_P<%=p%>( this%D1D, this%D1D_tr, vec_in(:,1), vec_in(:,2), vec_in(:,3), &
      vec_out(:,1), vec_out(:,2), vec_out(:,3) )
    return
  end subroutine element_operation_tensorprod3D_Div_P<%=p%>

!> Calculate the 3D gradient
!!
!OCL SERIAL
  subroutine element_operation_tensorprod3D_Div_var5_P<%=p%>(  this, vec_in, vec_in_lift, &
    vec_out_d )
    use scale_element_operation_tensorprod3D_kernel, only: &
      element_operation_kernel_matvec_divlike_dirXYZ_P<%=p%>, &
      element_operation_kernel_matvec_Lift_hexahedral_P<%=p%>
    implicit none
    class(ElementOperationTensorProd3D_P<%=p%>), intent(in) :: this
    real(RP), intent(in) :: vec_in(this%elem3D%Np,3,5)
    real(RP), intent(in) :: vec_in_lift(this%elem3D%NfpTot,5)
    real(RP), intent(out) :: vec_out_d(this%elem3D%Np,4,5)

    integer :: iv
    !----------------------------------------------------------

    do iv=1, 5
      call element_operation_kernel_matvec_Lift_hexahedral_P<%=p%>( this%Lift_mat, vec_in_lift(:,iv), &
        vec_out_d(:,4,iv) )      
    end do
    do iv=1, 5
      call element_operation_kernel_matvec_divlike_dirXYZ_P<%=p%>( this%D1D, this%D1D_tr, vec_in(:,1,iv), vec_in(:,2,iv), vec_in(:,3,iv), &
        vec_out_d(:,1,iv), vec_out_d(:,2,iv), vec_out_d(:,3,iv) )
    end do
    return
  end subroutine element_operation_tensorprod3D_Div_var5_P<%=p%>

!> Calculate the 3D gradient
!!
!OCL SERIAL
  subroutine element_operation_tensorprod3D_Div_var5_2_P<%=p%>(  this, vec_in, &
    vec_out_d )
    use scale_element_operation_tensorprod3D_kernel, only: &
      element_operation_kernel_matvec_divlike_dirXYZ_P<%=p%>
    implicit none
    class(ElementOperationTensorProd3D_P<%=p%>), intent(in) :: this
    real(RP), intent(in) :: vec_in(this%elem3D%Np,3,5)
    real(RP), intent(out) :: vec_out_d(this%elem3D%Np,3,5)

    integer :: iv
    !----------------------------------------------------------

    do iv=1, 5
      call element_operation_kernel_matvec_divlike_dirXYZ_P<%=p%>( this%D1D, this%D1D_tr, vec_in(:,1,iv), vec_in(:,2,iv), vec_in(:,3,iv), &
        vec_out_d(:,1,iv), vec_out_d(:,2,iv), vec_out_d(:,3,iv) )
    end do
    return
  end subroutine element_operation_tensorprod3D_Div_var5_2_P<%=p%>
  
!OCL SERIAL
  subroutine element_operation_tensorprod3D_VFilterPM1_P<%=p%>( this, vec_in, vec_out )
    use scale_element_operation_tensorprod3D_kernel, only: element_operation_kernel_matvec_dirZ_P<%=p%>
    implicit none
    class(ElementOperationTensorProd3D_P<%=p%>), intent(in) :: this
    real(RP), intent(in) :: vec_in(this%elem3D%Np)
    real(RP), intent(out) :: vec_out(this%elem3D%Np)
    !---------------------------------------------------------------

    call element_operation_kernel_matvec_dirZ_P<%=p%>( this%IntrpMat_VPOrdM1_tr, vec_in, &
      vec_out )
    return
  end subroutine element_operation_tensorprod3D_VFilterPM1_P<%=p%> 

  !OCL SERIAL
  subroutine element_operation_tensorprod3D_ModalFilter_tracer_P<%=p%>( this, vec_in, vec_work, vec_out )
    use scale_element_operation_tensorprod3D_kernel, only: &
      element_operation_kernel_matvec_ModalFilter_P<%=p%>

    implicit none
    class(ElementOperationTensorProd3D_P<%=p%>), intent(in) :: this
    real(RP), intent(in) :: vec_in(this%elem3D%Np)
    real(RP), intent(out) :: vec_work(this%elem3D%Np)
    real(RP), intent(out) :: vec_out(this%elem3D%Np)
    !---------------------------------------------

    call element_operation_kernel_matvec_ModalFilter_P<%=p%>( this%MFilter_tracer_h1D, this%MFilter_tracer_h1D_tr, this%MFilter_tracer_v1D_tr, vec_in(:), vec_work, &
      vec_out(:) )
    
    return
  end subroutine element_operation_tensorprod3D_ModalFilter_tracer_P<%=p%> 
  
!OCL SERIAL
  subroutine element_operation_tensorprod3D_ModalFilter_var5_P<%=p%>( this, vec_in, vec_work, vec_out )
    use scale_element_operation_tensorprod3D_kernel, only: &
      element_operation_kernel_matvec_ModalFilter_P<%=p%>

    implicit none
    class(ElementOperationTensorProd3D_P<%=p%>), intent(in) :: this
    real(RP), intent(in) :: vec_in(this%elem3D%Np,5)
    real(RP), intent(out) :: vec_work(this%elem3D%Np)
    real(RP), intent(out) :: vec_out(this%elem3D%Np,5)
    integer :: iv
    !---------------------------------------------

    do iv=1, 5
      call element_operation_kernel_matvec_ModalFilter_P<%=p%>( this%MFilter_h1D, this%MFilter_h1D_tr, this%MFilter_v1D_tr, vec_in(:,iv), vec_work, &
        vec_out(:,iv) )
    end do
    
    return
  end subroutine element_operation_tensorprod3D_ModalFilter_var5_P<%=p%> 

% end

!- private -

!OCL SERIAL
  subroutine setup_ModalFilter( MFilter_h1D, MFilter_h1D_tr, MFilter_v1D_tr, &
    MF_ETAC_h, MF_ALPHA_h, MF_ORDER_h, &
    MF_ETAC_v, MF_ALPHA_v, MF_ORDER_v, &
    PolyOrder_h, PolyOrder_v )

    use scale_element_line, only: LineElement
    implicit none

    real(RP), intent(inout) :: MFilter_h1D(:,:)
    real(RP), intent(inout) :: MFilter_h1D_tr(:,:)
    real(RP), intent(inout) :: MFilter_v1D_tr(:,:)
    real(RP), intent(in) :: MF_ETAC_h
    real(RP), intent(in) :: MF_ALPHA_h
    integer, intent(in) :: MF_ORDER_h
    real(RP), intent(in) :: MF_ETAC_v
    real(RP), intent(in) :: MF_ALPHA_v
    integer, intent(in) :: MF_ORDER_v
    integer, intent(in) :: PolyOrder_h
    integer, intent(in) :: PolyOrder_v

    type(LineElement) :: elem1D
    type(ModalFilter) :: MFilter1D
    !--------------------------------------------------------

    call elem1D%Init( PolyOrder_h, .false. )      

    call MFilter1D%Init( elem1D, &
      MF_ETAC_h, MF_ALPHA_h, MF_ORDER_h      )
    MFilter_h1D(:,:) = MFilter1D%FilterMat(:,:)
    MFilter_h1D_tr(:,:) = transpose(MFilter_h1D(:,:))

    call MFilter1D%Final()
    call elem1D%Final()

    !-
    call elem1D%Init( PolyOrder_v, .false. )      

    call MFilter1D%Init( elem1D, &
      MF_ETAC_v, MF_ALPHA_v, MF_ORDER_v      )
    MFilter_v1D_tr(:,:) = transpose(MFilter1D%FilterMat(:,:))

    call MFilter1D%Final()
    call elem1D%Final()

    return
  end subroutine setup_ModalFilter

!OCL SERIAL
  subroutine setup_elem_operator( D1D, D1D_tr, Lift_mat, IntrpMat_VPOrdM1_tr, &
    np, elem3D )
    use scale_element_line, only: LineElement
    use scale_sparsemat, only: SparseMat
    implicit none
    integer, intent(in) :: np
    class(ElementBase3D), intent(in) :: elem3D
    real(RP), intent(out) :: D1D(np,np)
    real(RP), intent(out) :: D1D_tr(np,np)
    real(RP), intent(out) :: Lift_mat(np,np,np,6)
    real(RP), intent(out) :: IntrpMat_VPOrdM1_tr(np,np)

    integer :: p

    integer :: p1, p2, p_
    real(RP) :: invV_VPOrdM1(np,np)
    real(RP) :: IntrpMat_VPOrdM1(np,np)

    type(LineElement) :: elem1D
    type(SparseMat) :: Lift_sm
    integer :: i, j, k
    !----------------------------------------------------------

    call elem1D%Init( np-1, .false. )
    D1D(:,:) = elem1D%Dx1(:,:)
    D1D_tr(:,:) = transpose(D1D)

    call Lift_sm%Init( elem3D%Lift, storage_format='ELL' )
    do k=1, np
    do j=1, np
    do i=1, np
      p1 = i + (j-1)*np + (k-1)*np**2
      Lift_mat(i,j,k,1:6) = &
        (/ elem3D%Lift(p1,i+(k-1)*np), &
           elem3D%Lift(p1,j+(k-1)*np+(2-1)*np**2), &
           elem3D%Lift(p1,i+(k-1)*np+(3-1)*np**2), &
           elem3D%Lift(p1,j+(k-1)*np+(4-1)*np**2), &
           elem3D%Lift(p1,i+(j-1)*np+(5-1)*np**2), &
           elem3D%Lift(p1,i+(j-1)*np+(6-1)*np**2) /)
    end do
    end do
    end do
    call Lift_sm%Final()

    !--

    InvV_VPOrdM1(:,:) = elem1D%invV(:,:)
    InvV_VPOrdM1(np,:) = 0.0_RP
    IntrpMat_VPOrdM1(:,:) = matmul(elem1D%V, invV_VPOrdM1)
    IntrpMat_VPOrdM1_tr(:,:) = transpose(IntrpMat_VPOrdM1)

    !-
    call elem1D%Final()

    return
  end subroutine setup_elem_operator

end module scale_element_operation_tensorprod3D