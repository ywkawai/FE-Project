<% AUTOGEN_PMAX = 15 %>
!-------------------------------------------------------------------------------
! Warning: This file was generated from <%=__FILE__%>.
!          Do not edit this file.
!-------------------------------------------------------------------------------
!-------------------------------------------------------------------------------
!> module FElib / Element / Operation with 3D tensor product elements
!!
!! @par Description
!!           A module for providing mathematical operations assuming a 3D tensor product element with (p+1)^3 DOF
!!
!! @author Yuta Kawai, Xuanzhengbo Ren, and Team SCALE
!!
!<
#include "scaleFElib.h"
module scale_element_operation_tensorprod3D

  !-----------------------------------------------------------------------------
  !
  !++ used modules
  !
  use scale_precision
  use scale_io

  use scale_element_base, only: &
    ElementBase3D, &
    ElementBase3D_Init, ElementBase3D_Final

  use scale_element_operation_base, only: ElementOperationBase3D

  !-----------------------------------------------------------------------------
  implicit none
  private

  !-----------------------------------------------------------------------------
  !
  !++ Public type & procedure
  !  

  type, public, abstract, extends(ElementOperationBase3D) :: ElementOperationTensorProd3D
  contains
    procedure(ElementOperationTensorProd3D_Init), deferred, public :: Init
    procedure(ElementOperationTensorProd3D_Final), deferred, public :: Final
  end type ElementOperationTensorProd3D

  interface
    subroutine ElementOperationTensorProd3D_Init( this, elem3D )
      import ElementOperationTensorProd3D
      import ElementBase3D
      class(ElementOperationTensorProd3D), intent(inout) :: this
      class(ElementBase3D), intent(in), target :: elem3D
    end subroutine ElementOperationTensorProd3D_Init

    subroutine ElementOperationTensorProd3D_Final( this )
      import ElementOperationTensorProd3D
      class(ElementOperationTensorProd3D), intent(inout) :: this
    end subroutine ElementOperationTensorProd3D_Final
  end interface

  public :: ElementOperationTensorprod3D_create

% for p in 1..AUTOGEN_PMAX
% np = p+1  
  type, public, extends(ElementOperationTensorProd3D) :: ElementOperationTensorProd3D_P<%=p%>
    real(RP) :: D1D(<%=np%>,<%=np%>)
    real(RP) :: D1D_tr(<%=np%>,<%=np%>)
    real(RP) :: Lift_mat(<%=np%>,<%=np%>,<%=np%>,6)
    real(RP) :: IntrpMat_VPOrdM1(<%=np%>,<%=np%>)

  contains
    procedure, public :: Init => element_operation_tensorprod3D_Init_P<%=p%>
    procedure, public :: Final => element_operation_tensorprod3D_Final_P<%=p%>
    procedure, public :: Dx => element_operation_tensorprod3D_Dx_P<%=p%>
    procedure, public :: Dy => element_operation_tensorprod3D_Dy_P<%=p%>
    procedure, public :: Dz => element_operation_tensorprod3D_Dz_P<%=p%>
    procedure, public :: Lift => element_operation_tensorprod3D_Lift_P<%=p%>
    procedure, public :: DxDyDzLift => element_operation_tensorprod3D_DxDyDzLift_P<%=p%>
    procedure, public :: Div => element_operation_tensorprod3D_Div_P<%=p%>
    procedure, public :: VFilterPM1 => element_operation_tensorprod3D_VFilterPM1_P<%=p%>
  end type ElementOperationTensorProd3D_P<%=p%>
% end

contains
!OCL SERIAL
  subroutine ElementOperationTensorprod3D_create( elem3D, obj )
    use scale_prc, only: PRC_abort
    implicit none
    class(ElementBase3D), intent(in) :: elem3D
    class(ElementOperationTensorProd3D), intent(out), allocatable :: obj
    !-----------------------------------------------------

    if ( elem3D%PolyOrder_h /= elem3D%PolyOrder_v ) then
      LOG_INFO('ElemenetOperationTensorprod3D_create',*) 'PolyOrder_h and PolyOrder_v should be same in this module. ElemenetOperationGeneral should be used!'
      call PRC_abort
    end if

    select case( elem3D%PolyOrder_h )
% for p in 1..AUTOGEN_PMAX
    case(<%=p%>)
      allocate( ElementOperationTensorProd3D_P<%=p%> :: obj )
% end
    case default
      LOG_INFO('ElemenetOperationTensorprod3D_create',*) 'The specified polynomial order execceds <%=AUTOGEN_PMAX%> and is not supported in this module. ElemenetOperationGeneral should be used!'
      call PRC_abort
    end select
    call obj%Init( elem3D )

    return
  end subroutine ElementOperationTensorprod3D_create

% for p in 1..AUTOGEN_PMAX
% np = p+1

!--- For p=<%=p%> ------------------------------------

!> Initialization
!!
!OCL SERIAL
  subroutine element_operation_tensorprod3D_Init_P<%=p%>( this, elem3D )
    use scale_element_line, only: LineElement
    use scale_sparsemat, only: SparseMat
    implicit none
    class(ElementOperationTensorProd3D_P<%=p%>), intent(inout) :: this
    class(ElementBase3D), intent(in), target :: elem3D

    integer :: p

    integer :: p1, p2, p_
    real(RP) :: invV_VPOrdM1(<%=np%>,<%=np%>)

    type(LineElement) :: elem1D
    type(SparseMat) :: Lift_sm
    !----------------------------------------------------------
    this%elem3D => elem3D

    call elem1D%Init( <%=p%>, .false. )
    this%D1D(:,:) = elem1D%Dx1(:,:)
    this%D1D_tr(:,:) = transpose(this%D1D)

    call Lift_sm%Init( elem3D%Lift, storage_format='ELL' )
    this%Lift_mat(:,:,:,:) = reshape(Lift_sm%val, (/ <%=np%>,<%=np%>,<%=np%>,6 /) )
    call Lift_sm%Final()

    !--

    InvV_VPOrdM1(:,:) = elem1D%invV(:,:)
    InvV_VPOrdM1(<%=np%>,:) = 0.0_RP
    this%IntrpMat_VPOrdM1(:,:) = matmul(elem1D%V, invV_VPOrdM1)

    !-
    call elem1D%Final()

    return
  end subroutine element_operation_tensorprod3D_Init_P<%=p%>

!> Finalization
!!
!OCL SERIAL
  subroutine element_operation_tensorprod3D_Final_P<%=p%>( this )
    implicit none
    class(ElementOperationTensorProd3D_P<%=p%>), intent(inout) :: this
    !----------------------------------------------------------
    nullify( this%elem3D )
    return
  end subroutine element_operation_tensorprod3D_Final_P<%=p%>

!> Calculate the differential in x-direction
!!
!OCL SERIAL
  subroutine element_operation_tensorprod3D_Dx_P<%=p%>( this, vec_in, vec_out )
    use scale_element_operation_tensorprod3D_kernel, only: element_operation_kernel_matvec_dirX_P<%=p%>
    implicit none
    class(ElementOperationTensorProd3D_P<%=p%>), intent(in) :: this
    real(RP), intent(in) :: vec_in(this%elem3D%Np)
    real(RP), intent(out) :: vec_out(this%elem3D%Np)
    !----------------------------------------------------------
    call element_operation_kernel_matvec_dirX_P<%=p%>( this%D1D, vec_in, vec_out )
    return
  end subroutine element_operation_tensorprod3D_Dx_P<%=p%>

!> Calculate the differential in z-direction
!!
!OCL SERIAL
  subroutine element_operation_tensorprod3D_Dy_P<%=p%>( this, vec_in, vec_out )
    use scale_element_operation_tensorprod3D_kernel, only: element_operation_kernel_matvec_dirY_P<%=p%>
    implicit none
    class(ElementOperationTensorProd3D_P<%=p%>), intent(in) :: this
    real(RP), intent(in) :: vec_in(this%elem3D%Np)
    real(RP), intent(out) :: vec_out(this%elem3D%Np)
    !----------------------------------------------------------
    call element_operation_kernel_matvec_dirY_P<%=p%>( this%D1D_tr, vec_in, vec_out )
    return
  end subroutine element_operation_tensorprod3D_Dy_P<%=p%>

!> Calculate the differential in z-direction
!!
!OCL SERIAL
  subroutine element_operation_tensorprod3D_Dz_P<%=p%>( this, vec_in, vec_out )
    use scale_element_operation_tensorprod3D_kernel, only: element_operation_kernel_matvec_dirZ_P<%=p%>
    implicit none
    class(ElementOperationTensorProd3D_P<%=p%>), intent(in) :: this
    real(RP), intent(in) :: vec_in(this%elem3D%Np)
    real(RP), intent(out) :: vec_out(this%elem3D%Np)
    !----------------------------------------------------------
    call element_operation_kernel_matvec_dirZ_P<%=p%>( this%D1D_tr, vec_in, vec_out )
    return
  end subroutine element_operation_tensorprod3D_Dz_P<%=p%>

!> Calculate the Lifting term
!!
!OCL SERIAL
  subroutine element_operation_tensorprod3D_Lift_P<%=p%>( this, vec_in, vec_out )
    use scale_element_operation_tensorprod3D_kernel, only: element_operation_kernel_matvec_Lift_hexahedral_P<%=p%>
    implicit none
    class(ElementOperationTensorProd3D_P<%=p%>), intent(in) :: this
    real(RP), intent(in) :: vec_in(this%elem3D%NfpTot)
    real(RP), intent(out) :: vec_out(this%elem3D%Np)
    !----------------------------------------------------------
    call element_operation_kernel_matvec_Lift_hexahedral_P<%=p%>( this%Lift_mat, vec_in, vec_out )
    return
  end subroutine element_operation_tensorprod3D_Lift_P<%=p%>

!> Calculate the 3D gradient
!!
!OCL SERIAL
  subroutine element_operation_tensorprod3D_DxDyDzLift_P<%=p%>( this, vec_in, vec_in_lift, vec_out_dx, vec_out_dy, vec_out_dz, vec_out_lift )
    use scale_element_operation_tensorprod3D_kernel, only: &
      element_operation_kernel_matvec_gradlike_dirXYZ_P<%=p%>, &
      element_operation_kernel_matvec_Lift_hexahedral_P<%=p%>
    implicit none
    class(ElementOperationTensorProd3D_P<%=p%>), intent(in) :: this
    real(RP), intent(in) :: vec_in(this%elem3D%Np)
    real(RP), intent(in) :: vec_in_lift(this%elem3D%NfpTot)
    real(RP), intent(out) :: vec_out_dx(this%elem3D%Np)
    real(RP), intent(out) :: vec_out_dy(this%elem3D%Np)
    real(RP), intent(out) :: vec_out_dz(this%elem3D%Np)
    real(RP), intent(out) :: vec_out_lift(this%elem3D%Np)
    !----------------------------------------------------------
    call element_operation_kernel_matvec_gradlike_dirXYZ_P<%=p%>( this%D1D, this%D1D_tr, vec_in, vec_in, &
      vec_out_dx, vec_out_dy, vec_out_dz )
    call element_operation_kernel_matvec_Lift_hexahedral_P<%=p%>( this%Lift_mat, vec_in_lift, &
      vec_out_lift )      

    return
  end subroutine element_operation_tensorprod3D_DxDyDzLift_P<%=p%>

!> Calculate the 3D gradient
!!
!OCL SERIAL
  subroutine element_operation_tensorprod3D_Div_P<%=p%>(  this, vec_in_x, vec_in_y, vec_in_z, vec_in_lift, Escale, Gsqrt, sign_, &
    vec_out_dx, vec_out_dy, vec_out_dz, vec_out_lift, vec_out )
    use scale_element_operation_tensorprod3D_kernel, only: &
      element_operation_kernel_matvec_divlike_dirXYZ_P<%=p%>, &
      element_operation_kernel_matvec_Lift_hexahedral_P<%=p%>
    implicit none
    class(ElementOperationTensorProd3D_P<%=p%>), intent(in) :: this
    real(RP), intent(in) :: vec_in_x(this%elem3D%Np)
    real(RP), intent(in) :: vec_in_y(this%elem3D%Np)
    real(RP), intent(in) :: vec_in_z(this%elem3D%Np)
    real(RP), intent(in) :: vec_in_lift(this%elem3D%NfpTot)
    real(RP), intent(in) :: Escale(3,this%elem3D%Np)
    real(RP), intent(in) :: Gsqrt(this%elem3D%Np)
    real(RP), intent(in) :: sign_    
    real(RP), intent(out) :: vec_out_dx(this%elem3D%Np)
    real(RP), intent(out) :: vec_out_dy(this%elem3D%Np)
    real(RP), intent(out) :: vec_out_dz(this%elem3D%Np)
    real(RP), intent(out) :: vec_out_lift(this%elem3D%Np)
    real(RP), intent(out) :: vec_out(this%elem3D%Np)
    !----------------------------------------------------------

    call element_operation_kernel_matvec_Lift_hexahedral_P<%=p%>( this%Lift_mat, vec_in_lift, &
      vec_out_lift )      

    call element_operation_kernel_matvec_divlike_dirXYZ_P<%=p%>( this%D1D, this%D1D_tr, vec_in_x, vec_in_y, vec_in_z, Escale, Gsqrt, vec_out_lift, sign_, &
      vec_out_dx, vec_out_dy, vec_out_dz, vec_out )

    return
  end subroutine element_operation_tensorprod3D_Div_P<%=p%>

  subroutine element_operation_tensorprod3D_VFilterPM1_P<%=p%>( this, vec_in, vec_out )
    use scale_element_operation_tensorprod3D_kernel, only: element_operation_kernel_matvec_dirZ_P<%=p%>
    implicit none
    class(ElementOperationTensorProd3D_P<%=p%>), intent(in) :: this
    real(RP), intent(in) :: vec_in(this%elem3D%Np)
    real(RP), intent(out) :: vec_out(this%elem3D%Np)
    !---------------------------------------------------------------

    call element_operation_kernel_matvec_dirZ_P<%=p%>( this%IntrpMat_VPOrdM1, vec_in, &
      vec_out )
    return
  end subroutine element_operation_tensorprod3D_VFilterPM1_P<%=p%> 

% end

end module scale_element_operation_tensorprod3D