<% AUTOGEN_PMAX = 13 %>
!-------------------------------------------------------------------------------
! Warning: This file was generated from <%=__FILE__%>.
!          Do not edit this file.
!-------------------------------------------------------------------------------
!-------------------------------------------------------------------------------
!> module FElib / Element / Operation with 3D tensor product elements
!!
!! @par Description
!!           A module for providing mathematical operations assuming a 3D tensor product element with (p+1)^3 DOF
!!
!! @author Yuta Kawai, Xuanzhengbo Ren, and Team SCALE
!!
!<
#include "scaleFElib.h"
module scale_element_operation_tensorprod3D

  !-----------------------------------------------------------------------------
  !
  !++ used modules
  !
  use scale_precision

  use scale_element_base, only: &
    ElementBase3D, &
    ElementBase3D_Init, ElementBase3D_Final

  use scale_element_operation_base, only: ElementOperationBase3D

  !-----------------------------------------------------------------------------
  implicit none
  private

  !-----------------------------------------------------------------------------
  !
  !++ Public type & procedure
  !  
% for p in 1..AUTOGEN_PMAX
% np = p+1  
  type, public, extends(ElementOperationBase3D) :: ElementOperationTensorProd3D_P<%=p%>
    real(RP) :: Dx1D(<%=np%>,<%=np%>)
    real(RP) :: Dy1D(<%=np%>,<%=np%>)
    real(RP) :: Dz1D(<%=np%>,<%=np%>)
    real(RP) :: Dy1D_tr(<%=np%>,<%=np%>)
    real(RP) :: Dz1D_tr(<%=np%>,<%=np%>)
  contains
    procedure, public :: Dx => element_operation_tensorprod3D_Dx_P<%=p%>
    procedure, public :: Dy => element_operation_tensorprod3D_Dy_P<%=p%>
    procedure, public :: Dz => element_operation_tensorprod3D_Dz_P<%=p%>
    procedure, public :: Grad => element_operation_tensorprod3D_Grad_P<%=p%>
  end type ElementOperationTensorProd3D_P<%=p%>
% end

contains
% for p in 1..AUTOGEN_PMAX
% np = p+1

!> Calculate the differential in x-direction
!!
!OCL SERIAL
  subroutine element_operation_tensorprod3D_Dx_P<%=p%>( this, vec_in, vec_out )
    use scale_element_operation_tensorprod3D_kernel, only: element_operation_tensorprod3D_kernel_matrix_vec_dirX_P<%=p%>
    implicit none
    class(ElementOperationTensorProd3D_P<%=p%>), intent(in) :: this
    real(RP), intent(in) :: vec_in(this%Np1D,this%Np1D**2)
    real(RP), intent(out) :: vec_out(this%Np1D,this%Np1D**2)
    !----------------------------------------------------------
    call element_tensorprod3D_operation_kernel_matrix_vec_dirX_P<%=p%>( this%Dx1D, vec_in, vec_out )
    return
  end subroutine element_operation_tensorprod3D_Dx_P<%=p%>
% end

!-------------------------------------------------------------

% for p in 1..AUTOGEN_PMAX
% np = p+1

!> Calculate the differential in z-direction
!!
!OCL SERIAL
  subroutine element_operation_tensorprod3D_Dy_P<%=p%>( this, vec_in, vec_out )
    use scale_element_operation_tensorprod3D_kernel, only: element_operation_tensorprod3D_kernel_matrix_vec_dirY_P<%=p%>
    implicit none
    class(ElementOperationTensorProd3D_P<%=p%>), intent(in) :: this
    real(RP), intent(in) :: vec_in(this%Np1D,this%Np1D,this%Np1D)
    real(RP), intent(out) :: vec_out(this%Np1D,this%Np1D,this%Np1D)
    !----------------------------------------------------------
    call element_tensorprod3D_operation_kernel_matrix_vec_dirY_P<%=p%>( this%Dy1D_tr, vec_in, vec_out )
    return
  end subroutine element_operation_tensorprod3D_Dy_P<%=p%>
% end

!-------------------------------------------------------------

% for p in 1..AUTOGEN_PMAX
% np = p+1

!> Calculate the differential in z-direction
!!
!OCL SERIAL
  subroutine element_operation_tensorprod3D_Dz_P<%=p%>( this, vec_in, vec_out )
    use scale_element_operation_tensorprod3D_kernel, only: element_operation_tensorprod3D_kernel_matrix_vec_dirZ_P<%=p%>
    implicit none
    class(ElementOperationTensorProd3D_P<%=p%>), intent(in) :: this
    real(RP), intent(in) :: vec_in(this%Np1D,this%Np1D,this%Np1D)
    real(RP), intent(out) :: vec_out(this%Np1D,this%Np1D,this%Np1D)
    !----------------------------------------------------------
    call element_tensorprod3D_operation_kernel_matrix_vec_dirZ_P<%=p%>( this%Dz1D_tr, vec_in, vec_out )
    return
  end subroutine element_operation_tensorprod3D_Dz_P<%=p%>
% end

!-------------------------------------------------------------

% for p in 1..AUTOGEN_PMAX
% np = p+1

!> Calculate the differential in z-direction
!!
!OCL SERIAL
  subroutine element_operation_tensorprod3D_Grad_P<%=p%>( this, vec_in, vec_out_dx, vec_out_dy, vec_out_dz )
    use scale_element_operation_tensorprod3D_kernel, only: element_operation_tensorprod3D_kernel_matrix_vec_gradlike_dirXYZ_P<%=p%>
    implicit none
    class(ElementOperationTensorProd3D_P<%=p%>), intent(in) :: this
    real(RP), intent(in) :: vec_in(this%Np1D,this%Np1D,this%Np1D)
    real(RP), intent(out) :: vec_out_dx(this%Np1D,this%Np1D,this%Np1D)
    real(RP), intent(out) :: vec_out_dy(this%Np1D,this%Np1D,this%Np1D)
    real(RP), intent(out) :: vec_out_dz(this%Np1D,this%Np1D,this%Np1D)
    !----------------------------------------------------------
    call element_tensorprod3D_operation_kernel_matrix_vec_gradlike_dirXYZ_P<%=p%>( this%Dx1D, this%Dy1D_tr, this%Dz1D_tr, vec_in, &
      vec_out_dx, vec_out_dy, vec_out_dz )
    return
  end subroutine element_operation_tensorprod3D_Grad_P<%=p%>
% end

end module scale_element_operation_tensorprod3D