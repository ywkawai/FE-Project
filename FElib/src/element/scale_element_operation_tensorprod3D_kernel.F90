
!-------------------------------------------------------------------------------
! Warning: This file was generated from element/scale_element_operation_tensorprod3D_kernel.F90.erb.
!          Do not edit this file.
!-------------------------------------------------------------------------------
!-------------------------------------------------------------------------------
!> module FElib / Element / Operation with 3D tensor product elements
!!
!! @par Description
!!           A module for providing kernels of matrix and vector operations assuming a 3D tensor product element with (p+1)^3 DOF
!!
!! @author Yuta Kawai, Xuanzhengbo Ren, and Team SCALE
!!
!<
#include "scaleFElib.h"
module scale_element_operation_tensorprod3D_kernel

  !-----------------------------------------------------------------------------
  !
  !++ used modules
  !
  use scale_precision

  use scale_element_base, only: &
    ElementBase3D, &
    ElementBase3D_Init, ElementBase3D_Final
  !-----------------------------------------------------------------------------
  implicit none
  private

  !-----------------------------------------------------------------------------
  !
  !++ Public type & procedure
  !  
  public :: element_operation_kernel_matvec_dirX_P1
  public :: element_operation_kernel_matvec_dirY_P1  
  public :: element_operation_kernel_matvec_dirZ_P1
  public :: element_operation_kernel_matvec_Lift_hexahedral_P1
  public :: element_operation_kernel_matvec_gradlike_dirXYZ_P1
  public :: element_operation_kernel_matvec_divlike_dirXYZ_P1
  public :: element_operation_kernel_matvec_ModalFilter_P1
  public :: element_operation_kernel_matvec_dirX_P2
  public :: element_operation_kernel_matvec_dirY_P2  
  public :: element_operation_kernel_matvec_dirZ_P2
  public :: element_operation_kernel_matvec_Lift_hexahedral_P2
  public :: element_operation_kernel_matvec_gradlike_dirXYZ_P2
  public :: element_operation_kernel_matvec_divlike_dirXYZ_P2
  public :: element_operation_kernel_matvec_ModalFilter_P2
  public :: element_operation_kernel_matvec_dirX_P3
  public :: element_operation_kernel_matvec_dirY_P3  
  public :: element_operation_kernel_matvec_dirZ_P3
  public :: element_operation_kernel_matvec_Lift_hexahedral_P3
  public :: element_operation_kernel_matvec_gradlike_dirXYZ_P3
  public :: element_operation_kernel_matvec_divlike_dirXYZ_P3
  public :: element_operation_kernel_matvec_ModalFilter_P3
  public :: element_operation_kernel_matvec_dirX_P4
  public :: element_operation_kernel_matvec_dirY_P4  
  public :: element_operation_kernel_matvec_dirZ_P4
  public :: element_operation_kernel_matvec_Lift_hexahedral_P4
  public :: element_operation_kernel_matvec_gradlike_dirXYZ_P4
  public :: element_operation_kernel_matvec_divlike_dirXYZ_P4
  public :: element_operation_kernel_matvec_ModalFilter_P4
  public :: element_operation_kernel_matvec_dirX_P5
  public :: element_operation_kernel_matvec_dirY_P5  
  public :: element_operation_kernel_matvec_dirZ_P5
  public :: element_operation_kernel_matvec_Lift_hexahedral_P5
  public :: element_operation_kernel_matvec_gradlike_dirXYZ_P5
  public :: element_operation_kernel_matvec_divlike_dirXYZ_P5
  public :: element_operation_kernel_matvec_ModalFilter_P5
  public :: element_operation_kernel_matvec_dirX_P6
  public :: element_operation_kernel_matvec_dirY_P6  
  public :: element_operation_kernel_matvec_dirZ_P6
  public :: element_operation_kernel_matvec_Lift_hexahedral_P6
  public :: element_operation_kernel_matvec_gradlike_dirXYZ_P6
  public :: element_operation_kernel_matvec_divlike_dirXYZ_P6
  public :: element_operation_kernel_matvec_ModalFilter_P6
  public :: element_operation_kernel_matvec_dirX_P7
  public :: element_operation_kernel_matvec_dirY_P7  
  public :: element_operation_kernel_matvec_dirZ_P7
  public :: element_operation_kernel_matvec_Lift_hexahedral_P7
  public :: element_operation_kernel_matvec_gradlike_dirXYZ_P7
  public :: element_operation_kernel_matvec_divlike_dirXYZ_P7
  public :: element_operation_kernel_matvec_ModalFilter_P7
  public :: element_operation_kernel_matvec_dirX_P8
  public :: element_operation_kernel_matvec_dirY_P8  
  public :: element_operation_kernel_matvec_dirZ_P8
  public :: element_operation_kernel_matvec_Lift_hexahedral_P8
  public :: element_operation_kernel_matvec_gradlike_dirXYZ_P8
  public :: element_operation_kernel_matvec_divlike_dirXYZ_P8
  public :: element_operation_kernel_matvec_ModalFilter_P8
  public :: element_operation_kernel_matvec_dirX_P9
  public :: element_operation_kernel_matvec_dirY_P9  
  public :: element_operation_kernel_matvec_dirZ_P9
  public :: element_operation_kernel_matvec_Lift_hexahedral_P9
  public :: element_operation_kernel_matvec_gradlike_dirXYZ_P9
  public :: element_operation_kernel_matvec_divlike_dirXYZ_P9
  public :: element_operation_kernel_matvec_ModalFilter_P9
  public :: element_operation_kernel_matvec_dirX_P10
  public :: element_operation_kernel_matvec_dirY_P10  
  public :: element_operation_kernel_matvec_dirZ_P10
  public :: element_operation_kernel_matvec_Lift_hexahedral_P10
  public :: element_operation_kernel_matvec_gradlike_dirXYZ_P10
  public :: element_operation_kernel_matvec_divlike_dirXYZ_P10
  public :: element_operation_kernel_matvec_ModalFilter_P10
  public :: element_operation_kernel_matvec_dirX_P11
  public :: element_operation_kernel_matvec_dirY_P11  
  public :: element_operation_kernel_matvec_dirZ_P11
  public :: element_operation_kernel_matvec_Lift_hexahedral_P11
  public :: element_operation_kernel_matvec_gradlike_dirXYZ_P11
  public :: element_operation_kernel_matvec_divlike_dirXYZ_P11
  public :: element_operation_kernel_matvec_ModalFilter_P11
  public :: element_operation_kernel_matvec_dirX_P12
  public :: element_operation_kernel_matvec_dirY_P12  
  public :: element_operation_kernel_matvec_dirZ_P12
  public :: element_operation_kernel_matvec_Lift_hexahedral_P12
  public :: element_operation_kernel_matvec_gradlike_dirXYZ_P12
  public :: element_operation_kernel_matvec_divlike_dirXYZ_P12
  public :: element_operation_kernel_matvec_ModalFilter_P12
  public :: element_operation_kernel_matvec_dirX_P13
  public :: element_operation_kernel_matvec_dirY_P13  
  public :: element_operation_kernel_matvec_dirZ_P13
  public :: element_operation_kernel_matvec_Lift_hexahedral_P13
  public :: element_operation_kernel_matvec_gradlike_dirXYZ_P13
  public :: element_operation_kernel_matvec_divlike_dirXYZ_P13
  public :: element_operation_kernel_matvec_ModalFilter_P13
  public :: element_operation_kernel_matvec_dirX_P14
  public :: element_operation_kernel_matvec_dirY_P14  
  public :: element_operation_kernel_matvec_dirZ_P14
  public :: element_operation_kernel_matvec_Lift_hexahedral_P14
  public :: element_operation_kernel_matvec_gradlike_dirXYZ_P14
  public :: element_operation_kernel_matvec_divlike_dirXYZ_P14
  public :: element_operation_kernel_matvec_ModalFilter_P14
  public :: element_operation_kernel_matvec_dirX_P15
  public :: element_operation_kernel_matvec_dirY_P15  
  public :: element_operation_kernel_matvec_dirZ_P15
  public :: element_operation_kernel_matvec_Lift_hexahedral_P15
  public :: element_operation_kernel_matvec_gradlike_dirXYZ_P15
  public :: element_operation_kernel_matvec_divlike_dirXYZ_P15
  public :: element_operation_kernel_matvec_ModalFilter_P15

contains
!--- For p=1 ------------------------------------

!> Calculate a matrix-vector multiplication associated with mathematical operations in the x direction (first dimension of vec_in) with p=1
!!
!OCL SERIAL
  subroutine element_operation_kernel_matvec_dirX_P1( Mat_x, vec_in, vec_out )
    implicit none
    real(RP), intent(in) :: Mat_x(2,2)
    real(RP), intent(in) :: vec_in(2,2**2)
    real(RP), intent(out) :: vec_out(2,2**2)

    integer :: i, jk
    !----------------------------------------------------------

    do jk=1, 2**2
    do i=1, 2
        vec_out(i,jk) = Mat_x(i,1) * vec_in(1,jk) &
                      + Mat_x(i,2) * vec_in(2,jk)
    end do
    end do

    return
  end subroutine element_operation_kernel_matvec_dirX_P1

!> Calculate a matrix-vector multiplication associated with mathematical operations in the y direction (second dimension of vec_in) with p=1
!! For a matrix-vector multiplication (vec_out = Mat_y vec_in), the passed variable of Mat_y should be transposed.
!!
!OCL SERIAL
  subroutine element_operation_kernel_matvec_dirY_P1( Mat_y_tr, vec_in, vec_out )
    implicit none
    real(RP), intent(in) :: Mat_y_tr(2,2)
    real(RP), intent(in) :: vec_in(2,2,2)
    real(RP), intent(out) :: vec_out(2,2,2)

    integer :: i, j, k
    !----------------------------------------------------------

    do k=1, 2
    do j=1, 2
    do i=1, 2
        vec_out(i,j,k) = vec_in(i,1,k) * Mat_y_tr(1,j) &
                       + vec_in(i,2,k) * Mat_y_tr(2,j) 
    end do
    end do
    end do

    return
  end subroutine element_operation_kernel_matvec_dirY_P1

!> Calculate a matrix-vector multiplication associated with mathematical operations in the z direction (third dimension of vec_in) with p=1
!! For a matrix-vector multiplication (vec_out = Mat_z vec_in), the passed variable of Mat_z should be transposed.
!!
!OCL SERIAL
  subroutine element_operation_kernel_matvec_dirZ_P1( Mat_z_tr, vec_in, vec_out )
    implicit none
    real(RP), intent(in) :: Mat_z_tr(2,2)
    real(RP), intent(in) :: vec_in(2,2,2)
    real(RP), intent(out) :: vec_out(2,2,2)

    integer :: i, j, k
    !----------------------------------------------------------

    do k=1, 2
    do j=1, 2
    do i=1, 2
        vec_out(i,j,k) = vec_in(i,j,1) * Mat_z_tr(1,k) &
                       + vec_in(i,j,2) * Mat_z_tr(2,k) 
    end do
    end do
    end do

    return
  end subroutine element_operation_kernel_matvec_dirZ_P1

!> Calculate a matrix-vector multiplication with lifting operations for a hexahedral element of order p=1
!!
!OCL SERIAL
  subroutine element_operation_kernel_matvec_Lift_hexahedral_P1( Lift, vec_in, vec_out )
    implicit none
    real(RP), intent(in) :: Lift(2,2,2,6)
    real(RP), intent(in) :: vec_in(2,2,6)
    real(RP), intent(out) :: vec_out(2,2,2)

    integer :: i, j, k
    !----------------------------------------------------------

    do k=1, 2
    do j=1, 2
    do i=1, 2
        vec_out(i,j,k) = Lift(i,j,k,1) * vec_in(i,k,1) &
                       + Lift(i,j,k,2) * vec_in(j,k,2) &
                       + Lift(i,j,k,3) * vec_in(i,k,3) &
                       + Lift(i,j,k,4) * vec_in(j,k,4) &
                       + Lift(i,j,k,5) * vec_in(i,j,5) &
                       + Lift(i,j,k,6) * vec_in(i,j,6)
    end do
    end do
    end do

    return
  end subroutine element_operation_kernel_matvec_Lift_hexahedral_P1
  
!> Calculate a matrix-vector multiplication associated with mathematical operations in the x, y, and z direction (third dimension of vec_in) with p=1
!! For a matrix-vector multiplication (vec_d_out = Mat_d vec_in where d=x,y,z), the passed variables of Mat_y and Mat_z should be transposed.
!! Note that we assume that vec_in_ has same data as vec_in, but are reshaped via the call of this subroutine. 
!!
!OCL SERIAL
  subroutine element_operation_kernel_matvec_gradlike_dirXYZ_P1( Mat, Mat_tr, vec_in, vec_in_, &
    vec_out_x, vec_out_y, vec_out_z  )
    implicit none
    real(RP), intent(in) :: Mat(2,2)
    real(RP), intent(in) :: Mat_tr(2,2)
    real(RP), intent(in) :: vec_in_(2,2**2)
    real(RP), intent(in) :: vec_in(2,2,2)
    real(RP), intent(out) :: vec_out_x(2,2**2)
    real(RP), intent(out) :: vec_out_y(2,2,2)
    real(RP), intent(out) :: vec_out_z(2,2,2)

    integer :: i, j, k, jk
    !----------------------------------------------------------

    ! X-dir

    do jk=1, 2**2
    do i=1, 2
        vec_out_x(i,jk) = Mat(i,1) * vec_in_(1,jk) &
                        + Mat(i,2) * vec_in_(2,jk)
    end do
    end do

    ! Y-dir
    do k=1, 2
    do j=1, 2
    do i=1, 2
        vec_out_y(i,j,k) = vec_in(i,1,k) * Mat_tr(1,j) &
                         + vec_in(i,2,k) * Mat_tr(2,j) 
    end do
    end do
    end do
    
    ! Z-dir
    do k=1, 2
    do j=1, 2
    do i=1, 2
        vec_out_z(i,j,k) = vec_in(i,1,k) * Mat_tr(1,j) &
                         + vec_in(i,j,2) * Mat_tr(2,k) 
    end do
    end do
    end do

    return
  end subroutine element_operation_kernel_matvec_gradlike_dirXYZ_P1

!> Calculate a matrix-vector multiplication associated with mathematical operations in the x, y, and z direction (third dimension of vec_in) with p=1
!! For a matrix-vector multiplication (vec_d_out = Mat_d vec_d_in where d=x,y,z), the passed variables of Mat_y and Mat_z should be transposed.
!! Note that we assume that vec_in_ has same data as vec_in, but are reshaped via the call of this subroutine. 
!!
!OCL SERIAL
  subroutine element_operation_kernel_matvec_divlike_dirXYZ_P1( &
    Mat, Mat_tr, vec_in_x, vec_in_y, vec_in_z, &
    vec_out_x, vec_out_y, vec_out_z  )
    implicit none
    real(RP), intent(in) :: Mat(2,2)
    real(RP), intent(in) :: Mat_tr(2,2)
    real(RP), intent(in) :: vec_in_x(2,2**2)
    real(RP), intent(in) :: vec_in_y(2,2,2)
    real(RP), intent(in) :: vec_in_z(2,2,2)
    real(RP), intent(out) :: vec_out_x(2,2**2)
    real(RP), intent(out) :: vec_out_y(2,2**2)
    real(RP), intent(out) :: vec_out_z(2,2**2)

    integer :: i, j, k, jk
    !----------------------------------------------------------

    ! X-dir

    do jk=1, 2**2
    do i=1, 2
      vec_out_x(i,jk) = Mat(i,1) * vec_in_x(1,jk) &
                      + Mat(i,2) * vec_in_x(2,jk)
    end do
    end do

    ! Y-dir
    do k=1, 2
    do j=1, 2
      jk = j + (k-1)*2
      do i=1, 2
        vec_out_y(i,jk) = vec_in_y(i,1,k) * Mat_tr(1,j) &
                        + vec_in_y(i,2,k) * Mat_tr(2,j) 
      end do
    end do
    end do
    
    ! Z-dir
    do k=1, 2
    do j=1, 2
      jk = j + (k-1)*2
      do i=1, 2
        vec_out_z(i,jk) = vec_in_z(i,j,1) * Mat_tr(1,k) &
                        + vec_in_z(i,j,2) * Mat_tr(2,k) 
      end do
    end do
    end do
    return
  end subroutine element_operation_kernel_matvec_divlike_dirXYZ_P1

!OCL SERIAL
  subroutine element_operation_kernel_matvec_divlike_dirXYZ_var5_P1( &
    Mat, Mat_tr, vec_in_x, vec_in_y, vec_in_z, &
    vec_out_x, vec_out_y, vec_out_z  )
    implicit none
    real(RP), intent(in) :: Mat(2,2)
    real(RP), intent(in) :: Mat_tr(2,2)
    real(RP), intent(in) :: vec_in_x(2,2**2*5)
    real(RP), intent(in) :: vec_in_y(2,2,2*5)
    real(RP), intent(in) :: vec_in_z(2,2,2,5)
    real(RP), intent(out) :: vec_out_x(2,2**2*5)
    real(RP), intent(out) :: vec_out_y(2,2**2*5)
    real(RP), intent(out) :: vec_out_z(2,2**2,5)

    integer :: i, j, k, jkv, jk, v, kv
    !----------------------------------------------------------

    ! X-dir

    do jkv=1, 2**2*5
    do i=1, 2
      vec_out_x(i,jkv) = Mat(i,1) * vec_in_x(1,jkv) &
                      + Mat(i,2) * vec_in_x(2,jkv)
    end do
    end do

    ! Y-dir
    do kv=1, 2*5
    do j=1, 2
      jkv = j + (kv-1)*10
      do i=1, 2
        vec_out_y(i,jkv) = vec_in_y(i,1,kv) * Mat_tr(1,j) &
                        + vec_in_y(i,2,kv) * Mat_tr(2,j) 
      end do
    end do
    end do
    
    ! Z-dir
    do v=1, 5
    do k=1, 2
    do j=1, 2
      jk = j + (k-1)*2
      do i=1, 2
        vec_out_z(i,jk,v) = vec_in_z(i,j,1,v) * Mat_tr(1,k) &
                        + vec_in_z(i,j,2,v) * Mat_tr(2,k) 
      end do
    end do
    end do
    end do
    return
  end subroutine element_operation_kernel_matvec_divlike_dirXYZ_var5_P1

!> Calculate a matrix-vector multiplication associated with 3D modal filtering with p=1
!!
!OCL SERIAL
  subroutine element_operation_kernel_matvec_ModalFilter_P1( Mat_h1D, Mat_h1D_tr, Mat_v1D_tr, vec_in, vec_work, &
    vec_out  )
    implicit none
    real(RP), intent(in) :: Mat_h1D(2,2)
    real(RP), intent(in) :: Mat_h1D_tr(2,2)
    real(RP), intent(in) :: Mat_v1D_tr(2,2)
    real(RP), intent(in) :: vec_in(2,2,2)
    real(RP), intent(out) :: vec_work(2,2,2)
    real(RP), intent(out) :: vec_out(2,2,2)

    integer :: i, j, k
    !----------------------------------------------------------

    ! X-dir

    do k=1, 2
    do j=1, 2
    do i=1, 2
      vec_out(i,j,k) = Mat_h1D(i,1) * vec_in(1,j,k) &
                     + Mat_h1D(i,2) * vec_in(2,j,k)
    end do
    end do
    end do
    
    ! Y-dir
    do k=1, 2
    do j=1, 2
    do i=1, 2
      vec_work(i,j,k) = vec_out(i,1,k) * Mat_h1D_tr(1,j) &
                      + vec_out(i,2,k) * Mat_h1D_tr(2,j) 
    end do
    end do
    end do
    
    ! Z-dir
    do k=1, 2
    do j=1, 2
    do i=1, 2
      vec_out(i,j,k) = vec_work(i,j,1) * Mat_v1D_tr(1,k) &
                     + vec_work(i,j,2) * Mat_v1D_tr(2,k) 
    end do
    end do
    end do

    return
  end subroutine element_operation_kernel_matvec_ModalFilter_P1

!--- For p=2 ------------------------------------

!> Calculate a matrix-vector multiplication associated with mathematical operations in the x direction (first dimension of vec_in) with p=2
!!
!OCL SERIAL
  subroutine element_operation_kernel_matvec_dirX_P2( Mat_x, vec_in, vec_out )
    implicit none
    real(RP), intent(in) :: Mat_x(3,3)
    real(RP), intent(in) :: vec_in(3,3**2)
    real(RP), intent(out) :: vec_out(3,3**2)

    integer :: i, jk
    !----------------------------------------------------------

    do jk=1, 3**2
    do i=1, 3
        vec_out(i,jk) = Mat_x(i,1) * vec_in(1,jk) &
                      + Mat_x(i,2) * vec_in(2,jk) &
                      + Mat_x(i,3) * vec_in(3,jk)
    end do
    end do

    return
  end subroutine element_operation_kernel_matvec_dirX_P2

!> Calculate a matrix-vector multiplication associated with mathematical operations in the y direction (second dimension of vec_in) with p=2
!! For a matrix-vector multiplication (vec_out = Mat_y vec_in), the passed variable of Mat_y should be transposed.
!!
!OCL SERIAL
  subroutine element_operation_kernel_matvec_dirY_P2( Mat_y_tr, vec_in, vec_out )
    implicit none
    real(RP), intent(in) :: Mat_y_tr(3,3)
    real(RP), intent(in) :: vec_in(3,3,3)
    real(RP), intent(out) :: vec_out(3,3,3)

    integer :: i, j, k
    !----------------------------------------------------------

    do k=1, 3
    do j=1, 3
    do i=1, 3
        vec_out(i,j,k) = vec_in(i,1,k) * Mat_y_tr(1,j) &
                       + vec_in(i,2,k) * Mat_y_tr(2,j) &
                       + vec_in(i,3,k) * Mat_y_tr(3,j) 
    end do
    end do
    end do

    return
  end subroutine element_operation_kernel_matvec_dirY_P2

!> Calculate a matrix-vector multiplication associated with mathematical operations in the z direction (third dimension of vec_in) with p=2
!! For a matrix-vector multiplication (vec_out = Mat_z vec_in), the passed variable of Mat_z should be transposed.
!!
!OCL SERIAL
  subroutine element_operation_kernel_matvec_dirZ_P2( Mat_z_tr, vec_in, vec_out )
    implicit none
    real(RP), intent(in) :: Mat_z_tr(3,3)
    real(RP), intent(in) :: vec_in(3,3,3)
    real(RP), intent(out) :: vec_out(3,3,3)

    integer :: i, j, k
    !----------------------------------------------------------

    do k=1, 3
    do j=1, 3
    do i=1, 3
        vec_out(i,j,k) = vec_in(i,j,1) * Mat_z_tr(1,k) &
                       + vec_in(i,j,2) * Mat_z_tr(2,k) &
                       + vec_in(i,j,3) * Mat_z_tr(3,k) 
    end do
    end do
    end do

    return
  end subroutine element_operation_kernel_matvec_dirZ_P2

!> Calculate a matrix-vector multiplication with lifting operations for a hexahedral element of order p=2
!!
!OCL SERIAL
  subroutine element_operation_kernel_matvec_Lift_hexahedral_P2( Lift, vec_in, vec_out )
    implicit none
    real(RP), intent(in) :: Lift(3,3,3,6)
    real(RP), intent(in) :: vec_in(3,3,6)
    real(RP), intent(out) :: vec_out(3,3,3)

    integer :: i, j, k
    !----------------------------------------------------------

    do k=1, 3
    do j=1, 3
    do i=1, 3
        vec_out(i,j,k) = Lift(i,j,k,1) * vec_in(i,k,1) &
                       + Lift(i,j,k,2) * vec_in(j,k,2) &
                       + Lift(i,j,k,3) * vec_in(i,k,3) &
                       + Lift(i,j,k,4) * vec_in(j,k,4) &
                       + Lift(i,j,k,5) * vec_in(i,j,5) &
                       + Lift(i,j,k,6) * vec_in(i,j,6)
    end do
    end do
    end do

    return
  end subroutine element_operation_kernel_matvec_Lift_hexahedral_P2
  
!> Calculate a matrix-vector multiplication associated with mathematical operations in the x, y, and z direction (third dimension of vec_in) with p=2
!! For a matrix-vector multiplication (vec_d_out = Mat_d vec_in where d=x,y,z), the passed variables of Mat_y and Mat_z should be transposed.
!! Note that we assume that vec_in_ has same data as vec_in, but are reshaped via the call of this subroutine. 
!!
!OCL SERIAL
  subroutine element_operation_kernel_matvec_gradlike_dirXYZ_P2( Mat, Mat_tr, vec_in, vec_in_, &
    vec_out_x, vec_out_y, vec_out_z  )
    implicit none
    real(RP), intent(in) :: Mat(3,3)
    real(RP), intent(in) :: Mat_tr(3,3)
    real(RP), intent(in) :: vec_in_(3,3**2)
    real(RP), intent(in) :: vec_in(3,3,3)
    real(RP), intent(out) :: vec_out_x(3,3**2)
    real(RP), intent(out) :: vec_out_y(3,3,3)
    real(RP), intent(out) :: vec_out_z(3,3,3)

    integer :: i, j, k, jk
    !----------------------------------------------------------

    ! X-dir

    do jk=1, 3**2
    do i=1, 3
        vec_out_x(i,jk) = Mat(i,1) * vec_in_(1,jk) &
                        + Mat(i,2) * vec_in_(2,jk) &
                        + Mat(i,3) * vec_in_(3,jk)
    end do
    end do

    ! Y-dir
    do k=1, 3
    do j=1, 3
    do i=1, 3
        vec_out_y(i,j,k) = vec_in(i,1,k) * Mat_tr(1,j) &
                         + vec_in(i,2,k) * Mat_tr(2,j) &
                         + vec_in(i,3,k) * Mat_tr(3,j) 
    end do
    end do
    end do
    
    ! Z-dir
    do k=1, 3
    do j=1, 3
    do i=1, 3
        vec_out_z(i,j,k) = vec_in(i,1,k) * Mat_tr(1,j) &
                         + vec_in(i,j,2) * Mat_tr(2,k) &
                         + vec_in(i,j,3) * Mat_tr(3,k) 
    end do
    end do
    end do

    return
  end subroutine element_operation_kernel_matvec_gradlike_dirXYZ_P2

!> Calculate a matrix-vector multiplication associated with mathematical operations in the x, y, and z direction (third dimension of vec_in) with p=2
!! For a matrix-vector multiplication (vec_d_out = Mat_d vec_d_in where d=x,y,z), the passed variables of Mat_y and Mat_z should be transposed.
!! Note that we assume that vec_in_ has same data as vec_in, but are reshaped via the call of this subroutine. 
!!
!OCL SERIAL
  subroutine element_operation_kernel_matvec_divlike_dirXYZ_P2( &
    Mat, Mat_tr, vec_in_x, vec_in_y, vec_in_z, &
    vec_out_x, vec_out_y, vec_out_z  )
    implicit none
    real(RP), intent(in) :: Mat(3,3)
    real(RP), intent(in) :: Mat_tr(3,3)
    real(RP), intent(in) :: vec_in_x(3,3**2)
    real(RP), intent(in) :: vec_in_y(3,3,3)
    real(RP), intent(in) :: vec_in_z(3,3,3)
    real(RP), intent(out) :: vec_out_x(3,3**2)
    real(RP), intent(out) :: vec_out_y(3,3**2)
    real(RP), intent(out) :: vec_out_z(3,3**2)

    integer :: i, j, k, jk
    !----------------------------------------------------------

    ! X-dir

    do jk=1, 3**2
    do i=1, 3
      vec_out_x(i,jk) = Mat(i,1) * vec_in_x(1,jk) &
                      + Mat(i,2) * vec_in_x(2,jk) &
                      + Mat(i,3) * vec_in_x(3,jk)
    end do
    end do

    ! Y-dir
    do k=1, 3
    do j=1, 3
      jk = j + (k-1)*3
      do i=1, 3
        vec_out_y(i,jk) = vec_in_y(i,1,k) * Mat_tr(1,j) &
                        + vec_in_y(i,2,k) * Mat_tr(2,j) &
                        + vec_in_y(i,3,k) * Mat_tr(3,j) 
      end do
    end do
    end do
    
    ! Z-dir
    do k=1, 3
    do j=1, 3
      jk = j + (k-1)*3
      do i=1, 3
        vec_out_z(i,jk) = vec_in_z(i,j,1) * Mat_tr(1,k) &
                        + vec_in_z(i,j,2) * Mat_tr(2,k) &
                        + vec_in_z(i,j,3) * Mat_tr(3,k) 
      end do
    end do
    end do
    return
  end subroutine element_operation_kernel_matvec_divlike_dirXYZ_P2

!OCL SERIAL
  subroutine element_operation_kernel_matvec_divlike_dirXYZ_var5_P2( &
    Mat, Mat_tr, vec_in_x, vec_in_y, vec_in_z, &
    vec_out_x, vec_out_y, vec_out_z  )
    implicit none
    real(RP), intent(in) :: Mat(3,3)
    real(RP), intent(in) :: Mat_tr(3,3)
    real(RP), intent(in) :: vec_in_x(3,3**2*5)
    real(RP), intent(in) :: vec_in_y(3,3,3*5)
    real(RP), intent(in) :: vec_in_z(3,3,3,5)
    real(RP), intent(out) :: vec_out_x(3,3**2*5)
    real(RP), intent(out) :: vec_out_y(3,3**2*5)
    real(RP), intent(out) :: vec_out_z(3,3**2,5)

    integer :: i, j, k, jkv, jk, v, kv
    !----------------------------------------------------------

    ! X-dir

    do jkv=1, 3**2*5
    do i=1, 3
      vec_out_x(i,jkv) = Mat(i,1) * vec_in_x(1,jkv) &
                      + Mat(i,2) * vec_in_x(2,jkv) &
                      + Mat(i,3) * vec_in_x(3,jkv)
    end do
    end do

    ! Y-dir
    do kv=1, 3*5
    do j=1, 3
      jkv = j + (kv-1)*15
      do i=1, 3
        vec_out_y(i,jkv) = vec_in_y(i,1,kv) * Mat_tr(1,j) &
                        + vec_in_y(i,2,kv) * Mat_tr(2,j) &
                        + vec_in_y(i,3,kv) * Mat_tr(3,j) 
      end do
    end do
    end do
    
    ! Z-dir
    do v=1, 5
    do k=1, 3
    do j=1, 3
      jk = j + (k-1)*3
      do i=1, 3
        vec_out_z(i,jk,v) = vec_in_z(i,j,1,v) * Mat_tr(1,k) &
                        + vec_in_z(i,j,2,v) * Mat_tr(2,k) &
                        + vec_in_z(i,j,3,v) * Mat_tr(3,k) 
      end do
    end do
    end do
    end do
    return
  end subroutine element_operation_kernel_matvec_divlike_dirXYZ_var5_P2

!> Calculate a matrix-vector multiplication associated with 3D modal filtering with p=2
!!
!OCL SERIAL
  subroutine element_operation_kernel_matvec_ModalFilter_P2( Mat_h1D, Mat_h1D_tr, Mat_v1D_tr, vec_in, vec_work, &
    vec_out  )
    implicit none
    real(RP), intent(in) :: Mat_h1D(3,3)
    real(RP), intent(in) :: Mat_h1D_tr(3,3)
    real(RP), intent(in) :: Mat_v1D_tr(3,3)
    real(RP), intent(in) :: vec_in(3,3,3)
    real(RP), intent(out) :: vec_work(3,3,3)
    real(RP), intent(out) :: vec_out(3,3,3)

    integer :: i, j, k
    !----------------------------------------------------------

    ! X-dir

    do k=1, 3
    do j=1, 3
    do i=1, 3
      vec_out(i,j,k) = Mat_h1D(i,1) * vec_in(1,j,k) &
                     + Mat_h1D(i,2) * vec_in(2,j,k) &
                     + Mat_h1D(i,3) * vec_in(3,j,k)
    end do
    end do
    end do
    
    ! Y-dir
    do k=1, 3
    do j=1, 3
    do i=1, 3
      vec_work(i,j,k) = vec_out(i,1,k) * Mat_h1D_tr(1,j) &
                      + vec_out(i,2,k) * Mat_h1D_tr(2,j) &
                      + vec_out(i,3,k) * Mat_h1D_tr(3,j) 
    end do
    end do
    end do
    
    ! Z-dir
    do k=1, 3
    do j=1, 3
    do i=1, 3
      vec_out(i,j,k) = vec_work(i,j,1) * Mat_v1D_tr(1,k) &
                     + vec_work(i,j,2) * Mat_v1D_tr(2,k) &
                     + vec_work(i,j,3) * Mat_v1D_tr(3,k) 
    end do
    end do
    end do

    return
  end subroutine element_operation_kernel_matvec_ModalFilter_P2

!--- For p=3 ------------------------------------

!> Calculate a matrix-vector multiplication associated with mathematical operations in the x direction (first dimension of vec_in) with p=3
!!
!OCL SERIAL
  subroutine element_operation_kernel_matvec_dirX_P3( Mat_x, vec_in, vec_out )
    implicit none
    real(RP), intent(in) :: Mat_x(4,4)
    real(RP), intent(in) :: vec_in(4,4**2)
    real(RP), intent(out) :: vec_out(4,4**2)

    integer :: i, jk
    !----------------------------------------------------------

    do jk=1, 4**2
    do i=1, 4
        vec_out(i,jk) = Mat_x(i,1) * vec_in(1,jk) &
                      + Mat_x(i,2) * vec_in(2,jk) &
                      + Mat_x(i,3) * vec_in(3,jk) &
                      + Mat_x(i,4) * vec_in(4,jk)
    end do
    end do

    return
  end subroutine element_operation_kernel_matvec_dirX_P3

!> Calculate a matrix-vector multiplication associated with mathematical operations in the y direction (second dimension of vec_in) with p=3
!! For a matrix-vector multiplication (vec_out = Mat_y vec_in), the passed variable of Mat_y should be transposed.
!!
!OCL SERIAL
  subroutine element_operation_kernel_matvec_dirY_P3( Mat_y_tr, vec_in, vec_out )
    implicit none
    real(RP), intent(in) :: Mat_y_tr(4,4)
    real(RP), intent(in) :: vec_in(4,4,4)
    real(RP), intent(out) :: vec_out(4,4,4)

    integer :: i, j, k
    !----------------------------------------------------------

    do k=1, 4
    do j=1, 4
    do i=1, 4
        vec_out(i,j,k) = vec_in(i,1,k) * Mat_y_tr(1,j) &
                       + vec_in(i,2,k) * Mat_y_tr(2,j) &
                       + vec_in(i,3,k) * Mat_y_tr(3,j) &
                       + vec_in(i,4,k) * Mat_y_tr(4,j) 
    end do
    end do
    end do

    return
  end subroutine element_operation_kernel_matvec_dirY_P3

!> Calculate a matrix-vector multiplication associated with mathematical operations in the z direction (third dimension of vec_in) with p=3
!! For a matrix-vector multiplication (vec_out = Mat_z vec_in), the passed variable of Mat_z should be transposed.
!!
!OCL SERIAL
  subroutine element_operation_kernel_matvec_dirZ_P3( Mat_z_tr, vec_in, vec_out )
    implicit none
    real(RP), intent(in) :: Mat_z_tr(4,4)
    real(RP), intent(in) :: vec_in(4,4,4)
    real(RP), intent(out) :: vec_out(4,4,4)

    integer :: i, j, k
    !----------------------------------------------------------

    do k=1, 4
    do j=1, 4
    do i=1, 4
        vec_out(i,j,k) = vec_in(i,j,1) * Mat_z_tr(1,k) &
                       + vec_in(i,j,2) * Mat_z_tr(2,k) &
                       + vec_in(i,j,3) * Mat_z_tr(3,k) &
                       + vec_in(i,j,4) * Mat_z_tr(4,k) 
    end do
    end do
    end do

    return
  end subroutine element_operation_kernel_matvec_dirZ_P3

!> Calculate a matrix-vector multiplication with lifting operations for a hexahedral element of order p=3
!!
!OCL SERIAL
  subroutine element_operation_kernel_matvec_Lift_hexahedral_P3( Lift, vec_in, vec_out )
    implicit none
    real(RP), intent(in) :: Lift(4,4,4,6)
    real(RP), intent(in) :: vec_in(4,4,6)
    real(RP), intent(out) :: vec_out(4,4,4)

    integer :: i, j, k
    !----------------------------------------------------------

    do k=1, 4
    do j=1, 4
    do i=1, 4
        vec_out(i,j,k) = Lift(i,j,k,1) * vec_in(i,k,1) &
                       + Lift(i,j,k,2) * vec_in(j,k,2) &
                       + Lift(i,j,k,3) * vec_in(i,k,3) &
                       + Lift(i,j,k,4) * vec_in(j,k,4) &
                       + Lift(i,j,k,5) * vec_in(i,j,5) &
                       + Lift(i,j,k,6) * vec_in(i,j,6)
    end do
    end do
    end do

    return
  end subroutine element_operation_kernel_matvec_Lift_hexahedral_P3
  
!> Calculate a matrix-vector multiplication associated with mathematical operations in the x, y, and z direction (third dimension of vec_in) with p=3
!! For a matrix-vector multiplication (vec_d_out = Mat_d vec_in where d=x,y,z), the passed variables of Mat_y and Mat_z should be transposed.
!! Note that we assume that vec_in_ has same data as vec_in, but are reshaped via the call of this subroutine. 
!!
!OCL SERIAL
  subroutine element_operation_kernel_matvec_gradlike_dirXYZ_P3( Mat, Mat_tr, vec_in, vec_in_, &
    vec_out_x, vec_out_y, vec_out_z  )
    implicit none
    real(RP), intent(in) :: Mat(4,4)
    real(RP), intent(in) :: Mat_tr(4,4)
    real(RP), intent(in) :: vec_in_(4,4**2)
    real(RP), intent(in) :: vec_in(4,4,4)
    real(RP), intent(out) :: vec_out_x(4,4**2)
    real(RP), intent(out) :: vec_out_y(4,4,4)
    real(RP), intent(out) :: vec_out_z(4,4,4)

    integer :: i, j, k, jk
    !----------------------------------------------------------

    ! X-dir

    do jk=1, 4**2
    do i=1, 4
        vec_out_x(i,jk) = Mat(i,1) * vec_in_(1,jk) &
                        + Mat(i,2) * vec_in_(2,jk) &
                        + Mat(i,3) * vec_in_(3,jk) &
                        + Mat(i,4) * vec_in_(4,jk)
    end do
    end do

    ! Y-dir
    do k=1, 4
    do j=1, 4
    do i=1, 4
        vec_out_y(i,j,k) = vec_in(i,1,k) * Mat_tr(1,j) &
                         + vec_in(i,2,k) * Mat_tr(2,j) &
                         + vec_in(i,3,k) * Mat_tr(3,j) &
                         + vec_in(i,4,k) * Mat_tr(4,j) 
    end do
    end do
    end do
    
    ! Z-dir
    do k=1, 4
    do j=1, 4
    do i=1, 4
        vec_out_z(i,j,k) = vec_in(i,1,k) * Mat_tr(1,j) &
                         + vec_in(i,j,2) * Mat_tr(2,k) &
                         + vec_in(i,j,3) * Mat_tr(3,k) &
                         + vec_in(i,j,4) * Mat_tr(4,k) 
    end do
    end do
    end do

    return
  end subroutine element_operation_kernel_matvec_gradlike_dirXYZ_P3

!> Calculate a matrix-vector multiplication associated with mathematical operations in the x, y, and z direction (third dimension of vec_in) with p=3
!! For a matrix-vector multiplication (vec_d_out = Mat_d vec_d_in where d=x,y,z), the passed variables of Mat_y and Mat_z should be transposed.
!! Note that we assume that vec_in_ has same data as vec_in, but are reshaped via the call of this subroutine. 
!!
!OCL SERIAL
  subroutine element_operation_kernel_matvec_divlike_dirXYZ_P3( &
    Mat, Mat_tr, vec_in_x, vec_in_y, vec_in_z, &
    vec_out_x, vec_out_y, vec_out_z  )
    implicit none
    real(RP), intent(in) :: Mat(4,4)
    real(RP), intent(in) :: Mat_tr(4,4)
    real(RP), intent(in) :: vec_in_x(4,4**2)
    real(RP), intent(in) :: vec_in_y(4,4,4)
    real(RP), intent(in) :: vec_in_z(4,4,4)
    real(RP), intent(out) :: vec_out_x(4,4**2)
    real(RP), intent(out) :: vec_out_y(4,4**2)
    real(RP), intent(out) :: vec_out_z(4,4**2)

    integer :: i, j, k, jk
    !----------------------------------------------------------

    ! X-dir

    do jk=1, 4**2
    do i=1, 4
      vec_out_x(i,jk) = Mat(i,1) * vec_in_x(1,jk) &
                      + Mat(i,2) * vec_in_x(2,jk) &
                      + Mat(i,3) * vec_in_x(3,jk) &
                      + Mat(i,4) * vec_in_x(4,jk)
    end do
    end do

    ! Y-dir
    do k=1, 4
    do j=1, 4
      jk = j + (k-1)*4
      do i=1, 4
        vec_out_y(i,jk) = vec_in_y(i,1,k) * Mat_tr(1,j) &
                        + vec_in_y(i,2,k) * Mat_tr(2,j) &
                        + vec_in_y(i,3,k) * Mat_tr(3,j) &
                        + vec_in_y(i,4,k) * Mat_tr(4,j) 
      end do
    end do
    end do
    
    ! Z-dir
    do k=1, 4
    do j=1, 4
      jk = j + (k-1)*4
      do i=1, 4
        vec_out_z(i,jk) = vec_in_z(i,j,1) * Mat_tr(1,k) &
                        + vec_in_z(i,j,2) * Mat_tr(2,k) &
                        + vec_in_z(i,j,3) * Mat_tr(3,k) &
                        + vec_in_z(i,j,4) * Mat_tr(4,k) 
      end do
    end do
    end do
    return
  end subroutine element_operation_kernel_matvec_divlike_dirXYZ_P3

!OCL SERIAL
  subroutine element_operation_kernel_matvec_divlike_dirXYZ_var5_P3( &
    Mat, Mat_tr, vec_in_x, vec_in_y, vec_in_z, &
    vec_out_x, vec_out_y, vec_out_z  )
    implicit none
    real(RP), intent(in) :: Mat(4,4)
    real(RP), intent(in) :: Mat_tr(4,4)
    real(RP), intent(in) :: vec_in_x(4,4**2*5)
    real(RP), intent(in) :: vec_in_y(4,4,4*5)
    real(RP), intent(in) :: vec_in_z(4,4,4,5)
    real(RP), intent(out) :: vec_out_x(4,4**2*5)
    real(RP), intent(out) :: vec_out_y(4,4**2*5)
    real(RP), intent(out) :: vec_out_z(4,4**2,5)

    integer :: i, j, k, jkv, jk, v, kv
    !----------------------------------------------------------

    ! X-dir

    do jkv=1, 4**2*5
    do i=1, 4
      vec_out_x(i,jkv) = Mat(i,1) * vec_in_x(1,jkv) &
                      + Mat(i,2) * vec_in_x(2,jkv) &
                      + Mat(i,3) * vec_in_x(3,jkv) &
                      + Mat(i,4) * vec_in_x(4,jkv)
    end do
    end do

    ! Y-dir
    do kv=1, 4*5
    do j=1, 4
      jkv = j + (kv-1)*20
      do i=1, 4
        vec_out_y(i,jkv) = vec_in_y(i,1,kv) * Mat_tr(1,j) &
                        + vec_in_y(i,2,kv) * Mat_tr(2,j) &
                        + vec_in_y(i,3,kv) * Mat_tr(3,j) &
                        + vec_in_y(i,4,kv) * Mat_tr(4,j) 
      end do
    end do
    end do
    
    ! Z-dir
    do v=1, 5
    do k=1, 4
    do j=1, 4
      jk = j + (k-1)*4
      do i=1, 4
        vec_out_z(i,jk,v) = vec_in_z(i,j,1,v) * Mat_tr(1,k) &
                        + vec_in_z(i,j,2,v) * Mat_tr(2,k) &
                        + vec_in_z(i,j,3,v) * Mat_tr(3,k) &
                        + vec_in_z(i,j,4,v) * Mat_tr(4,k) 
      end do
    end do
    end do
    end do
    return
  end subroutine element_operation_kernel_matvec_divlike_dirXYZ_var5_P3

!> Calculate a matrix-vector multiplication associated with 3D modal filtering with p=3
!!
!OCL SERIAL
  subroutine element_operation_kernel_matvec_ModalFilter_P3( Mat_h1D, Mat_h1D_tr, Mat_v1D_tr, vec_in, vec_work, &
    vec_out  )
    implicit none
    real(RP), intent(in) :: Mat_h1D(4,4)
    real(RP), intent(in) :: Mat_h1D_tr(4,4)
    real(RP), intent(in) :: Mat_v1D_tr(4,4)
    real(RP), intent(in) :: vec_in(4,4,4)
    real(RP), intent(out) :: vec_work(4,4,4)
    real(RP), intent(out) :: vec_out(4,4,4)

    integer :: i, j, k
    !----------------------------------------------------------

    ! X-dir

    do k=1, 4
    do j=1, 4
    do i=1, 4
      vec_out(i,j,k) = Mat_h1D(i,1) * vec_in(1,j,k) &
                     + Mat_h1D(i,2) * vec_in(2,j,k) &
                     + Mat_h1D(i,3) * vec_in(3,j,k) &
                     + Mat_h1D(i,4) * vec_in(4,j,k)
    end do
    end do
    end do
    
    ! Y-dir
    do k=1, 4
    do j=1, 4
    do i=1, 4
      vec_work(i,j,k) = vec_out(i,1,k) * Mat_h1D_tr(1,j) &
                      + vec_out(i,2,k) * Mat_h1D_tr(2,j) &
                      + vec_out(i,3,k) * Mat_h1D_tr(3,j) &
                      + vec_out(i,4,k) * Mat_h1D_tr(4,j) 
    end do
    end do
    end do
    
    ! Z-dir
    do k=1, 4
    do j=1, 4
    do i=1, 4
      vec_out(i,j,k) = vec_work(i,j,1) * Mat_v1D_tr(1,k) &
                     + vec_work(i,j,2) * Mat_v1D_tr(2,k) &
                     + vec_work(i,j,3) * Mat_v1D_tr(3,k) &
                     + vec_work(i,j,4) * Mat_v1D_tr(4,k) 
    end do
    end do
    end do

    return
  end subroutine element_operation_kernel_matvec_ModalFilter_P3

!--- For p=4 ------------------------------------

!> Calculate a matrix-vector multiplication associated with mathematical operations in the x direction (first dimension of vec_in) with p=4
!!
!OCL SERIAL
  subroutine element_operation_kernel_matvec_dirX_P4( Mat_x, vec_in, vec_out )
    implicit none
    real(RP), intent(in) :: Mat_x(5,5)
    real(RP), intent(in) :: vec_in(5,5**2)
    real(RP), intent(out) :: vec_out(5,5**2)

    integer :: i, jk
    !----------------------------------------------------------

    do jk=1, 5**2
    do i=1, 5
        vec_out(i,jk) = Mat_x(i,1) * vec_in(1,jk) &
                      + Mat_x(i,2) * vec_in(2,jk) &
                      + Mat_x(i,3) * vec_in(3,jk) &
                      + Mat_x(i,4) * vec_in(4,jk) &
                      + Mat_x(i,5) * vec_in(5,jk)
    end do
    end do

    return
  end subroutine element_operation_kernel_matvec_dirX_P4

!> Calculate a matrix-vector multiplication associated with mathematical operations in the y direction (second dimension of vec_in) with p=4
!! For a matrix-vector multiplication (vec_out = Mat_y vec_in), the passed variable of Mat_y should be transposed.
!!
!OCL SERIAL
  subroutine element_operation_kernel_matvec_dirY_P4( Mat_y_tr, vec_in, vec_out )
    implicit none
    real(RP), intent(in) :: Mat_y_tr(5,5)
    real(RP), intent(in) :: vec_in(5,5,5)
    real(RP), intent(out) :: vec_out(5,5,5)

    integer :: i, j, k
    !----------------------------------------------------------

    do k=1, 5
    do j=1, 5
    do i=1, 5
        vec_out(i,j,k) = vec_in(i,1,k) * Mat_y_tr(1,j) &
                       + vec_in(i,2,k) * Mat_y_tr(2,j) &
                       + vec_in(i,3,k) * Mat_y_tr(3,j) &
                       + vec_in(i,4,k) * Mat_y_tr(4,j) &
                       + vec_in(i,5,k) * Mat_y_tr(5,j) 
    end do
    end do
    end do

    return
  end subroutine element_operation_kernel_matvec_dirY_P4

!> Calculate a matrix-vector multiplication associated with mathematical operations in the z direction (third dimension of vec_in) with p=4
!! For a matrix-vector multiplication (vec_out = Mat_z vec_in), the passed variable of Mat_z should be transposed.
!!
!OCL SERIAL
  subroutine element_operation_kernel_matvec_dirZ_P4( Mat_z_tr, vec_in, vec_out )
    implicit none
    real(RP), intent(in) :: Mat_z_tr(5,5)
    real(RP), intent(in) :: vec_in(5,5,5)
    real(RP), intent(out) :: vec_out(5,5,5)

    integer :: i, j, k
    !----------------------------------------------------------

    do k=1, 5
    do j=1, 5
    do i=1, 5
        vec_out(i,j,k) = vec_in(i,j,1) * Mat_z_tr(1,k) &
                       + vec_in(i,j,2) * Mat_z_tr(2,k) &
                       + vec_in(i,j,3) * Mat_z_tr(3,k) &
                       + vec_in(i,j,4) * Mat_z_tr(4,k) &
                       + vec_in(i,j,5) * Mat_z_tr(5,k) 
    end do
    end do
    end do

    return
  end subroutine element_operation_kernel_matvec_dirZ_P4

!> Calculate a matrix-vector multiplication with lifting operations for a hexahedral element of order p=4
!!
!OCL SERIAL
  subroutine element_operation_kernel_matvec_Lift_hexahedral_P4( Lift, vec_in, vec_out )
    implicit none
    real(RP), intent(in) :: Lift(5,5,5,6)
    real(RP), intent(in) :: vec_in(5,5,6)
    real(RP), intent(out) :: vec_out(5,5,5)

    integer :: i, j, k
    !----------------------------------------------------------

    do k=1, 5
    do j=1, 5
    do i=1, 5
        vec_out(i,j,k) = Lift(i,j,k,1) * vec_in(i,k,1) &
                       + Lift(i,j,k,2) * vec_in(j,k,2) &
                       + Lift(i,j,k,3) * vec_in(i,k,3) &
                       + Lift(i,j,k,4) * vec_in(j,k,4) &
                       + Lift(i,j,k,5) * vec_in(i,j,5) &
                       + Lift(i,j,k,6) * vec_in(i,j,6)
    end do
    end do
    end do

    return
  end subroutine element_operation_kernel_matvec_Lift_hexahedral_P4
  
!> Calculate a matrix-vector multiplication associated with mathematical operations in the x, y, and z direction (third dimension of vec_in) with p=4
!! For a matrix-vector multiplication (vec_d_out = Mat_d vec_in where d=x,y,z), the passed variables of Mat_y and Mat_z should be transposed.
!! Note that we assume that vec_in_ has same data as vec_in, but are reshaped via the call of this subroutine. 
!!
!OCL SERIAL
  subroutine element_operation_kernel_matvec_gradlike_dirXYZ_P4( Mat, Mat_tr, vec_in, vec_in_, &
    vec_out_x, vec_out_y, vec_out_z  )
    implicit none
    real(RP), intent(in) :: Mat(5,5)
    real(RP), intent(in) :: Mat_tr(5,5)
    real(RP), intent(in) :: vec_in_(5,5**2)
    real(RP), intent(in) :: vec_in(5,5,5)
    real(RP), intent(out) :: vec_out_x(5,5**2)
    real(RP), intent(out) :: vec_out_y(5,5,5)
    real(RP), intent(out) :: vec_out_z(5,5,5)

    integer :: i, j, k, jk
    !----------------------------------------------------------

    ! X-dir

    do jk=1, 5**2
    do i=1, 5
        vec_out_x(i,jk) = Mat(i,1) * vec_in_(1,jk) &
                        + Mat(i,2) * vec_in_(2,jk) &
                        + Mat(i,3) * vec_in_(3,jk) &
                        + Mat(i,4) * vec_in_(4,jk) &
                        + Mat(i,5) * vec_in_(5,jk)
    end do
    end do

    ! Y-dir
    do k=1, 5
    do j=1, 5
    do i=1, 5
        vec_out_y(i,j,k) = vec_in(i,1,k) * Mat_tr(1,j) &
                         + vec_in(i,2,k) * Mat_tr(2,j) &
                         + vec_in(i,3,k) * Mat_tr(3,j) &
                         + vec_in(i,4,k) * Mat_tr(4,j) &
                         + vec_in(i,5,k) * Mat_tr(5,j) 
    end do
    end do
    end do
    
    ! Z-dir
    do k=1, 5
    do j=1, 5
    do i=1, 5
        vec_out_z(i,j,k) = vec_in(i,1,k) * Mat_tr(1,j) &
                         + vec_in(i,j,2) * Mat_tr(2,k) &
                         + vec_in(i,j,3) * Mat_tr(3,k) &
                         + vec_in(i,j,4) * Mat_tr(4,k) &
                         + vec_in(i,j,5) * Mat_tr(5,k) 
    end do
    end do
    end do

    return
  end subroutine element_operation_kernel_matvec_gradlike_dirXYZ_P4

!> Calculate a matrix-vector multiplication associated with mathematical operations in the x, y, and z direction (third dimension of vec_in) with p=4
!! For a matrix-vector multiplication (vec_d_out = Mat_d vec_d_in where d=x,y,z), the passed variables of Mat_y and Mat_z should be transposed.
!! Note that we assume that vec_in_ has same data as vec_in, but are reshaped via the call of this subroutine. 
!!
!OCL SERIAL
  subroutine element_operation_kernel_matvec_divlike_dirXYZ_P4( &
    Mat, Mat_tr, vec_in_x, vec_in_y, vec_in_z, &
    vec_out_x, vec_out_y, vec_out_z  )
    implicit none
    real(RP), intent(in) :: Mat(5,5)
    real(RP), intent(in) :: Mat_tr(5,5)
    real(RP), intent(in) :: vec_in_x(5,5**2)
    real(RP), intent(in) :: vec_in_y(5,5,5)
    real(RP), intent(in) :: vec_in_z(5,5,5)
    real(RP), intent(out) :: vec_out_x(5,5**2)
    real(RP), intent(out) :: vec_out_y(5,5**2)
    real(RP), intent(out) :: vec_out_z(5,5**2)

    integer :: i, j, k, jk
    !----------------------------------------------------------

    ! X-dir

    do jk=1, 5**2
    do i=1, 5
      vec_out_x(i,jk) = Mat(i,1) * vec_in_x(1,jk) &
                      + Mat(i,2) * vec_in_x(2,jk) &
                      + Mat(i,3) * vec_in_x(3,jk) &
                      + Mat(i,4) * vec_in_x(4,jk) &
                      + Mat(i,5) * vec_in_x(5,jk)
    end do
    end do

    ! Y-dir
    do k=1, 5
    do j=1, 5
      jk = j + (k-1)*5
      do i=1, 5
        vec_out_y(i,jk) = vec_in_y(i,1,k) * Mat_tr(1,j) &
                        + vec_in_y(i,2,k) * Mat_tr(2,j) &
                        + vec_in_y(i,3,k) * Mat_tr(3,j) &
                        + vec_in_y(i,4,k) * Mat_tr(4,j) &
                        + vec_in_y(i,5,k) * Mat_tr(5,j) 
      end do
    end do
    end do
    
    ! Z-dir
    do k=1, 5
    do j=1, 5
      jk = j + (k-1)*5
      do i=1, 5
        vec_out_z(i,jk) = vec_in_z(i,j,1) * Mat_tr(1,k) &
                        + vec_in_z(i,j,2) * Mat_tr(2,k) &
                        + vec_in_z(i,j,3) * Mat_tr(3,k) &
                        + vec_in_z(i,j,4) * Mat_tr(4,k) &
                        + vec_in_z(i,j,5) * Mat_tr(5,k) 
      end do
    end do
    end do
    return
  end subroutine element_operation_kernel_matvec_divlike_dirXYZ_P4

!OCL SERIAL
  subroutine element_operation_kernel_matvec_divlike_dirXYZ_var5_P4( &
    Mat, Mat_tr, vec_in_x, vec_in_y, vec_in_z, &
    vec_out_x, vec_out_y, vec_out_z  )
    implicit none
    real(RP), intent(in) :: Mat(5,5)
    real(RP), intent(in) :: Mat_tr(5,5)
    real(RP), intent(in) :: vec_in_x(5,5**2*5)
    real(RP), intent(in) :: vec_in_y(5,5,5*5)
    real(RP), intent(in) :: vec_in_z(5,5,5,5)
    real(RP), intent(out) :: vec_out_x(5,5**2*5)
    real(RP), intent(out) :: vec_out_y(5,5**2*5)
    real(RP), intent(out) :: vec_out_z(5,5**2,5)

    integer :: i, j, k, jkv, jk, v, kv
    !----------------------------------------------------------

    ! X-dir

    do jkv=1, 5**2*5
    do i=1, 5
      vec_out_x(i,jkv) = Mat(i,1) * vec_in_x(1,jkv) &
                      + Mat(i,2) * vec_in_x(2,jkv) &
                      + Mat(i,3) * vec_in_x(3,jkv) &
                      + Mat(i,4) * vec_in_x(4,jkv) &
                      + Mat(i,5) * vec_in_x(5,jkv)
    end do
    end do

    ! Y-dir
    do kv=1, 5*5
    do j=1, 5
      jkv = j + (kv-1)*25
      do i=1, 5
        vec_out_y(i,jkv) = vec_in_y(i,1,kv) * Mat_tr(1,j) &
                        + vec_in_y(i,2,kv) * Mat_tr(2,j) &
                        + vec_in_y(i,3,kv) * Mat_tr(3,j) &
                        + vec_in_y(i,4,kv) * Mat_tr(4,j) &
                        + vec_in_y(i,5,kv) * Mat_tr(5,j) 
      end do
    end do
    end do
    
    ! Z-dir
    do v=1, 5
    do k=1, 5
    do j=1, 5
      jk = j + (k-1)*5
      do i=1, 5
        vec_out_z(i,jk,v) = vec_in_z(i,j,1,v) * Mat_tr(1,k) &
                        + vec_in_z(i,j,2,v) * Mat_tr(2,k) &
                        + vec_in_z(i,j,3,v) * Mat_tr(3,k) &
                        + vec_in_z(i,j,4,v) * Mat_tr(4,k) &
                        + vec_in_z(i,j,5,v) * Mat_tr(5,k) 
      end do
    end do
    end do
    end do
    return
  end subroutine element_operation_kernel_matvec_divlike_dirXYZ_var5_P4

!> Calculate a matrix-vector multiplication associated with 3D modal filtering with p=4
!!
!OCL SERIAL
  subroutine element_operation_kernel_matvec_ModalFilter_P4( Mat_h1D, Mat_h1D_tr, Mat_v1D_tr, vec_in, vec_work, &
    vec_out  )
    implicit none
    real(RP), intent(in) :: Mat_h1D(5,5)
    real(RP), intent(in) :: Mat_h1D_tr(5,5)
    real(RP), intent(in) :: Mat_v1D_tr(5,5)
    real(RP), intent(in) :: vec_in(5,5,5)
    real(RP), intent(out) :: vec_work(5,5,5)
    real(RP), intent(out) :: vec_out(5,5,5)

    integer :: i, j, k
    !----------------------------------------------------------

    ! X-dir

    do k=1, 5
    do j=1, 5
    do i=1, 5
      vec_out(i,j,k) = Mat_h1D(i,1) * vec_in(1,j,k) &
                     + Mat_h1D(i,2) * vec_in(2,j,k) &
                     + Mat_h1D(i,3) * vec_in(3,j,k) &
                     + Mat_h1D(i,4) * vec_in(4,j,k) &
                     + Mat_h1D(i,5) * vec_in(5,j,k)
    end do
    end do
    end do
    
    ! Y-dir
    do k=1, 5
    do j=1, 5
    do i=1, 5
      vec_work(i,j,k) = vec_out(i,1,k) * Mat_h1D_tr(1,j) &
                      + vec_out(i,2,k) * Mat_h1D_tr(2,j) &
                      + vec_out(i,3,k) * Mat_h1D_tr(3,j) &
                      + vec_out(i,4,k) * Mat_h1D_tr(4,j) &
                      + vec_out(i,5,k) * Mat_h1D_tr(5,j) 
    end do
    end do
    end do
    
    ! Z-dir
    do k=1, 5
    do j=1, 5
    do i=1, 5
      vec_out(i,j,k) = vec_work(i,j,1) * Mat_v1D_tr(1,k) &
                     + vec_work(i,j,2) * Mat_v1D_tr(2,k) &
                     + vec_work(i,j,3) * Mat_v1D_tr(3,k) &
                     + vec_work(i,j,4) * Mat_v1D_tr(4,k) &
                     + vec_work(i,j,5) * Mat_v1D_tr(5,k) 
    end do
    end do
    end do

    return
  end subroutine element_operation_kernel_matvec_ModalFilter_P4

!--- For p=5 ------------------------------------

!> Calculate a matrix-vector multiplication associated with mathematical operations in the x direction (first dimension of vec_in) with p=5
!!
!OCL SERIAL
  subroutine element_operation_kernel_matvec_dirX_P5( Mat_x, vec_in, vec_out )
    implicit none
    real(RP), intent(in) :: Mat_x(6,6)
    real(RP), intent(in) :: vec_in(6,6**2)
    real(RP), intent(out) :: vec_out(6,6**2)

    integer :: i, jk
    !----------------------------------------------------------

    do jk=1, 6**2
    do i=1, 6
        vec_out(i,jk) = Mat_x(i,1) * vec_in(1,jk) &
                      + Mat_x(i,2) * vec_in(2,jk) &
                      + Mat_x(i,3) * vec_in(3,jk) &
                      + Mat_x(i,4) * vec_in(4,jk) &
                      + Mat_x(i,5) * vec_in(5,jk) &
                      + Mat_x(i,6) * vec_in(6,jk)
    end do
    end do

    return
  end subroutine element_operation_kernel_matvec_dirX_P5

!> Calculate a matrix-vector multiplication associated with mathematical operations in the y direction (second dimension of vec_in) with p=5
!! For a matrix-vector multiplication (vec_out = Mat_y vec_in), the passed variable of Mat_y should be transposed.
!!
!OCL SERIAL
  subroutine element_operation_kernel_matvec_dirY_P5( Mat_y_tr, vec_in, vec_out )
    implicit none
    real(RP), intent(in) :: Mat_y_tr(6,6)
    real(RP), intent(in) :: vec_in(6,6,6)
    real(RP), intent(out) :: vec_out(6,6,6)

    integer :: i, j, k
    !----------------------------------------------------------

    do k=1, 6
    do j=1, 6
    do i=1, 6
        vec_out(i,j,k) = vec_in(i,1,k) * Mat_y_tr(1,j) &
                       + vec_in(i,2,k) * Mat_y_tr(2,j) &
                       + vec_in(i,3,k) * Mat_y_tr(3,j) &
                       + vec_in(i,4,k) * Mat_y_tr(4,j) &
                       + vec_in(i,5,k) * Mat_y_tr(5,j) &
                       + vec_in(i,6,k) * Mat_y_tr(6,j) 
    end do
    end do
    end do

    return
  end subroutine element_operation_kernel_matvec_dirY_P5

!> Calculate a matrix-vector multiplication associated with mathematical operations in the z direction (third dimension of vec_in) with p=5
!! For a matrix-vector multiplication (vec_out = Mat_z vec_in), the passed variable of Mat_z should be transposed.
!!
!OCL SERIAL
  subroutine element_operation_kernel_matvec_dirZ_P5( Mat_z_tr, vec_in, vec_out )
    implicit none
    real(RP), intent(in) :: Mat_z_tr(6,6)
    real(RP), intent(in) :: vec_in(6,6,6)
    real(RP), intent(out) :: vec_out(6,6,6)

    integer :: i, j, k
    !----------------------------------------------------------

    do k=1, 6
    do j=1, 6
    do i=1, 6
        vec_out(i,j,k) = vec_in(i,j,1) * Mat_z_tr(1,k) &
                       + vec_in(i,j,2) * Mat_z_tr(2,k) &
                       + vec_in(i,j,3) * Mat_z_tr(3,k) &
                       + vec_in(i,j,4) * Mat_z_tr(4,k) &
                       + vec_in(i,j,5) * Mat_z_tr(5,k) &
                       + vec_in(i,j,6) * Mat_z_tr(6,k) 
    end do
    end do
    end do

    return
  end subroutine element_operation_kernel_matvec_dirZ_P5

!> Calculate a matrix-vector multiplication with lifting operations for a hexahedral element of order p=5
!!
!OCL SERIAL
  subroutine element_operation_kernel_matvec_Lift_hexahedral_P5( Lift, vec_in, vec_out )
    implicit none
    real(RP), intent(in) :: Lift(6,6,6,6)
    real(RP), intent(in) :: vec_in(6,6,6)
    real(RP), intent(out) :: vec_out(6,6,6)

    integer :: i, j, k
    !----------------------------------------------------------

    do k=1, 6
    do j=1, 6
    do i=1, 6
        vec_out(i,j,k) = Lift(i,j,k,1) * vec_in(i,k,1) &
                       + Lift(i,j,k,2) * vec_in(j,k,2) &
                       + Lift(i,j,k,3) * vec_in(i,k,3) &
                       + Lift(i,j,k,4) * vec_in(j,k,4) &
                       + Lift(i,j,k,5) * vec_in(i,j,5) &
                       + Lift(i,j,k,6) * vec_in(i,j,6)
    end do
    end do
    end do

    return
  end subroutine element_operation_kernel_matvec_Lift_hexahedral_P5
  
!> Calculate a matrix-vector multiplication associated with mathematical operations in the x, y, and z direction (third dimension of vec_in) with p=5
!! For a matrix-vector multiplication (vec_d_out = Mat_d vec_in where d=x,y,z), the passed variables of Mat_y and Mat_z should be transposed.
!! Note that we assume that vec_in_ has same data as vec_in, but are reshaped via the call of this subroutine. 
!!
!OCL SERIAL
  subroutine element_operation_kernel_matvec_gradlike_dirXYZ_P5( Mat, Mat_tr, vec_in, vec_in_, &
    vec_out_x, vec_out_y, vec_out_z  )
    implicit none
    real(RP), intent(in) :: Mat(6,6)
    real(RP), intent(in) :: Mat_tr(6,6)
    real(RP), intent(in) :: vec_in_(6,6**2)
    real(RP), intent(in) :: vec_in(6,6,6)
    real(RP), intent(out) :: vec_out_x(6,6**2)
    real(RP), intent(out) :: vec_out_y(6,6,6)
    real(RP), intent(out) :: vec_out_z(6,6,6)

    integer :: i, j, k, jk
    !----------------------------------------------------------

    ! X-dir

    do jk=1, 6**2
    do i=1, 6
        vec_out_x(i,jk) = Mat(i,1) * vec_in_(1,jk) &
                        + Mat(i,2) * vec_in_(2,jk) &
                        + Mat(i,3) * vec_in_(3,jk) &
                        + Mat(i,4) * vec_in_(4,jk) &
                        + Mat(i,5) * vec_in_(5,jk) &
                        + Mat(i,6) * vec_in_(6,jk)
    end do
    end do

    ! Y-dir
    do k=1, 6
    do j=1, 6
    do i=1, 6
        vec_out_y(i,j,k) = vec_in(i,1,k) * Mat_tr(1,j) &
                         + vec_in(i,2,k) * Mat_tr(2,j) &
                         + vec_in(i,3,k) * Mat_tr(3,j) &
                         + vec_in(i,4,k) * Mat_tr(4,j) &
                         + vec_in(i,5,k) * Mat_tr(5,j) &
                         + vec_in(i,6,k) * Mat_tr(6,j) 
    end do
    end do
    end do
    
    ! Z-dir
    do k=1, 6
    do j=1, 6
    do i=1, 6
        vec_out_z(i,j,k) = vec_in(i,1,k) * Mat_tr(1,j) &
                         + vec_in(i,j,2) * Mat_tr(2,k) &
                         + vec_in(i,j,3) * Mat_tr(3,k) &
                         + vec_in(i,j,4) * Mat_tr(4,k) &
                         + vec_in(i,j,5) * Mat_tr(5,k) &
                         + vec_in(i,j,6) * Mat_tr(6,k) 
    end do
    end do
    end do

    return
  end subroutine element_operation_kernel_matvec_gradlike_dirXYZ_P5

!> Calculate a matrix-vector multiplication associated with mathematical operations in the x, y, and z direction (third dimension of vec_in) with p=5
!! For a matrix-vector multiplication (vec_d_out = Mat_d vec_d_in where d=x,y,z), the passed variables of Mat_y and Mat_z should be transposed.
!! Note that we assume that vec_in_ has same data as vec_in, but are reshaped via the call of this subroutine. 
!!
!OCL SERIAL
  subroutine element_operation_kernel_matvec_divlike_dirXYZ_P5( &
    Mat, Mat_tr, vec_in_x, vec_in_y, vec_in_z, &
    vec_out_x, vec_out_y, vec_out_z  )
    implicit none
    real(RP), intent(in) :: Mat(6,6)
    real(RP), intent(in) :: Mat_tr(6,6)
    real(RP), intent(in) :: vec_in_x(6,6**2)
    real(RP), intent(in) :: vec_in_y(6,6,6)
    real(RP), intent(in) :: vec_in_z(6,6,6)
    real(RP), intent(out) :: vec_out_x(6,6**2)
    real(RP), intent(out) :: vec_out_y(6,6**2)
    real(RP), intent(out) :: vec_out_z(6,6**2)

    integer :: i, j, k, jk
    !----------------------------------------------------------

    ! X-dir

    do jk=1, 6**2
    do i=1, 6
      vec_out_x(i,jk) = Mat(i,1) * vec_in_x(1,jk) &
                      + Mat(i,2) * vec_in_x(2,jk) &
                      + Mat(i,3) * vec_in_x(3,jk) &
                      + Mat(i,4) * vec_in_x(4,jk) &
                      + Mat(i,5) * vec_in_x(5,jk) &
                      + Mat(i,6) * vec_in_x(6,jk)
    end do
    end do

    ! Y-dir
    do k=1, 6
    do j=1, 6
      jk = j + (k-1)*6
      do i=1, 6
        vec_out_y(i,jk) = vec_in_y(i,1,k) * Mat_tr(1,j) &
                        + vec_in_y(i,2,k) * Mat_tr(2,j) &
                        + vec_in_y(i,3,k) * Mat_tr(3,j) &
                        + vec_in_y(i,4,k) * Mat_tr(4,j) &
                        + vec_in_y(i,5,k) * Mat_tr(5,j) &
                        + vec_in_y(i,6,k) * Mat_tr(6,j) 
      end do
    end do
    end do
    
    ! Z-dir
    do k=1, 6
    do j=1, 6
      jk = j + (k-1)*6
      do i=1, 6
        vec_out_z(i,jk) = vec_in_z(i,j,1) * Mat_tr(1,k) &
                        + vec_in_z(i,j,2) * Mat_tr(2,k) &
                        + vec_in_z(i,j,3) * Mat_tr(3,k) &
                        + vec_in_z(i,j,4) * Mat_tr(4,k) &
                        + vec_in_z(i,j,5) * Mat_tr(5,k) &
                        + vec_in_z(i,j,6) * Mat_tr(6,k) 
      end do
    end do
    end do
    return
  end subroutine element_operation_kernel_matvec_divlike_dirXYZ_P5

!OCL SERIAL
  subroutine element_operation_kernel_matvec_divlike_dirXYZ_var5_P5( &
    Mat, Mat_tr, vec_in_x, vec_in_y, vec_in_z, &
    vec_out_x, vec_out_y, vec_out_z  )
    implicit none
    real(RP), intent(in) :: Mat(6,6)
    real(RP), intent(in) :: Mat_tr(6,6)
    real(RP), intent(in) :: vec_in_x(6,6**2*5)
    real(RP), intent(in) :: vec_in_y(6,6,6*5)
    real(RP), intent(in) :: vec_in_z(6,6,6,5)
    real(RP), intent(out) :: vec_out_x(6,6**2*5)
    real(RP), intent(out) :: vec_out_y(6,6**2*5)
    real(RP), intent(out) :: vec_out_z(6,6**2,5)

    integer :: i, j, k, jkv, jk, v, kv
    !----------------------------------------------------------

    ! X-dir

    do jkv=1, 6**2*5
    do i=1, 6
      vec_out_x(i,jkv) = Mat(i,1) * vec_in_x(1,jkv) &
                      + Mat(i,2) * vec_in_x(2,jkv) &
                      + Mat(i,3) * vec_in_x(3,jkv) &
                      + Mat(i,4) * vec_in_x(4,jkv) &
                      + Mat(i,5) * vec_in_x(5,jkv) &
                      + Mat(i,6) * vec_in_x(6,jkv)
    end do
    end do

    ! Y-dir
    do kv=1, 6*5
    do j=1, 6
      jkv = j + (kv-1)*30
      do i=1, 6
        vec_out_y(i,jkv) = vec_in_y(i,1,kv) * Mat_tr(1,j) &
                        + vec_in_y(i,2,kv) * Mat_tr(2,j) &
                        + vec_in_y(i,3,kv) * Mat_tr(3,j) &
                        + vec_in_y(i,4,kv) * Mat_tr(4,j) &
                        + vec_in_y(i,5,kv) * Mat_tr(5,j) &
                        + vec_in_y(i,6,kv) * Mat_tr(6,j) 
      end do
    end do
    end do
    
    ! Z-dir
    do v=1, 5
    do k=1, 6
    do j=1, 6
      jk = j + (k-1)*6
      do i=1, 6
        vec_out_z(i,jk,v) = vec_in_z(i,j,1,v) * Mat_tr(1,k) &
                        + vec_in_z(i,j,2,v) * Mat_tr(2,k) &
                        + vec_in_z(i,j,3,v) * Mat_tr(3,k) &
                        + vec_in_z(i,j,4,v) * Mat_tr(4,k) &
                        + vec_in_z(i,j,5,v) * Mat_tr(5,k) &
                        + vec_in_z(i,j,6,v) * Mat_tr(6,k) 
      end do
    end do
    end do
    end do
    return
  end subroutine element_operation_kernel_matvec_divlike_dirXYZ_var5_P5

!> Calculate a matrix-vector multiplication associated with 3D modal filtering with p=5
!!
!OCL SERIAL
  subroutine element_operation_kernel_matvec_ModalFilter_P5( Mat_h1D, Mat_h1D_tr, Mat_v1D_tr, vec_in, vec_work, &
    vec_out  )
    implicit none
    real(RP), intent(in) :: Mat_h1D(6,6)
    real(RP), intent(in) :: Mat_h1D_tr(6,6)
    real(RP), intent(in) :: Mat_v1D_tr(6,6)
    real(RP), intent(in) :: vec_in(6,6,6)
    real(RP), intent(out) :: vec_work(6,6,6)
    real(RP), intent(out) :: vec_out(6,6,6)

    integer :: i, j, k
    !----------------------------------------------------------

    ! X-dir

    do k=1, 6
    do j=1, 6
    do i=1, 6
      vec_out(i,j,k) = Mat_h1D(i,1) * vec_in(1,j,k) &
                     + Mat_h1D(i,2) * vec_in(2,j,k) &
                     + Mat_h1D(i,3) * vec_in(3,j,k) &
                     + Mat_h1D(i,4) * vec_in(4,j,k) &
                     + Mat_h1D(i,5) * vec_in(5,j,k) &
                     + Mat_h1D(i,6) * vec_in(6,j,k)
    end do
    end do
    end do
    
    ! Y-dir
    do k=1, 6
    do j=1, 6
    do i=1, 6
      vec_work(i,j,k) = vec_out(i,1,k) * Mat_h1D_tr(1,j) &
                      + vec_out(i,2,k) * Mat_h1D_tr(2,j) &
                      + vec_out(i,3,k) * Mat_h1D_tr(3,j) &
                      + vec_out(i,4,k) * Mat_h1D_tr(4,j) &
                      + vec_out(i,5,k) * Mat_h1D_tr(5,j) &
                      + vec_out(i,6,k) * Mat_h1D_tr(6,j) 
    end do
    end do
    end do
    
    ! Z-dir
    do k=1, 6
    do j=1, 6
    do i=1, 6
      vec_out(i,j,k) = vec_work(i,j,1) * Mat_v1D_tr(1,k) &
                     + vec_work(i,j,2) * Mat_v1D_tr(2,k) &
                     + vec_work(i,j,3) * Mat_v1D_tr(3,k) &
                     + vec_work(i,j,4) * Mat_v1D_tr(4,k) &
                     + vec_work(i,j,5) * Mat_v1D_tr(5,k) &
                     + vec_work(i,j,6) * Mat_v1D_tr(6,k) 
    end do
    end do
    end do

    return
  end subroutine element_operation_kernel_matvec_ModalFilter_P5

!--- For p=6 ------------------------------------

!> Calculate a matrix-vector multiplication associated with mathematical operations in the x direction (first dimension of vec_in) with p=6
!!
!OCL SERIAL
  subroutine element_operation_kernel_matvec_dirX_P6( Mat_x, vec_in, vec_out )
    implicit none
    real(RP), intent(in) :: Mat_x(7,7)
    real(RP), intent(in) :: vec_in(7,7**2)
    real(RP), intent(out) :: vec_out(7,7**2)

    integer :: i, jk
    !----------------------------------------------------------

    do jk=1, 7**2
    do i=1, 7
        vec_out(i,jk) = Mat_x(i,1) * vec_in(1,jk) &
                      + Mat_x(i,2) * vec_in(2,jk) &
                      + Mat_x(i,3) * vec_in(3,jk) &
                      + Mat_x(i,4) * vec_in(4,jk) &
                      + Mat_x(i,5) * vec_in(5,jk) &
                      + Mat_x(i,6) * vec_in(6,jk) &
                      + Mat_x(i,7) * vec_in(7,jk)
    end do
    end do

    return
  end subroutine element_operation_kernel_matvec_dirX_P6

!> Calculate a matrix-vector multiplication associated with mathematical operations in the y direction (second dimension of vec_in) with p=6
!! For a matrix-vector multiplication (vec_out = Mat_y vec_in), the passed variable of Mat_y should be transposed.
!!
!OCL SERIAL
  subroutine element_operation_kernel_matvec_dirY_P6( Mat_y_tr, vec_in, vec_out )
    implicit none
    real(RP), intent(in) :: Mat_y_tr(7,7)
    real(RP), intent(in) :: vec_in(7,7,7)
    real(RP), intent(out) :: vec_out(7,7,7)

    integer :: i, j, k
    !----------------------------------------------------------

    do k=1, 7
    do j=1, 7
    do i=1, 7
        vec_out(i,j,k) = vec_in(i,1,k) * Mat_y_tr(1,j) &
                       + vec_in(i,2,k) * Mat_y_tr(2,j) &
                       + vec_in(i,3,k) * Mat_y_tr(3,j) &
                       + vec_in(i,4,k) * Mat_y_tr(4,j) &
                       + vec_in(i,5,k) * Mat_y_tr(5,j) &
                       + vec_in(i,6,k) * Mat_y_tr(6,j) &
                       + vec_in(i,7,k) * Mat_y_tr(7,j) 
    end do
    end do
    end do

    return
  end subroutine element_operation_kernel_matvec_dirY_P6

!> Calculate a matrix-vector multiplication associated with mathematical operations in the z direction (third dimension of vec_in) with p=6
!! For a matrix-vector multiplication (vec_out = Mat_z vec_in), the passed variable of Mat_z should be transposed.
!!
!OCL SERIAL
  subroutine element_operation_kernel_matvec_dirZ_P6( Mat_z_tr, vec_in, vec_out )
    implicit none
    real(RP), intent(in) :: Mat_z_tr(7,7)
    real(RP), intent(in) :: vec_in(7,7,7)
    real(RP), intent(out) :: vec_out(7,7,7)

    integer :: i, j, k
    !----------------------------------------------------------

    do k=1, 7
    do j=1, 7
    do i=1, 7
        vec_out(i,j,k) = vec_in(i,j,1) * Mat_z_tr(1,k) &
                       + vec_in(i,j,2) * Mat_z_tr(2,k) &
                       + vec_in(i,j,3) * Mat_z_tr(3,k) &
                       + vec_in(i,j,4) * Mat_z_tr(4,k) &
                       + vec_in(i,j,5) * Mat_z_tr(5,k) &
                       + vec_in(i,j,6) * Mat_z_tr(6,k) &
                       + vec_in(i,j,7) * Mat_z_tr(7,k) 
    end do
    end do
    end do

    return
  end subroutine element_operation_kernel_matvec_dirZ_P6

!> Calculate a matrix-vector multiplication with lifting operations for a hexahedral element of order p=6
!!
!OCL SERIAL
  subroutine element_operation_kernel_matvec_Lift_hexahedral_P6( Lift, vec_in, vec_out )
    implicit none
    real(RP), intent(in) :: Lift(7,7,7,6)
    real(RP), intent(in) :: vec_in(7,7,6)
    real(RP), intent(out) :: vec_out(7,7,7)

    integer :: i, j, k
    !----------------------------------------------------------

    do k=1, 7
    do j=1, 7
    do i=1, 7
        vec_out(i,j,k) = Lift(i,j,k,1) * vec_in(i,k,1) &
                       + Lift(i,j,k,2) * vec_in(j,k,2) &
                       + Lift(i,j,k,3) * vec_in(i,k,3) &
                       + Lift(i,j,k,4) * vec_in(j,k,4) &
                       + Lift(i,j,k,5) * vec_in(i,j,5) &
                       + Lift(i,j,k,6) * vec_in(i,j,6)
    end do
    end do
    end do

    return
  end subroutine element_operation_kernel_matvec_Lift_hexahedral_P6
  
!> Calculate a matrix-vector multiplication associated with mathematical operations in the x, y, and z direction (third dimension of vec_in) with p=6
!! For a matrix-vector multiplication (vec_d_out = Mat_d vec_in where d=x,y,z), the passed variables of Mat_y and Mat_z should be transposed.
!! Note that we assume that vec_in_ has same data as vec_in, but are reshaped via the call of this subroutine. 
!!
!OCL SERIAL
  subroutine element_operation_kernel_matvec_gradlike_dirXYZ_P6( Mat, Mat_tr, vec_in, vec_in_, &
    vec_out_x, vec_out_y, vec_out_z  )
    implicit none
    real(RP), intent(in) :: Mat(7,7)
    real(RP), intent(in) :: Mat_tr(7,7)
    real(RP), intent(in) :: vec_in_(7,7**2)
    real(RP), intent(in) :: vec_in(7,7,7)
    real(RP), intent(out) :: vec_out_x(7,7**2)
    real(RP), intent(out) :: vec_out_y(7,7,7)
    real(RP), intent(out) :: vec_out_z(7,7,7)

    integer :: i, j, k, jk
    !----------------------------------------------------------

    ! X-dir

    do jk=1, 7**2
    do i=1, 7
        vec_out_x(i,jk) = Mat(i,1) * vec_in_(1,jk) &
                        + Mat(i,2) * vec_in_(2,jk) &
                        + Mat(i,3) * vec_in_(3,jk) &
                        + Mat(i,4) * vec_in_(4,jk) &
                        + Mat(i,5) * vec_in_(5,jk) &
                        + Mat(i,6) * vec_in_(6,jk) &
                        + Mat(i,7) * vec_in_(7,jk)
    end do
    end do

    ! Y-dir
    do k=1, 7
    do j=1, 7
    do i=1, 7
        vec_out_y(i,j,k) = vec_in(i,1,k) * Mat_tr(1,j) &
                         + vec_in(i,2,k) * Mat_tr(2,j) &
                         + vec_in(i,3,k) * Mat_tr(3,j) &
                         + vec_in(i,4,k) * Mat_tr(4,j) &
                         + vec_in(i,5,k) * Mat_tr(5,j) &
                         + vec_in(i,6,k) * Mat_tr(6,j) &
                         + vec_in(i,7,k) * Mat_tr(7,j) 
    end do
    end do
    end do
    
    ! Z-dir
    do k=1, 7
    do j=1, 7
    do i=1, 7
        vec_out_z(i,j,k) = vec_in(i,1,k) * Mat_tr(1,j) &
                         + vec_in(i,j,2) * Mat_tr(2,k) &
                         + vec_in(i,j,3) * Mat_tr(3,k) &
                         + vec_in(i,j,4) * Mat_tr(4,k) &
                         + vec_in(i,j,5) * Mat_tr(5,k) &
                         + vec_in(i,j,6) * Mat_tr(6,k) &
                         + vec_in(i,j,7) * Mat_tr(7,k) 
    end do
    end do
    end do

    return
  end subroutine element_operation_kernel_matvec_gradlike_dirXYZ_P6

!> Calculate a matrix-vector multiplication associated with mathematical operations in the x, y, and z direction (third dimension of vec_in) with p=6
!! For a matrix-vector multiplication (vec_d_out = Mat_d vec_d_in where d=x,y,z), the passed variables of Mat_y and Mat_z should be transposed.
!! Note that we assume that vec_in_ has same data as vec_in, but are reshaped via the call of this subroutine. 
!!
!OCL SERIAL
  subroutine element_operation_kernel_matvec_divlike_dirXYZ_P6( &
    Mat, Mat_tr, vec_in_x, vec_in_y, vec_in_z, &
    vec_out_x, vec_out_y, vec_out_z  )
    implicit none
    real(RP), intent(in) :: Mat(7,7)
    real(RP), intent(in) :: Mat_tr(7,7)
    real(RP), intent(in) :: vec_in_x(7,7**2)
    real(RP), intent(in) :: vec_in_y(7,7,7)
    real(RP), intent(in) :: vec_in_z(7,7,7)
    real(RP), intent(out) :: vec_out_x(7,7**2)
    real(RP), intent(out) :: vec_out_y(7,7**2)
    real(RP), intent(out) :: vec_out_z(7,7**2)

    integer :: i, j, k, jk
    !----------------------------------------------------------

    ! X-dir

    do jk=1, 7**2
    do i=1, 7
      vec_out_x(i,jk) = Mat(i,1) * vec_in_x(1,jk) &
                      + Mat(i,2) * vec_in_x(2,jk) &
                      + Mat(i,3) * vec_in_x(3,jk) &
                      + Mat(i,4) * vec_in_x(4,jk) &
                      + Mat(i,5) * vec_in_x(5,jk) &
                      + Mat(i,6) * vec_in_x(6,jk) &
                      + Mat(i,7) * vec_in_x(7,jk)
    end do
    end do

    ! Y-dir
    do k=1, 7
    do j=1, 7
      jk = j + (k-1)*7
      do i=1, 7
        vec_out_y(i,jk) = vec_in_y(i,1,k) * Mat_tr(1,j) &
                        + vec_in_y(i,2,k) * Mat_tr(2,j) &
                        + vec_in_y(i,3,k) * Mat_tr(3,j) &
                        + vec_in_y(i,4,k) * Mat_tr(4,j) &
                        + vec_in_y(i,5,k) * Mat_tr(5,j) &
                        + vec_in_y(i,6,k) * Mat_tr(6,j) &
                        + vec_in_y(i,7,k) * Mat_tr(7,j) 
      end do
    end do
    end do
    
    ! Z-dir
    do k=1, 7
    do j=1, 7
      jk = j + (k-1)*7
      do i=1, 7
        vec_out_z(i,jk) = vec_in_z(i,j,1) * Mat_tr(1,k) &
                        + vec_in_z(i,j,2) * Mat_tr(2,k) &
                        + vec_in_z(i,j,3) * Mat_tr(3,k) &
                        + vec_in_z(i,j,4) * Mat_tr(4,k) &
                        + vec_in_z(i,j,5) * Mat_tr(5,k) &
                        + vec_in_z(i,j,6) * Mat_tr(6,k) &
                        + vec_in_z(i,j,7) * Mat_tr(7,k) 
      end do
    end do
    end do
    return
  end subroutine element_operation_kernel_matvec_divlike_dirXYZ_P6

!OCL SERIAL
  subroutine element_operation_kernel_matvec_divlike_dirXYZ_var5_P6( &
    Mat, Mat_tr, vec_in_x, vec_in_y, vec_in_z, &
    vec_out_x, vec_out_y, vec_out_z  )
    implicit none
    real(RP), intent(in) :: Mat(7,7)
    real(RP), intent(in) :: Mat_tr(7,7)
    real(RP), intent(in) :: vec_in_x(7,7**2*5)
    real(RP), intent(in) :: vec_in_y(7,7,7*5)
    real(RP), intent(in) :: vec_in_z(7,7,7,5)
    real(RP), intent(out) :: vec_out_x(7,7**2*5)
    real(RP), intent(out) :: vec_out_y(7,7**2*5)
    real(RP), intent(out) :: vec_out_z(7,7**2,5)

    integer :: i, j, k, jkv, jk, v, kv
    !----------------------------------------------------------

    ! X-dir

    do jkv=1, 7**2*5
    do i=1, 7
      vec_out_x(i,jkv) = Mat(i,1) * vec_in_x(1,jkv) &
                      + Mat(i,2) * vec_in_x(2,jkv) &
                      + Mat(i,3) * vec_in_x(3,jkv) &
                      + Mat(i,4) * vec_in_x(4,jkv) &
                      + Mat(i,5) * vec_in_x(5,jkv) &
                      + Mat(i,6) * vec_in_x(6,jkv) &
                      + Mat(i,7) * vec_in_x(7,jkv)
    end do
    end do

    ! Y-dir
    do kv=1, 7*5
    do j=1, 7
      jkv = j + (kv-1)*35
      do i=1, 7
        vec_out_y(i,jkv) = vec_in_y(i,1,kv) * Mat_tr(1,j) &
                        + vec_in_y(i,2,kv) * Mat_tr(2,j) &
                        + vec_in_y(i,3,kv) * Mat_tr(3,j) &
                        + vec_in_y(i,4,kv) * Mat_tr(4,j) &
                        + vec_in_y(i,5,kv) * Mat_tr(5,j) &
                        + vec_in_y(i,6,kv) * Mat_tr(6,j) &
                        + vec_in_y(i,7,kv) * Mat_tr(7,j) 
      end do
    end do
    end do
    
    ! Z-dir
    do v=1, 5
    do k=1, 7
    do j=1, 7
      jk = j + (k-1)*7
      do i=1, 7
        vec_out_z(i,jk,v) = vec_in_z(i,j,1,v) * Mat_tr(1,k) &
                        + vec_in_z(i,j,2,v) * Mat_tr(2,k) &
                        + vec_in_z(i,j,3,v) * Mat_tr(3,k) &
                        + vec_in_z(i,j,4,v) * Mat_tr(4,k) &
                        + vec_in_z(i,j,5,v) * Mat_tr(5,k) &
                        + vec_in_z(i,j,6,v) * Mat_tr(6,k) &
                        + vec_in_z(i,j,7,v) * Mat_tr(7,k) 
      end do
    end do
    end do
    end do
    return
  end subroutine element_operation_kernel_matvec_divlike_dirXYZ_var5_P6

!> Calculate a matrix-vector multiplication associated with 3D modal filtering with p=6
!!
!OCL SERIAL
  subroutine element_operation_kernel_matvec_ModalFilter_P6( Mat_h1D, Mat_h1D_tr, Mat_v1D_tr, vec_in, vec_work, &
    vec_out  )
    implicit none
    real(RP), intent(in) :: Mat_h1D(7,7)
    real(RP), intent(in) :: Mat_h1D_tr(7,7)
    real(RP), intent(in) :: Mat_v1D_tr(7,7)
    real(RP), intent(in) :: vec_in(7,7,7)
    real(RP), intent(out) :: vec_work(7,7,7)
    real(RP), intent(out) :: vec_out(7,7,7)

    integer :: i, j, k
    !----------------------------------------------------------

    ! X-dir

    do k=1, 7
    do j=1, 7
    do i=1, 7
      vec_out(i,j,k) = Mat_h1D(i,1) * vec_in(1,j,k) &
                     + Mat_h1D(i,2) * vec_in(2,j,k) &
                     + Mat_h1D(i,3) * vec_in(3,j,k) &
                     + Mat_h1D(i,4) * vec_in(4,j,k) &
                     + Mat_h1D(i,5) * vec_in(5,j,k) &
                     + Mat_h1D(i,6) * vec_in(6,j,k) &
                     + Mat_h1D(i,7) * vec_in(7,j,k)
    end do
    end do
    end do
    
    ! Y-dir
    do k=1, 7
    do j=1, 7
    do i=1, 7
      vec_work(i,j,k) = vec_out(i,1,k) * Mat_h1D_tr(1,j) &
                      + vec_out(i,2,k) * Mat_h1D_tr(2,j) &
                      + vec_out(i,3,k) * Mat_h1D_tr(3,j) &
                      + vec_out(i,4,k) * Mat_h1D_tr(4,j) &
                      + vec_out(i,5,k) * Mat_h1D_tr(5,j) &
                      + vec_out(i,6,k) * Mat_h1D_tr(6,j) &
                      + vec_out(i,7,k) * Mat_h1D_tr(7,j) 
    end do
    end do
    end do
    
    ! Z-dir
    do k=1, 7
    do j=1, 7
    do i=1, 7
      vec_out(i,j,k) = vec_work(i,j,1) * Mat_v1D_tr(1,k) &
                     + vec_work(i,j,2) * Mat_v1D_tr(2,k) &
                     + vec_work(i,j,3) * Mat_v1D_tr(3,k) &
                     + vec_work(i,j,4) * Mat_v1D_tr(4,k) &
                     + vec_work(i,j,5) * Mat_v1D_tr(5,k) &
                     + vec_work(i,j,6) * Mat_v1D_tr(6,k) &
                     + vec_work(i,j,7) * Mat_v1D_tr(7,k) 
    end do
    end do
    end do

    return
  end subroutine element_operation_kernel_matvec_ModalFilter_P6

!--- For p=7 ------------------------------------

!> Calculate a matrix-vector multiplication associated with mathematical operations in the x direction (first dimension of vec_in) with p=7
!!
!OCL SERIAL
  subroutine element_operation_kernel_matvec_dirX_P7( Mat_x, vec_in, vec_out )
    implicit none
    real(RP), intent(in) :: Mat_x(8,8)
    real(RP), intent(in) :: vec_in(8,8**2)
    real(RP), intent(out) :: vec_out(8,8**2)

    integer :: i, jk
    !----------------------------------------------------------

    do jk=1, 8**2
    do i=1, 8
        vec_out(i,jk) = Mat_x(i,1) * vec_in(1,jk) &
                      + Mat_x(i,2) * vec_in(2,jk) &
                      + Mat_x(i,3) * vec_in(3,jk) &
                      + Mat_x(i,4) * vec_in(4,jk) &
                      + Mat_x(i,5) * vec_in(5,jk) &
                      + Mat_x(i,6) * vec_in(6,jk) &
                      + Mat_x(i,7) * vec_in(7,jk) &
                      + Mat_x(i,8) * vec_in(8,jk)
    end do
    end do

    return
  end subroutine element_operation_kernel_matvec_dirX_P7

!> Calculate a matrix-vector multiplication associated with mathematical operations in the y direction (second dimension of vec_in) with p=7
!! For a matrix-vector multiplication (vec_out = Mat_y vec_in), the passed variable of Mat_y should be transposed.
!!
!OCL SERIAL
  subroutine element_operation_kernel_matvec_dirY_P7( Mat_y_tr, vec_in, vec_out )
    implicit none
    real(RP), intent(in) :: Mat_y_tr(8,8)
    real(RP), intent(in) :: vec_in(8,8,8)
    real(RP), intent(out) :: vec_out(8,8,8)

    integer :: i, j, k
    !----------------------------------------------------------

    do k=1, 8
    do j=1, 8
    do i=1, 8
        vec_out(i,j,k) = vec_in(i,1,k) * Mat_y_tr(1,j) &
                       + vec_in(i,2,k) * Mat_y_tr(2,j) &
                       + vec_in(i,3,k) * Mat_y_tr(3,j) &
                       + vec_in(i,4,k) * Mat_y_tr(4,j) &
                       + vec_in(i,5,k) * Mat_y_tr(5,j) &
                       + vec_in(i,6,k) * Mat_y_tr(6,j) &
                       + vec_in(i,7,k) * Mat_y_tr(7,j) &
                       + vec_in(i,8,k) * Mat_y_tr(8,j) 
    end do
    end do
    end do

    return
  end subroutine element_operation_kernel_matvec_dirY_P7

!> Calculate a matrix-vector multiplication associated with mathematical operations in the z direction (third dimension of vec_in) with p=7
!! For a matrix-vector multiplication (vec_out = Mat_z vec_in), the passed variable of Mat_z should be transposed.
!!
!OCL SERIAL
  subroutine element_operation_kernel_matvec_dirZ_P7( Mat_z_tr, vec_in, vec_out )
    implicit none
    real(RP), intent(in) :: Mat_z_tr(8,8)
    real(RP), intent(in) :: vec_in(8,8,8)
    real(RP), intent(out) :: vec_out(8,8,8)

    integer :: i, j, k
    !----------------------------------------------------------

    do k=1, 8
    do j=1, 8
    do i=1, 8
        vec_out(i,j,k) = vec_in(i,j,1) * Mat_z_tr(1,k) &
                       + vec_in(i,j,2) * Mat_z_tr(2,k) &
                       + vec_in(i,j,3) * Mat_z_tr(3,k) &
                       + vec_in(i,j,4) * Mat_z_tr(4,k) &
                       + vec_in(i,j,5) * Mat_z_tr(5,k) &
                       + vec_in(i,j,6) * Mat_z_tr(6,k) &
                       + vec_in(i,j,7) * Mat_z_tr(7,k) &
                       + vec_in(i,j,8) * Mat_z_tr(8,k) 
    end do
    end do
    end do

    return
  end subroutine element_operation_kernel_matvec_dirZ_P7

!> Calculate a matrix-vector multiplication with lifting operations for a hexahedral element of order p=7
!!
!OCL SERIAL
  subroutine element_operation_kernel_matvec_Lift_hexahedral_P7( Lift, vec_in, vec_out )
    implicit none
    real(RP), intent(in) :: Lift(8,8,8,6)
    real(RP), intent(in) :: vec_in(8,8,6)
    real(RP), intent(out) :: vec_out(8,8,8)

    integer :: i, j, k
    !----------------------------------------------------------

    do k=1, 8
    do j=1, 8
    do i=1, 8
        vec_out(i,j,k) = Lift(i,j,k,1) * vec_in(i,k,1) &
                       + Lift(i,j,k,2) * vec_in(j,k,2) &
                       + Lift(i,j,k,3) * vec_in(i,k,3) &
                       + Lift(i,j,k,4) * vec_in(j,k,4) &
                       + Lift(i,j,k,5) * vec_in(i,j,5) &
                       + Lift(i,j,k,6) * vec_in(i,j,6)
    end do
    end do
    end do

    return
  end subroutine element_operation_kernel_matvec_Lift_hexahedral_P7
  
!> Calculate a matrix-vector multiplication associated with mathematical operations in the x, y, and z direction (third dimension of vec_in) with p=7
!! For a matrix-vector multiplication (vec_d_out = Mat_d vec_in where d=x,y,z), the passed variables of Mat_y and Mat_z should be transposed.
!! Note that we assume that vec_in_ has same data as vec_in, but are reshaped via the call of this subroutine. 
!!
!OCL SERIAL
  subroutine element_operation_kernel_matvec_gradlike_dirXYZ_P7( Mat, Mat_tr, vec_in, vec_in_, &
    vec_out_x, vec_out_y, vec_out_z  )
    implicit none
    real(RP), intent(in) :: Mat(8,8)
    real(RP), intent(in) :: Mat_tr(8,8)
    real(RP), intent(in) :: vec_in_(8,8**2)
    real(RP), intent(in) :: vec_in(8,8,8)
    real(RP), intent(out) :: vec_out_x(8,8**2)
    real(RP), intent(out) :: vec_out_y(8,8,8)
    real(RP), intent(out) :: vec_out_z(8,8,8)

    integer :: i, j, k, jk
    !----------------------------------------------------------

    ! X-dir

    do jk=1, 8**2
    do i=1, 8
        vec_out_x(i,jk) = Mat(i,1) * vec_in_(1,jk) &
                        + Mat(i,2) * vec_in_(2,jk) &
                        + Mat(i,3) * vec_in_(3,jk) &
                        + Mat(i,4) * vec_in_(4,jk) &
                        + Mat(i,5) * vec_in_(5,jk) &
                        + Mat(i,6) * vec_in_(6,jk) &
                        + Mat(i,7) * vec_in_(7,jk) &
                        + Mat(i,8) * vec_in_(8,jk)
    end do
    end do

    ! Y-dir
    do k=1, 8
    do j=1, 8
    do i=1, 8
        vec_out_y(i,j,k) = vec_in(i,1,k) * Mat_tr(1,j) &
                         + vec_in(i,2,k) * Mat_tr(2,j) &
                         + vec_in(i,3,k) * Mat_tr(3,j) &
                         + vec_in(i,4,k) * Mat_tr(4,j) &
                         + vec_in(i,5,k) * Mat_tr(5,j) &
                         + vec_in(i,6,k) * Mat_tr(6,j) &
                         + vec_in(i,7,k) * Mat_tr(7,j) &
                         + vec_in(i,8,k) * Mat_tr(8,j) 
    end do
    end do
    end do
    
    ! Z-dir
    do k=1, 8
    do j=1, 8
    do i=1, 8
        vec_out_z(i,j,k) = vec_in(i,1,k) * Mat_tr(1,j) &
                         + vec_in(i,j,2) * Mat_tr(2,k) &
                         + vec_in(i,j,3) * Mat_tr(3,k) &
                         + vec_in(i,j,4) * Mat_tr(4,k) &
                         + vec_in(i,j,5) * Mat_tr(5,k) &
                         + vec_in(i,j,6) * Mat_tr(6,k) &
                         + vec_in(i,j,7) * Mat_tr(7,k) &
                         + vec_in(i,j,8) * Mat_tr(8,k) 
    end do
    end do
    end do

    return
  end subroutine element_operation_kernel_matvec_gradlike_dirXYZ_P7

!> Calculate a matrix-vector multiplication associated with mathematical operations in the x, y, and z direction (third dimension of vec_in) with p=7
!! For a matrix-vector multiplication (vec_d_out = Mat_d vec_d_in where d=x,y,z), the passed variables of Mat_y and Mat_z should be transposed.
!! Note that we assume that vec_in_ has same data as vec_in, but are reshaped via the call of this subroutine. 
!!
!OCL SERIAL
  subroutine element_operation_kernel_matvec_divlike_dirXYZ_P7( &
    Mat, Mat_tr, vec_in_x, vec_in_y, vec_in_z, &
    vec_out_x, vec_out_y, vec_out_z  )
    implicit none
    real(RP), intent(in) :: Mat(8,8)
    real(RP), intent(in) :: Mat_tr(8,8)
    real(RP), intent(in) :: vec_in_x(8,8**2)
    real(RP), intent(in) :: vec_in_y(8,8,8)
    real(RP), intent(in) :: vec_in_z(8,8,8)
    real(RP), intent(out) :: vec_out_x(8,8**2)
    real(RP), intent(out) :: vec_out_y(8,8**2)
    real(RP), intent(out) :: vec_out_z(8,8**2)

    integer :: i, j, k, jk
    !----------------------------------------------------------

    ! X-dir

    do jk=1, 8**2
    do i=1, 8
      vec_out_x(i,jk) = Mat(i,1) * vec_in_x(1,jk) &
                      + Mat(i,2) * vec_in_x(2,jk) &
                      + Mat(i,3) * vec_in_x(3,jk) &
                      + Mat(i,4) * vec_in_x(4,jk) &
                      + Mat(i,5) * vec_in_x(5,jk) &
                      + Mat(i,6) * vec_in_x(6,jk) &
                      + Mat(i,7) * vec_in_x(7,jk) &
                      + Mat(i,8) * vec_in_x(8,jk)
    end do
    end do

    ! Y-dir
    do k=1, 8
    do j=1, 8
      jk = j + (k-1)*8
      do i=1, 8
        vec_out_y(i,jk) = vec_in_y(i,1,k) * Mat_tr(1,j) &
                        + vec_in_y(i,2,k) * Mat_tr(2,j) &
                        + vec_in_y(i,3,k) * Mat_tr(3,j) &
                        + vec_in_y(i,4,k) * Mat_tr(4,j) &
                        + vec_in_y(i,5,k) * Mat_tr(5,j) &
                        + vec_in_y(i,6,k) * Mat_tr(6,j) &
                        + vec_in_y(i,7,k) * Mat_tr(7,j) &
                        + vec_in_y(i,8,k) * Mat_tr(8,j) 
      end do
    end do
    end do
    
    ! Z-dir
    do k=1, 8
    do j=1, 8
      jk = j + (k-1)*8
      do i=1, 8
        vec_out_z(i,jk) = vec_in_z(i,j,1) * Mat_tr(1,k) &
                        + vec_in_z(i,j,2) * Mat_tr(2,k) &
                        + vec_in_z(i,j,3) * Mat_tr(3,k) &
                        + vec_in_z(i,j,4) * Mat_tr(4,k) &
                        + vec_in_z(i,j,5) * Mat_tr(5,k) &
                        + vec_in_z(i,j,6) * Mat_tr(6,k) &
                        + vec_in_z(i,j,7) * Mat_tr(7,k) &
                        + vec_in_z(i,j,8) * Mat_tr(8,k) 
      end do
    end do
    end do
    return
  end subroutine element_operation_kernel_matvec_divlike_dirXYZ_P7

!OCL SERIAL
  subroutine element_operation_kernel_matvec_divlike_dirXYZ_var5_P7( &
    Mat, Mat_tr, vec_in_x, vec_in_y, vec_in_z, &
    vec_out_x, vec_out_y, vec_out_z  )
    implicit none
    real(RP), intent(in) :: Mat(8,8)
    real(RP), intent(in) :: Mat_tr(8,8)
    real(RP), intent(in) :: vec_in_x(8,8**2*5)
    real(RP), intent(in) :: vec_in_y(8,8,8*5)
    real(RP), intent(in) :: vec_in_z(8,8,8,5)
    real(RP), intent(out) :: vec_out_x(8,8**2*5)
    real(RP), intent(out) :: vec_out_y(8,8**2*5)
    real(RP), intent(out) :: vec_out_z(8,8**2,5)

    integer :: i, j, k, jkv, jk, v, kv
    !----------------------------------------------------------

    ! X-dir

    do jkv=1, 8**2*5
    do i=1, 8
      vec_out_x(i,jkv) = Mat(i,1) * vec_in_x(1,jkv) &
                      + Mat(i,2) * vec_in_x(2,jkv) &
                      + Mat(i,3) * vec_in_x(3,jkv) &
                      + Mat(i,4) * vec_in_x(4,jkv) &
                      + Mat(i,5) * vec_in_x(5,jkv) &
                      + Mat(i,6) * vec_in_x(6,jkv) &
                      + Mat(i,7) * vec_in_x(7,jkv) &
                      + Mat(i,8) * vec_in_x(8,jkv)
    end do
    end do

    ! Y-dir
    do kv=1, 8*5
    do j=1, 8
      jkv = j + (kv-1)*40
      do i=1, 8
        vec_out_y(i,jkv) = vec_in_y(i,1,kv) * Mat_tr(1,j) &
                        + vec_in_y(i,2,kv) * Mat_tr(2,j) &
                        + vec_in_y(i,3,kv) * Mat_tr(3,j) &
                        + vec_in_y(i,4,kv) * Mat_tr(4,j) &
                        + vec_in_y(i,5,kv) * Mat_tr(5,j) &
                        + vec_in_y(i,6,kv) * Mat_tr(6,j) &
                        + vec_in_y(i,7,kv) * Mat_tr(7,j) &
                        + vec_in_y(i,8,kv) * Mat_tr(8,j) 
      end do
    end do
    end do
    
    ! Z-dir
    do v=1, 5
    do k=1, 8
    do j=1, 8
      jk = j + (k-1)*8
      do i=1, 8
        vec_out_z(i,jk,v) = vec_in_z(i,j,1,v) * Mat_tr(1,k) &
                        + vec_in_z(i,j,2,v) * Mat_tr(2,k) &
                        + vec_in_z(i,j,3,v) * Mat_tr(3,k) &
                        + vec_in_z(i,j,4,v) * Mat_tr(4,k) &
                        + vec_in_z(i,j,5,v) * Mat_tr(5,k) &
                        + vec_in_z(i,j,6,v) * Mat_tr(6,k) &
                        + vec_in_z(i,j,7,v) * Mat_tr(7,k) &
                        + vec_in_z(i,j,8,v) * Mat_tr(8,k) 
      end do
    end do
    end do
    end do
    return
  end subroutine element_operation_kernel_matvec_divlike_dirXYZ_var5_P7

!> Calculate a matrix-vector multiplication associated with 3D modal filtering with p=7
!!
!OCL SERIAL
  subroutine element_operation_kernel_matvec_ModalFilter_P7( Mat_h1D, Mat_h1D_tr, Mat_v1D_tr, vec_in, vec_work, &
    vec_out  )
    implicit none
    real(RP), intent(in) :: Mat_h1D(8,8)
    real(RP), intent(in) :: Mat_h1D_tr(8,8)
    real(RP), intent(in) :: Mat_v1D_tr(8,8)
    real(RP), intent(in) :: vec_in(8,8,8)
    real(RP), intent(out) :: vec_work(8,8,8)
    real(RP), intent(out) :: vec_out(8,8,8)

    integer :: i, j, k
    !----------------------------------------------------------

    ! X-dir

    do k=1, 8
    do j=1, 8
    do i=1, 8
      vec_out(i,j,k) = Mat_h1D(i,1) * vec_in(1,j,k) &
                     + Mat_h1D(i,2) * vec_in(2,j,k) &
                     + Mat_h1D(i,3) * vec_in(3,j,k) &
                     + Mat_h1D(i,4) * vec_in(4,j,k) &
                     + Mat_h1D(i,5) * vec_in(5,j,k) &
                     + Mat_h1D(i,6) * vec_in(6,j,k) &
                     + Mat_h1D(i,7) * vec_in(7,j,k) &
                     + Mat_h1D(i,8) * vec_in(8,j,k)
    end do
    end do
    end do
    
    ! Y-dir
    do k=1, 8
    do j=1, 8
    do i=1, 8
      vec_work(i,j,k) = vec_out(i,1,k) * Mat_h1D_tr(1,j) &
                      + vec_out(i,2,k) * Mat_h1D_tr(2,j) &
                      + vec_out(i,3,k) * Mat_h1D_tr(3,j) &
                      + vec_out(i,4,k) * Mat_h1D_tr(4,j) &
                      + vec_out(i,5,k) * Mat_h1D_tr(5,j) &
                      + vec_out(i,6,k) * Mat_h1D_tr(6,j) &
                      + vec_out(i,7,k) * Mat_h1D_tr(7,j) &
                      + vec_out(i,8,k) * Mat_h1D_tr(8,j) 
    end do
    end do
    end do
    
    ! Z-dir
    do k=1, 8
    do j=1, 8
    do i=1, 8
      vec_out(i,j,k) = vec_work(i,j,1) * Mat_v1D_tr(1,k) &
                     + vec_work(i,j,2) * Mat_v1D_tr(2,k) &
                     + vec_work(i,j,3) * Mat_v1D_tr(3,k) &
                     + vec_work(i,j,4) * Mat_v1D_tr(4,k) &
                     + vec_work(i,j,5) * Mat_v1D_tr(5,k) &
                     + vec_work(i,j,6) * Mat_v1D_tr(6,k) &
                     + vec_work(i,j,7) * Mat_v1D_tr(7,k) &
                     + vec_work(i,j,8) * Mat_v1D_tr(8,k) 
    end do
    end do
    end do

    return
  end subroutine element_operation_kernel_matvec_ModalFilter_P7

!--- For p=8 ------------------------------------

!> Calculate a matrix-vector multiplication associated with mathematical operations in the x direction (first dimension of vec_in) with p=8
!!
!OCL SERIAL
  subroutine element_operation_kernel_matvec_dirX_P8( Mat_x, vec_in, vec_out )
    implicit none
    real(RP), intent(in) :: Mat_x(9,9)
    real(RP), intent(in) :: vec_in(9,9**2)
    real(RP), intent(out) :: vec_out(9,9**2)

    integer :: i, jk
    !----------------------------------------------------------

    do jk=1, 9**2
    do i=1, 9
        vec_out(i,jk) = Mat_x(i,1) * vec_in(1,jk) &
                      + Mat_x(i,2) * vec_in(2,jk) &
                      + Mat_x(i,3) * vec_in(3,jk) &
                      + Mat_x(i,4) * vec_in(4,jk) &
                      + Mat_x(i,5) * vec_in(5,jk) &
                      + Mat_x(i,6) * vec_in(6,jk) &
                      + Mat_x(i,7) * vec_in(7,jk) &
                      + Mat_x(i,8) * vec_in(8,jk) &
                      + Mat_x(i,9) * vec_in(9,jk)
    end do
    end do

    return
  end subroutine element_operation_kernel_matvec_dirX_P8

!> Calculate a matrix-vector multiplication associated with mathematical operations in the y direction (second dimension of vec_in) with p=8
!! For a matrix-vector multiplication (vec_out = Mat_y vec_in), the passed variable of Mat_y should be transposed.
!!
!OCL SERIAL
  subroutine element_operation_kernel_matvec_dirY_P8( Mat_y_tr, vec_in, vec_out )
    implicit none
    real(RP), intent(in) :: Mat_y_tr(9,9)
    real(RP), intent(in) :: vec_in(9,9,9)
    real(RP), intent(out) :: vec_out(9,9,9)

    integer :: i, j, k
    !----------------------------------------------------------

    do k=1, 9
    do j=1, 9
    do i=1, 9
        vec_out(i,j,k) = vec_in(i,1,k) * Mat_y_tr(1,j) &
                       + vec_in(i,2,k) * Mat_y_tr(2,j) &
                       + vec_in(i,3,k) * Mat_y_tr(3,j) &
                       + vec_in(i,4,k) * Mat_y_tr(4,j) &
                       + vec_in(i,5,k) * Mat_y_tr(5,j) &
                       + vec_in(i,6,k) * Mat_y_tr(6,j) &
                       + vec_in(i,7,k) * Mat_y_tr(7,j) &
                       + vec_in(i,8,k) * Mat_y_tr(8,j) &
                       + vec_in(i,9,k) * Mat_y_tr(9,j) 
    end do
    end do
    end do

    return
  end subroutine element_operation_kernel_matvec_dirY_P8

!> Calculate a matrix-vector multiplication associated with mathematical operations in the z direction (third dimension of vec_in) with p=8
!! For a matrix-vector multiplication (vec_out = Mat_z vec_in), the passed variable of Mat_z should be transposed.
!!
!OCL SERIAL
  subroutine element_operation_kernel_matvec_dirZ_P8( Mat_z_tr, vec_in, vec_out )
    implicit none
    real(RP), intent(in) :: Mat_z_tr(9,9)
    real(RP), intent(in) :: vec_in(9,9,9)
    real(RP), intent(out) :: vec_out(9,9,9)

    integer :: i, j, k
    !----------------------------------------------------------

    do k=1, 9
    do j=1, 9
    do i=1, 9
        vec_out(i,j,k) = vec_in(i,j,1) * Mat_z_tr(1,k) &
                       + vec_in(i,j,2) * Mat_z_tr(2,k) &
                       + vec_in(i,j,3) * Mat_z_tr(3,k) &
                       + vec_in(i,j,4) * Mat_z_tr(4,k) &
                       + vec_in(i,j,5) * Mat_z_tr(5,k) &
                       + vec_in(i,j,6) * Mat_z_tr(6,k) &
                       + vec_in(i,j,7) * Mat_z_tr(7,k) &
                       + vec_in(i,j,8) * Mat_z_tr(8,k) &
                       + vec_in(i,j,9) * Mat_z_tr(9,k) 
    end do
    end do
    end do

    return
  end subroutine element_operation_kernel_matvec_dirZ_P8

!> Calculate a matrix-vector multiplication with lifting operations for a hexahedral element of order p=8
!!
!OCL SERIAL
  subroutine element_operation_kernel_matvec_Lift_hexahedral_P8( Lift, vec_in, vec_out )
    implicit none
    real(RP), intent(in) :: Lift(9,9,9,6)
    real(RP), intent(in) :: vec_in(9,9,6)
    real(RP), intent(out) :: vec_out(9,9,9)

    integer :: i, j, k
    !----------------------------------------------------------

    do k=1, 9
    do j=1, 9
    do i=1, 9
        vec_out(i,j,k) = Lift(i,j,k,1) * vec_in(i,k,1) &
                       + Lift(i,j,k,2) * vec_in(j,k,2) &
                       + Lift(i,j,k,3) * vec_in(i,k,3) &
                       + Lift(i,j,k,4) * vec_in(j,k,4) &
                       + Lift(i,j,k,5) * vec_in(i,j,5) &
                       + Lift(i,j,k,6) * vec_in(i,j,6)
    end do
    end do
    end do

    return
  end subroutine element_operation_kernel_matvec_Lift_hexahedral_P8
  
!> Calculate a matrix-vector multiplication associated with mathematical operations in the x, y, and z direction (third dimension of vec_in) with p=8
!! For a matrix-vector multiplication (vec_d_out = Mat_d vec_in where d=x,y,z), the passed variables of Mat_y and Mat_z should be transposed.
!! Note that we assume that vec_in_ has same data as vec_in, but are reshaped via the call of this subroutine. 
!!
!OCL SERIAL
  subroutine element_operation_kernel_matvec_gradlike_dirXYZ_P8( Mat, Mat_tr, vec_in, vec_in_, &
    vec_out_x, vec_out_y, vec_out_z  )
    implicit none
    real(RP), intent(in) :: Mat(9,9)
    real(RP), intent(in) :: Mat_tr(9,9)
    real(RP), intent(in) :: vec_in_(9,9**2)
    real(RP), intent(in) :: vec_in(9,9,9)
    real(RP), intent(out) :: vec_out_x(9,9**2)
    real(RP), intent(out) :: vec_out_y(9,9,9)
    real(RP), intent(out) :: vec_out_z(9,9,9)

    integer :: i, j, k, jk
    !----------------------------------------------------------

    ! X-dir

    do jk=1, 9**2
    do i=1, 9
        vec_out_x(i,jk) = Mat(i,1) * vec_in_(1,jk) &
                        + Mat(i,2) * vec_in_(2,jk) &
                        + Mat(i,3) * vec_in_(3,jk) &
                        + Mat(i,4) * vec_in_(4,jk) &
                        + Mat(i,5) * vec_in_(5,jk) &
                        + Mat(i,6) * vec_in_(6,jk) &
                        + Mat(i,7) * vec_in_(7,jk) &
                        + Mat(i,8) * vec_in_(8,jk) &
                        + Mat(i,9) * vec_in_(9,jk)
    end do
    end do

    ! Y-dir
    do k=1, 9
    do j=1, 9
    do i=1, 9
        vec_out_y(i,j,k) = vec_in(i,1,k) * Mat_tr(1,j) &
                         + vec_in(i,2,k) * Mat_tr(2,j) &
                         + vec_in(i,3,k) * Mat_tr(3,j) &
                         + vec_in(i,4,k) * Mat_tr(4,j) &
                         + vec_in(i,5,k) * Mat_tr(5,j) &
                         + vec_in(i,6,k) * Mat_tr(6,j) &
                         + vec_in(i,7,k) * Mat_tr(7,j) &
                         + vec_in(i,8,k) * Mat_tr(8,j) &
                         + vec_in(i,9,k) * Mat_tr(9,j) 
    end do
    end do
    end do
    
    ! Z-dir
    do k=1, 9
    do j=1, 9
    do i=1, 9
        vec_out_z(i,j,k) = vec_in(i,1,k) * Mat_tr(1,j) &
                         + vec_in(i,j,2) * Mat_tr(2,k) &
                         + vec_in(i,j,3) * Mat_tr(3,k) &
                         + vec_in(i,j,4) * Mat_tr(4,k) &
                         + vec_in(i,j,5) * Mat_tr(5,k) &
                         + vec_in(i,j,6) * Mat_tr(6,k) &
                         + vec_in(i,j,7) * Mat_tr(7,k) &
                         + vec_in(i,j,8) * Mat_tr(8,k) &
                         + vec_in(i,j,9) * Mat_tr(9,k) 
    end do
    end do
    end do

    return
  end subroutine element_operation_kernel_matvec_gradlike_dirXYZ_P8

!> Calculate a matrix-vector multiplication associated with mathematical operations in the x, y, and z direction (third dimension of vec_in) with p=8
!! For a matrix-vector multiplication (vec_d_out = Mat_d vec_d_in where d=x,y,z), the passed variables of Mat_y and Mat_z should be transposed.
!! Note that we assume that vec_in_ has same data as vec_in, but are reshaped via the call of this subroutine. 
!!
!OCL SERIAL
  subroutine element_operation_kernel_matvec_divlike_dirXYZ_P8( &
    Mat, Mat_tr, vec_in_x, vec_in_y, vec_in_z, &
    vec_out_x, vec_out_y, vec_out_z  )
    implicit none
    real(RP), intent(in) :: Mat(9,9)
    real(RP), intent(in) :: Mat_tr(9,9)
    real(RP), intent(in) :: vec_in_x(9,9**2)
    real(RP), intent(in) :: vec_in_y(9,9,9)
    real(RP), intent(in) :: vec_in_z(9,9,9)
    real(RP), intent(out) :: vec_out_x(9,9**2)
    real(RP), intent(out) :: vec_out_y(9,9**2)
    real(RP), intent(out) :: vec_out_z(9,9**2)

    integer :: i, j, k, jk
    real(RP) :: tmp1, tmp2, tmp3
    !----------------------------------------------------------

    ! X-dir

    do jk=1, 9**2
    do i=1, 9
      tmp1 = Mat(i,1) * vec_in_x(1,jk) &
           + Mat(i,2) * vec_in_x(2,jk) &
           + Mat(i,3) * vec_in_x(3,jk)
      tmp2 = Mat(i,4) * vec_in_x(4,jk) &
           + Mat(i,5) * vec_in_x(5,jk) &
           + Mat(i,6) * vec_in_x(6,jk)
      tmp3 = Mat(i,7) * vec_in_x(7,jk) &
           + Mat(i,8) * vec_in_x(8,jk) &
           + Mat(i,9) * vec_in_x(9,jk)
      vec_out_x(i,jk) = tmp1 + tmp2 + tmp3
    end do
    end do

    ! Y-dir
    do k=1, 9
    do j=1, 9
      jk = j + (k-1)*9
      do i=1, 9
        tmp1 = vec_in_y(i,1,k) * Mat_tr(1,j) &
             + vec_in_y(i,2,k) * Mat_tr(2,j) &
             + vec_in_y(i,3,k) * Mat_tr(3,j) 
        tmp2 = vec_in_y(i,4,k) * Mat_tr(4,j) &
             + vec_in_y(i,5,k) * Mat_tr(5,j) &
             + vec_in_y(i,6,k) * Mat_tr(6,j) 
        tmp3 = vec_in_y(i,7,k) * Mat_tr(7,j) &
             + vec_in_y(i,8,k) * Mat_tr(8,j) &
             + vec_in_y(i,9,k) * Mat_tr(9,j) 
      vec_out_y(i,jk) = tmp1 + tmp2 + tmp3
      end do
    end do
    end do
    
    ! Z-dir
    do k=1, 9
    do j=1, 9
      jk = j + (k-1)*9
      do i=1, 9
        tmp1 = vec_in_z(i,j,1) * Mat_tr(1,k) &
             + vec_in_z(i,j,2) * Mat_tr(2,k) &
             + vec_in_z(i,j,3) * Mat_tr(3,k) 
        tmp2 = vec_in_z(i,j,4) * Mat_tr(4,k) &
             + vec_in_z(i,j,5) * Mat_tr(5,k) &
             + vec_in_z(i,j,6) * Mat_tr(6,k) 
        tmp3 = vec_in_z(i,j,7) * Mat_tr(7,k) &
             + vec_in_z(i,j,8) * Mat_tr(8,k) &
             + vec_in_z(i,j,9) * Mat_tr(9,k) 
      vec_out_z(i,jk) = tmp1 + tmp2 + tmp3
      end do
    end do
    end do
    return
  end subroutine element_operation_kernel_matvec_divlike_dirXYZ_P8

!OCL SERIAL
  subroutine element_operation_kernel_matvec_divlike_dirXYZ_var5_P8( &
    Mat, Mat_tr, vec_in_x, vec_in_y, vec_in_z, &
    vec_out_x, vec_out_y, vec_out_z  )
    implicit none
    real(RP), intent(in) :: Mat(9,9)
    real(RP), intent(in) :: Mat_tr(9,9)
    real(RP), intent(in) :: vec_in_x(9,9**2*5)
    real(RP), intent(in) :: vec_in_y(9,9,9*5)
    real(RP), intent(in) :: vec_in_z(9,9,9,5)
    real(RP), intent(out) :: vec_out_x(9,9**2*5)
    real(RP), intent(out) :: vec_out_y(9,9**2*5)
    real(RP), intent(out) :: vec_out_z(9,9**2,5)

    integer :: i, j, k, jkv, jk, v, kv
    real(RP) :: tmp1, tmp2, tmp3
    !----------------------------------------------------------

    ! X-dir

    do jkv=1, 9**2*5
    do i=1, 9
      tmp1 = Mat(i,1) * vec_in_x(1,jkv) &
           + Mat(i,2) * vec_in_x(2,jkv) &
           + Mat(i,3) * vec_in_x(3,jkv)
      tmp2 = Mat(i,4) * vec_in_x(4,jkv) &
           + Mat(i,5) * vec_in_x(5,jkv) &
           + Mat(i,6) * vec_in_x(6,jkv)
      tmp3 = Mat(i,7) * vec_in_x(7,jkv) &
           + Mat(i,8) * vec_in_x(8,jkv) &
           + Mat(i,9) * vec_in_x(9,jkv)
      vec_out_x(i,jkv) = tmp1 + tmp2 + tmp3
    end do
    end do

    ! Y-dir
    do kv=1, 9*5
    do j=1, 9
      jkv = j + (kv-1)*45
      do i=1, 9
        tmp1 = vec_in_y(i,1,kv) * Mat_tr(1,j) &
             + vec_in_y(i,2,kv) * Mat_tr(2,j) &
             + vec_in_y(i,3,kv) * Mat_tr(3,j) 
        tmp2 = vec_in_y(i,4,kv) * Mat_tr(4,j) &
             + vec_in_y(i,5,kv) * Mat_tr(5,j) &
             + vec_in_y(i,6,kv) * Mat_tr(6,j) 
        tmp3 = vec_in_y(i,7,kv) * Mat_tr(7,j) &
             + vec_in_y(i,8,kv) * Mat_tr(8,j) &
             + vec_in_y(i,9,kv) * Mat_tr(9,j) 
      vec_out_y(i,jkv) = tmp1 + tmp2 + tmp3
      end do
    end do
    end do
    
    ! Z-dir
    do v=1, 5
    do k=1, 9
    do j=1, 9
      jk = j + (k-1)*9
      do i=1, 9
        tmp1 = vec_in_z(i,j,1,v) * Mat_tr(1,k) &
             + vec_in_z(i,j,2,v) * Mat_tr(2,k) &
             + vec_in_z(i,j,3,v) * Mat_tr(3,k) 
        tmp2 = vec_in_z(i,j,4,v) * Mat_tr(4,k) &
             + vec_in_z(i,j,5,v) * Mat_tr(5,k) &
             + vec_in_z(i,j,6,v) * Mat_tr(6,k) 
        tmp3 = vec_in_z(i,j,7,v) * Mat_tr(7,k) &
             + vec_in_z(i,j,8,v) * Mat_tr(8,k) &
             + vec_in_z(i,j,9,v) * Mat_tr(9,k) 
      vec_out_z(i,jk,v) = tmp1 + tmp2 + tmp3
      end do
    end do
    end do
    end do
    return
  end subroutine element_operation_kernel_matvec_divlike_dirXYZ_var5_P8

!> Calculate a matrix-vector multiplication associated with 3D modal filtering with p=8
!!
!OCL SERIAL
  subroutine element_operation_kernel_matvec_ModalFilter_P8( Mat_h1D, Mat_h1D_tr, Mat_v1D_tr, vec_in, vec_work, &
    vec_out  )
    implicit none
    real(RP), intent(in) :: Mat_h1D(9,9)
    real(RP), intent(in) :: Mat_h1D_tr(9,9)
    real(RP), intent(in) :: Mat_v1D_tr(9,9)
    real(RP), intent(in) :: vec_in(9,9,9)
    real(RP), intent(out) :: vec_work(9,9,9)
    real(RP), intent(out) :: vec_out(9,9,9)

    integer :: i, j, k
    real(RP) :: tmp1, tmp2, tmp3
    !----------------------------------------------------------

    ! X-dir

    do k=1, 9
    do j=1, 9
    do i=1, 9
      tmp1 = Mat_h1D(i,1) * vec_in(1,j,k) &
           + Mat_h1D(i,2) * vec_in(2,j,k) &
           + Mat_h1D(i,3) * vec_in(3,j,k)
      tmp2 = Mat_h1D(i,4) * vec_in(4,j,k) &
           + Mat_h1D(i,5) * vec_in(5,j,k) &
           + Mat_h1D(i,6) * vec_in(6,j,k)
      tmp3 = Mat_h1D(i,7) * vec_in(7,j,k) &
           + Mat_h1D(i,8) * vec_in(8,j,k) &
           + Mat_h1D(i,9) * vec_in(9,j,k)
      vec_out(i,j,k) = tmp1 + tmp2 + tmp3
    end do
    end do
    end do
    
    ! Y-dir
    do k=1, 9
    do j=1, 9
    do i=1, 9
      tmp1 = vec_out(i,1,k) * Mat_h1D_tr(1,j) &
           + vec_out(i,2,k) * Mat_h1D_tr(2,j) &
           + vec_out(i,3,k) * Mat_h1D_tr(3,j) 
      tmp2 = vec_out(i,4,k) * Mat_h1D_tr(4,j) &
           + vec_out(i,5,k) * Mat_h1D_tr(5,j) &
           + vec_out(i,6,k) * Mat_h1D_tr(6,j) 
      tmp3 = vec_out(i,7,k) * Mat_h1D_tr(7,j) &
           + vec_out(i,8,k) * Mat_h1D_tr(8,j) &
           + vec_out(i,9,k) * Mat_h1D_tr(9,j) 
      vec_work(i,j,k) = tmp1 + tmp2 + tmp3
    end do
    end do
    end do
    
    ! Z-dir
    do k=1, 9
    do j=1, 9
    do i=1, 9
      tmp1 = vec_work(i,j,1) * Mat_v1D_tr(1,k) &
           + vec_work(i,j,2) * Mat_v1D_tr(2,k) &
           + vec_work(i,j,3) * Mat_v1D_tr(3,k) 
      tmp2 = vec_work(i,j,4) * Mat_v1D_tr(4,k) &
           + vec_work(i,j,5) * Mat_v1D_tr(5,k) &
           + vec_work(i,j,6) * Mat_v1D_tr(6,k) 
      tmp3 = vec_work(i,j,7) * Mat_v1D_tr(7,k) &
           + vec_work(i,j,8) * Mat_v1D_tr(8,k) &
           + vec_work(i,j,9) * Mat_v1D_tr(9,k) 
      vec_out(i,j,k) = tmp1 + tmp2 + tmp3
    end do
    end do
    end do

    return
  end subroutine element_operation_kernel_matvec_ModalFilter_P8

!--- For p=9 ------------------------------------

!> Calculate a matrix-vector multiplication associated with mathematical operations in the x direction (first dimension of vec_in) with p=9
!!
!OCL SERIAL
  subroutine element_operation_kernel_matvec_dirX_P9( Mat_x, vec_in, vec_out )
    implicit none
    real(RP), intent(in) :: Mat_x(10,10)
    real(RP), intent(in) :: vec_in(10,10**2)
    real(RP), intent(out) :: vec_out(10,10**2)

    integer :: i, jk
    !----------------------------------------------------------

    do jk=1, 10**2
    do i=1, 10
        vec_out(i,jk) = Mat_x(i,1) * vec_in(1,jk) &
                      + Mat_x(i,2) * vec_in(2,jk) &
                      + Mat_x(i,3) * vec_in(3,jk) &
                      + Mat_x(i,4) * vec_in(4,jk) &
                      + Mat_x(i,5) * vec_in(5,jk) &
                      + Mat_x(i,6) * vec_in(6,jk) &
                      + Mat_x(i,7) * vec_in(7,jk) &
                      + Mat_x(i,8) * vec_in(8,jk) &
                      + Mat_x(i,9) * vec_in(9,jk) &
                      + Mat_x(i,10) * vec_in(10,jk)
    end do
    end do

    return
  end subroutine element_operation_kernel_matvec_dirX_P9

!> Calculate a matrix-vector multiplication associated with mathematical operations in the y direction (second dimension of vec_in) with p=9
!! For a matrix-vector multiplication (vec_out = Mat_y vec_in), the passed variable of Mat_y should be transposed.
!!
!OCL SERIAL
  subroutine element_operation_kernel_matvec_dirY_P9( Mat_y_tr, vec_in, vec_out )
    implicit none
    real(RP), intent(in) :: Mat_y_tr(10,10)
    real(RP), intent(in) :: vec_in(10,10,10)
    real(RP), intent(out) :: vec_out(10,10,10)

    integer :: i, j, k
    !----------------------------------------------------------

    do k=1, 10
    do j=1, 10
    do i=1, 10
        vec_out(i,j,k) = vec_in(i,1,k) * Mat_y_tr(1,j) &
                       + vec_in(i,2,k) * Mat_y_tr(2,j) &
                       + vec_in(i,3,k) * Mat_y_tr(3,j) &
                       + vec_in(i,4,k) * Mat_y_tr(4,j) &
                       + vec_in(i,5,k) * Mat_y_tr(5,j) &
                       + vec_in(i,6,k) * Mat_y_tr(6,j) &
                       + vec_in(i,7,k) * Mat_y_tr(7,j) &
                       + vec_in(i,8,k) * Mat_y_tr(8,j) &
                       + vec_in(i,9,k) * Mat_y_tr(9,j) &
                       + vec_in(i,10,k) * Mat_y_tr(10,j) 
    end do
    end do
    end do

    return
  end subroutine element_operation_kernel_matvec_dirY_P9

!> Calculate a matrix-vector multiplication associated with mathematical operations in the z direction (third dimension of vec_in) with p=9
!! For a matrix-vector multiplication (vec_out = Mat_z vec_in), the passed variable of Mat_z should be transposed.
!!
!OCL SERIAL
  subroutine element_operation_kernel_matvec_dirZ_P9( Mat_z_tr, vec_in, vec_out )
    implicit none
    real(RP), intent(in) :: Mat_z_tr(10,10)
    real(RP), intent(in) :: vec_in(10,10,10)
    real(RP), intent(out) :: vec_out(10,10,10)

    integer :: i, j, k
    !----------------------------------------------------------

    do k=1, 10
    do j=1, 10
    do i=1, 10
        vec_out(i,j,k) = vec_in(i,j,1) * Mat_z_tr(1,k) &
                       + vec_in(i,j,2) * Mat_z_tr(2,k) &
                       + vec_in(i,j,3) * Mat_z_tr(3,k) &
                       + vec_in(i,j,4) * Mat_z_tr(4,k) &
                       + vec_in(i,j,5) * Mat_z_tr(5,k) &
                       + vec_in(i,j,6) * Mat_z_tr(6,k) &
                       + vec_in(i,j,7) * Mat_z_tr(7,k) &
                       + vec_in(i,j,8) * Mat_z_tr(8,k) &
                       + vec_in(i,j,9) * Mat_z_tr(9,k) &
                       + vec_in(i,j,10) * Mat_z_tr(10,k) 
    end do
    end do
    end do

    return
  end subroutine element_operation_kernel_matvec_dirZ_P9

!> Calculate a matrix-vector multiplication with lifting operations for a hexahedral element of order p=9
!!
!OCL SERIAL
  subroutine element_operation_kernel_matvec_Lift_hexahedral_P9( Lift, vec_in, vec_out )
    implicit none
    real(RP), intent(in) :: Lift(10,10,10,6)
    real(RP), intent(in) :: vec_in(10,10,6)
    real(RP), intent(out) :: vec_out(10,10,10)

    integer :: i, j, k
    !----------------------------------------------------------

    do k=1, 10
    do j=1, 10
    do i=1, 10
        vec_out(i,j,k) = Lift(i,j,k,1) * vec_in(i,k,1) &
                       + Lift(i,j,k,2) * vec_in(j,k,2) &
                       + Lift(i,j,k,3) * vec_in(i,k,3) &
                       + Lift(i,j,k,4) * vec_in(j,k,4) &
                       + Lift(i,j,k,5) * vec_in(i,j,5) &
                       + Lift(i,j,k,6) * vec_in(i,j,6)
    end do
    end do
    end do

    return
  end subroutine element_operation_kernel_matvec_Lift_hexahedral_P9
  
!> Calculate a matrix-vector multiplication associated with mathematical operations in the x, y, and z direction (third dimension of vec_in) with p=9
!! For a matrix-vector multiplication (vec_d_out = Mat_d vec_in where d=x,y,z), the passed variables of Mat_y and Mat_z should be transposed.
!! Note that we assume that vec_in_ has same data as vec_in, but are reshaped via the call of this subroutine. 
!!
!OCL SERIAL
  subroutine element_operation_kernel_matvec_gradlike_dirXYZ_P9( Mat, Mat_tr, vec_in, vec_in_, &
    vec_out_x, vec_out_y, vec_out_z  )
    implicit none
    real(RP), intent(in) :: Mat(10,10)
    real(RP), intent(in) :: Mat_tr(10,10)
    real(RP), intent(in) :: vec_in_(10,10**2)
    real(RP), intent(in) :: vec_in(10,10,10)
    real(RP), intent(out) :: vec_out_x(10,10**2)
    real(RP), intent(out) :: vec_out_y(10,10,10)
    real(RP), intent(out) :: vec_out_z(10,10,10)

    integer :: i, j, k, jk
    !----------------------------------------------------------

    ! X-dir

    do jk=1, 10**2
    do i=1, 10
        vec_out_x(i,jk) = Mat(i,1) * vec_in_(1,jk) &
                        + Mat(i,2) * vec_in_(2,jk) &
                        + Mat(i,3) * vec_in_(3,jk) &
                        + Mat(i,4) * vec_in_(4,jk) &
                        + Mat(i,5) * vec_in_(5,jk) &
                        + Mat(i,6) * vec_in_(6,jk) &
                        + Mat(i,7) * vec_in_(7,jk) &
                        + Mat(i,8) * vec_in_(8,jk) &
                        + Mat(i,9) * vec_in_(9,jk) &
                        + Mat(i,10) * vec_in_(10,jk)
    end do
    end do

    ! Y-dir
    do k=1, 10
    do j=1, 10
    do i=1, 10
        vec_out_y(i,j,k) = vec_in(i,1,k) * Mat_tr(1,j) &
                         + vec_in(i,2,k) * Mat_tr(2,j) &
                         + vec_in(i,3,k) * Mat_tr(3,j) &
                         + vec_in(i,4,k) * Mat_tr(4,j) &
                         + vec_in(i,5,k) * Mat_tr(5,j) &
                         + vec_in(i,6,k) * Mat_tr(6,j) &
                         + vec_in(i,7,k) * Mat_tr(7,j) &
                         + vec_in(i,8,k) * Mat_tr(8,j) &
                         + vec_in(i,9,k) * Mat_tr(9,j) &
                         + vec_in(i,10,k) * Mat_tr(10,j) 
    end do
    end do
    end do
    
    ! Z-dir
    do k=1, 10
    do j=1, 10
    do i=1, 10
        vec_out_z(i,j,k) = vec_in(i,1,k) * Mat_tr(1,j) &
                         + vec_in(i,j,2) * Mat_tr(2,k) &
                         + vec_in(i,j,3) * Mat_tr(3,k) &
                         + vec_in(i,j,4) * Mat_tr(4,k) &
                         + vec_in(i,j,5) * Mat_tr(5,k) &
                         + vec_in(i,j,6) * Mat_tr(6,k) &
                         + vec_in(i,j,7) * Mat_tr(7,k) &
                         + vec_in(i,j,8) * Mat_tr(8,k) &
                         + vec_in(i,j,9) * Mat_tr(9,k) &
                         + vec_in(i,j,10) * Mat_tr(10,k) 
    end do
    end do
    end do

    return
  end subroutine element_operation_kernel_matvec_gradlike_dirXYZ_P9

!> Calculate a matrix-vector multiplication associated with mathematical operations in the x, y, and z direction (third dimension of vec_in) with p=9
!! For a matrix-vector multiplication (vec_d_out = Mat_d vec_d_in where d=x,y,z), the passed variables of Mat_y and Mat_z should be transposed.
!! Note that we assume that vec_in_ has same data as vec_in, but are reshaped via the call of this subroutine. 
!!
!OCL SERIAL
  subroutine element_operation_kernel_matvec_divlike_dirXYZ_P9( &
    Mat, Mat_tr, vec_in_x, vec_in_y, vec_in_z, &
    vec_out_x, vec_out_y, vec_out_z  )
    implicit none
    real(RP), intent(in) :: Mat(10,10)
    real(RP), intent(in) :: Mat_tr(10,10)
    real(RP), intent(in) :: vec_in_x(10,10**2)
    real(RP), intent(in) :: vec_in_y(10,10,10)
    real(RP), intent(in) :: vec_in_z(10,10,10)
    real(RP), intent(out) :: vec_out_x(10,10**2)
    real(RP), intent(out) :: vec_out_y(10,10**2)
    real(RP), intent(out) :: vec_out_z(10,10**2)

    integer :: i, j, k, jk
    real(RP) :: tmp1, tmp2, tmp3
    !----------------------------------------------------------

    ! X-dir

    do jk=1, 10**2
    do i=1, 10
      tmp1 = Mat(i,1) * vec_in_x(1,jk) &
           + Mat(i,2) * vec_in_x(2,jk) &
           + Mat(i,3) * vec_in_x(3,jk)
      tmp2 = Mat(i,4) * vec_in_x(4,jk) &
           + Mat(i,5) * vec_in_x(5,jk) &
           + Mat(i,6) * vec_in_x(6,jk)
      tmp3 = Mat(i,7) * vec_in_x(7,jk) &
           + Mat(i,8) * vec_in_x(8,jk) &
           + Mat(i,9) * vec_in_x(9,jk) &
           + Mat(i,10) * vec_in_x(10,jk)
      vec_out_x(i,jk) = tmp1 + tmp2 + tmp3
    end do
    end do

    ! Y-dir
    do k=1, 10
    do j=1, 10
      jk = j + (k-1)*10
      do i=1, 10
        tmp1 = vec_in_y(i,1,k) * Mat_tr(1,j) &
             + vec_in_y(i,2,k) * Mat_tr(2,j) &
             + vec_in_y(i,3,k) * Mat_tr(3,j) 
        tmp2 = vec_in_y(i,4,k) * Mat_tr(4,j) &
             + vec_in_y(i,5,k) * Mat_tr(5,j) &
             + vec_in_y(i,6,k) * Mat_tr(6,j) 
        tmp3 = vec_in_y(i,7,k) * Mat_tr(7,j) &
             + vec_in_y(i,8,k) * Mat_tr(8,j) &
             + vec_in_y(i,9,k) * Mat_tr(9,j) &
             + vec_in_y(i,10,k) * Mat_tr(10,j) 
      vec_out_y(i,jk) = tmp1 + tmp2 + tmp3
      end do
    end do
    end do
    
    ! Z-dir
    do k=1, 10
    do j=1, 10
      jk = j + (k-1)*10
      do i=1, 10
        tmp1 = vec_in_z(i,j,1) * Mat_tr(1,k) &
             + vec_in_z(i,j,2) * Mat_tr(2,k) &
             + vec_in_z(i,j,3) * Mat_tr(3,k) 
        tmp2 = vec_in_z(i,j,4) * Mat_tr(4,k) &
             + vec_in_z(i,j,5) * Mat_tr(5,k) &
             + vec_in_z(i,j,6) * Mat_tr(6,k) 
        tmp3 = vec_in_z(i,j,7) * Mat_tr(7,k) &
             + vec_in_z(i,j,8) * Mat_tr(8,k) &
             + vec_in_z(i,j,9) * Mat_tr(9,k) &
             + vec_in_z(i,j,10) * Mat_tr(10,k) 
      vec_out_z(i,jk) = tmp1 + tmp2 + tmp3
      end do
    end do
    end do
    return
  end subroutine element_operation_kernel_matvec_divlike_dirXYZ_P9

!OCL SERIAL
  subroutine element_operation_kernel_matvec_divlike_dirXYZ_var5_P9( &
    Mat, Mat_tr, vec_in_x, vec_in_y, vec_in_z, &
    vec_out_x, vec_out_y, vec_out_z  )
    implicit none
    real(RP), intent(in) :: Mat(10,10)
    real(RP), intent(in) :: Mat_tr(10,10)
    real(RP), intent(in) :: vec_in_x(10,10**2*5)
    real(RP), intent(in) :: vec_in_y(10,10,10*5)
    real(RP), intent(in) :: vec_in_z(10,10,10,5)
    real(RP), intent(out) :: vec_out_x(10,10**2*5)
    real(RP), intent(out) :: vec_out_y(10,10**2*5)
    real(RP), intent(out) :: vec_out_z(10,10**2,5)

    integer :: i, j, k, jkv, jk, v, kv
    real(RP) :: tmp1, tmp2, tmp3
    !----------------------------------------------------------

    ! X-dir

    do jkv=1, 10**2*5
    do i=1, 10
      tmp1 = Mat(i,1) * vec_in_x(1,jkv) &
           + Mat(i,2) * vec_in_x(2,jkv) &
           + Mat(i,3) * vec_in_x(3,jkv)
      tmp2 = Mat(i,4) * vec_in_x(4,jkv) &
           + Mat(i,5) * vec_in_x(5,jkv) &
           + Mat(i,6) * vec_in_x(6,jkv)
      tmp3 = Mat(i,7) * vec_in_x(7,jkv) &
           + Mat(i,8) * vec_in_x(8,jkv) &
           + Mat(i,9) * vec_in_x(9,jkv) &
           + Mat(i,10) * vec_in_x(10,jkv)
      vec_out_x(i,jkv) = tmp1 + tmp2 + tmp3
    end do
    end do

    ! Y-dir
    do kv=1, 10*5
    do j=1, 10
      jkv = j + (kv-1)*50
      do i=1, 10
        tmp1 = vec_in_y(i,1,kv) * Mat_tr(1,j) &
             + vec_in_y(i,2,kv) * Mat_tr(2,j) &
             + vec_in_y(i,3,kv) * Mat_tr(3,j) 
        tmp2 = vec_in_y(i,4,kv) * Mat_tr(4,j) &
             + vec_in_y(i,5,kv) * Mat_tr(5,j) &
             + vec_in_y(i,6,kv) * Mat_tr(6,j) 
        tmp3 = vec_in_y(i,7,kv) * Mat_tr(7,j) &
             + vec_in_y(i,8,kv) * Mat_tr(8,j) &
             + vec_in_y(i,9,kv) * Mat_tr(9,j) &
             + vec_in_y(i,10,kv) * Mat_tr(10,j) 
      vec_out_y(i,jkv) = tmp1 + tmp2 + tmp3
      end do
    end do
    end do
    
    ! Z-dir
    do v=1, 5
    do k=1, 10
    do j=1, 10
      jk = j + (k-1)*10
      do i=1, 10
        tmp1 = vec_in_z(i,j,1,v) * Mat_tr(1,k) &
             + vec_in_z(i,j,2,v) * Mat_tr(2,k) &
             + vec_in_z(i,j,3,v) * Mat_tr(3,k) 
        tmp2 = vec_in_z(i,j,4,v) * Mat_tr(4,k) &
             + vec_in_z(i,j,5,v) * Mat_tr(5,k) &
             + vec_in_z(i,j,6,v) * Mat_tr(6,k) 
        tmp3 = vec_in_z(i,j,7,v) * Mat_tr(7,k) &
             + vec_in_z(i,j,8,v) * Mat_tr(8,k) &
             + vec_in_z(i,j,9,v) * Mat_tr(9,k) &
             + vec_in_z(i,j,10,v) * Mat_tr(10,k) 
      vec_out_z(i,jk,v) = tmp1 + tmp2 + tmp3
      end do
    end do
    end do
    end do
    return
  end subroutine element_operation_kernel_matvec_divlike_dirXYZ_var5_P9

!> Calculate a matrix-vector multiplication associated with 3D modal filtering with p=9
!!
!OCL SERIAL
  subroutine element_operation_kernel_matvec_ModalFilter_P9( Mat_h1D, Mat_h1D_tr, Mat_v1D_tr, vec_in, vec_work, &
    vec_out  )
    implicit none
    real(RP), intent(in) :: Mat_h1D(10,10)
    real(RP), intent(in) :: Mat_h1D_tr(10,10)
    real(RP), intent(in) :: Mat_v1D_tr(10,10)
    real(RP), intent(in) :: vec_in(10,10,10)
    real(RP), intent(out) :: vec_work(10,10,10)
    real(RP), intent(out) :: vec_out(10,10,10)

    integer :: i, j, k
    real(RP) :: tmp1, tmp2, tmp3
    !----------------------------------------------------------

    ! X-dir

    do k=1, 10
    do j=1, 10
    do i=1, 10
      tmp1 = Mat_h1D(i,1) * vec_in(1,j,k) &
           + Mat_h1D(i,2) * vec_in(2,j,k) &
           + Mat_h1D(i,3) * vec_in(3,j,k)
      tmp2 = Mat_h1D(i,4) * vec_in(4,j,k) &
           + Mat_h1D(i,5) * vec_in(5,j,k) &
           + Mat_h1D(i,6) * vec_in(6,j,k)
      tmp3 = Mat_h1D(i,7) * vec_in(7,j,k) &
           + Mat_h1D(i,8) * vec_in(8,j,k) &
           + Mat_h1D(i,9) * vec_in(9,j,k) &
           + Mat_h1D(i,10) * vec_in(10,j,k)
      vec_out(i,j,k) = tmp1 + tmp2 + tmp3
    end do
    end do
    end do
    
    ! Y-dir
    do k=1, 10
    do j=1, 10
    do i=1, 10
      tmp1 = vec_out(i,1,k) * Mat_h1D_tr(1,j) &
           + vec_out(i,2,k) * Mat_h1D_tr(2,j) &
           + vec_out(i,3,k) * Mat_h1D_tr(3,j) 
      tmp2 = vec_out(i,4,k) * Mat_h1D_tr(4,j) &
           + vec_out(i,5,k) * Mat_h1D_tr(5,j) &
           + vec_out(i,6,k) * Mat_h1D_tr(6,j) 
      tmp3 = vec_out(i,7,k) * Mat_h1D_tr(7,j) &
           + vec_out(i,8,k) * Mat_h1D_tr(8,j) &
           + vec_out(i,9,k) * Mat_h1D_tr(9,j) &
           + vec_out(i,10,k) * Mat_h1D_tr(10,j) 
      vec_work(i,j,k) = tmp1 + tmp2 + tmp3
    end do
    end do
    end do
    
    ! Z-dir
    do k=1, 10
    do j=1, 10
    do i=1, 10
      tmp1 = vec_work(i,j,1) * Mat_v1D_tr(1,k) &
           + vec_work(i,j,2) * Mat_v1D_tr(2,k) &
           + vec_work(i,j,3) * Mat_v1D_tr(3,k) 
      tmp2 = vec_work(i,j,4) * Mat_v1D_tr(4,k) &
           + vec_work(i,j,5) * Mat_v1D_tr(5,k) &
           + vec_work(i,j,6) * Mat_v1D_tr(6,k) 
      tmp3 = vec_work(i,j,7) * Mat_v1D_tr(7,k) &
           + vec_work(i,j,8) * Mat_v1D_tr(8,k) &
           + vec_work(i,j,9) * Mat_v1D_tr(9,k) &
           + vec_work(i,j,10) * Mat_v1D_tr(10,k) 
      vec_out(i,j,k) = tmp1 + tmp2 + tmp3
    end do
    end do
    end do

    return
  end subroutine element_operation_kernel_matvec_ModalFilter_P9

!--- For p=10 ------------------------------------

!> Calculate a matrix-vector multiplication associated with mathematical operations in the x direction (first dimension of vec_in) with p=10
!!
!OCL SERIAL
  subroutine element_operation_kernel_matvec_dirX_P10( Mat_x, vec_in, vec_out )
    implicit none
    real(RP), intent(in) :: Mat_x(11,11)
    real(RP), intent(in) :: vec_in(11,11**2)
    real(RP), intent(out) :: vec_out(11,11**2)

    integer :: i, jk
    !----------------------------------------------------------

    do jk=1, 11**2
    do i=1, 11
        vec_out(i,jk) = Mat_x(i,1) * vec_in(1,jk) &
                      + Mat_x(i,2) * vec_in(2,jk) &
                      + Mat_x(i,3) * vec_in(3,jk) &
                      + Mat_x(i,4) * vec_in(4,jk) &
                      + Mat_x(i,5) * vec_in(5,jk) &
                      + Mat_x(i,6) * vec_in(6,jk) &
                      + Mat_x(i,7) * vec_in(7,jk) &
                      + Mat_x(i,8) * vec_in(8,jk) &
                      + Mat_x(i,9) * vec_in(9,jk) &
                      + Mat_x(i,10) * vec_in(10,jk) &
                      + Mat_x(i,11) * vec_in(11,jk)
    end do
    end do

    return
  end subroutine element_operation_kernel_matvec_dirX_P10

!> Calculate a matrix-vector multiplication associated with mathematical operations in the y direction (second dimension of vec_in) with p=10
!! For a matrix-vector multiplication (vec_out = Mat_y vec_in), the passed variable of Mat_y should be transposed.
!!
!OCL SERIAL
  subroutine element_operation_kernel_matvec_dirY_P10( Mat_y_tr, vec_in, vec_out )
    implicit none
    real(RP), intent(in) :: Mat_y_tr(11,11)
    real(RP), intent(in) :: vec_in(11,11,11)
    real(RP), intent(out) :: vec_out(11,11,11)

    integer :: i, j, k
    !----------------------------------------------------------

    do k=1, 11
    do j=1, 11
    do i=1, 11
        vec_out(i,j,k) = vec_in(i,1,k) * Mat_y_tr(1,j) &
                       + vec_in(i,2,k) * Mat_y_tr(2,j) &
                       + vec_in(i,3,k) * Mat_y_tr(3,j) &
                       + vec_in(i,4,k) * Mat_y_tr(4,j) &
                       + vec_in(i,5,k) * Mat_y_tr(5,j) &
                       + vec_in(i,6,k) * Mat_y_tr(6,j) &
                       + vec_in(i,7,k) * Mat_y_tr(7,j) &
                       + vec_in(i,8,k) * Mat_y_tr(8,j) &
                       + vec_in(i,9,k) * Mat_y_tr(9,j) &
                       + vec_in(i,10,k) * Mat_y_tr(10,j) &
                       + vec_in(i,11,k) * Mat_y_tr(11,j) 
    end do
    end do
    end do

    return
  end subroutine element_operation_kernel_matvec_dirY_P10

!> Calculate a matrix-vector multiplication associated with mathematical operations in the z direction (third dimension of vec_in) with p=10
!! For a matrix-vector multiplication (vec_out = Mat_z vec_in), the passed variable of Mat_z should be transposed.
!!
!OCL SERIAL
  subroutine element_operation_kernel_matvec_dirZ_P10( Mat_z_tr, vec_in, vec_out )
    implicit none
    real(RP), intent(in) :: Mat_z_tr(11,11)
    real(RP), intent(in) :: vec_in(11,11,11)
    real(RP), intent(out) :: vec_out(11,11,11)

    integer :: i, j, k
    !----------------------------------------------------------

    do k=1, 11
    do j=1, 11
    do i=1, 11
        vec_out(i,j,k) = vec_in(i,j,1) * Mat_z_tr(1,k) &
                       + vec_in(i,j,2) * Mat_z_tr(2,k) &
                       + vec_in(i,j,3) * Mat_z_tr(3,k) &
                       + vec_in(i,j,4) * Mat_z_tr(4,k) &
                       + vec_in(i,j,5) * Mat_z_tr(5,k) &
                       + vec_in(i,j,6) * Mat_z_tr(6,k) &
                       + vec_in(i,j,7) * Mat_z_tr(7,k) &
                       + vec_in(i,j,8) * Mat_z_tr(8,k) &
                       + vec_in(i,j,9) * Mat_z_tr(9,k) &
                       + vec_in(i,j,10) * Mat_z_tr(10,k) &
                       + vec_in(i,j,11) * Mat_z_tr(11,k) 
    end do
    end do
    end do

    return
  end subroutine element_operation_kernel_matvec_dirZ_P10

!> Calculate a matrix-vector multiplication with lifting operations for a hexahedral element of order p=10
!!
!OCL SERIAL
  subroutine element_operation_kernel_matvec_Lift_hexahedral_P10( Lift, vec_in, vec_out )
    implicit none
    real(RP), intent(in) :: Lift(11,11,11,6)
    real(RP), intent(in) :: vec_in(11,11,6)
    real(RP), intent(out) :: vec_out(11,11,11)

    integer :: i, j, k
    !----------------------------------------------------------

    do k=1, 11
    do j=1, 11
    do i=1, 11
        vec_out(i,j,k) = Lift(i,j,k,1) * vec_in(i,k,1) &
                       + Lift(i,j,k,2) * vec_in(j,k,2) &
                       + Lift(i,j,k,3) * vec_in(i,k,3) &
                       + Lift(i,j,k,4) * vec_in(j,k,4) &
                       + Lift(i,j,k,5) * vec_in(i,j,5) &
                       + Lift(i,j,k,6) * vec_in(i,j,6)
    end do
    end do
    end do

    return
  end subroutine element_operation_kernel_matvec_Lift_hexahedral_P10
  
!> Calculate a matrix-vector multiplication associated with mathematical operations in the x, y, and z direction (third dimension of vec_in) with p=10
!! For a matrix-vector multiplication (vec_d_out = Mat_d vec_in where d=x,y,z), the passed variables of Mat_y and Mat_z should be transposed.
!! Note that we assume that vec_in_ has same data as vec_in, but are reshaped via the call of this subroutine. 
!!
!OCL SERIAL
  subroutine element_operation_kernel_matvec_gradlike_dirXYZ_P10( Mat, Mat_tr, vec_in, vec_in_, &
    vec_out_x, vec_out_y, vec_out_z  )
    implicit none
    real(RP), intent(in) :: Mat(11,11)
    real(RP), intent(in) :: Mat_tr(11,11)
    real(RP), intent(in) :: vec_in_(11,11**2)
    real(RP), intent(in) :: vec_in(11,11,11)
    real(RP), intent(out) :: vec_out_x(11,11**2)
    real(RP), intent(out) :: vec_out_y(11,11,11)
    real(RP), intent(out) :: vec_out_z(11,11,11)

    integer :: i, j, k, jk
    !----------------------------------------------------------

    ! X-dir

    do jk=1, 11**2
    do i=1, 11
        vec_out_x(i,jk) = Mat(i,1) * vec_in_(1,jk) &
                        + Mat(i,2) * vec_in_(2,jk) &
                        + Mat(i,3) * vec_in_(3,jk) &
                        + Mat(i,4) * vec_in_(4,jk) &
                        + Mat(i,5) * vec_in_(5,jk) &
                        + Mat(i,6) * vec_in_(6,jk) &
                        + Mat(i,7) * vec_in_(7,jk) &
                        + Mat(i,8) * vec_in_(8,jk) &
                        + Mat(i,9) * vec_in_(9,jk) &
                        + Mat(i,10) * vec_in_(10,jk) &
                        + Mat(i,11) * vec_in_(11,jk)
    end do
    end do

    ! Y-dir
    do k=1, 11
    do j=1, 11
    do i=1, 11
        vec_out_y(i,j,k) = vec_in(i,1,k) * Mat_tr(1,j) &
                         + vec_in(i,2,k) * Mat_tr(2,j) &
                         + vec_in(i,3,k) * Mat_tr(3,j) &
                         + vec_in(i,4,k) * Mat_tr(4,j) &
                         + vec_in(i,5,k) * Mat_tr(5,j) &
                         + vec_in(i,6,k) * Mat_tr(6,j) &
                         + vec_in(i,7,k) * Mat_tr(7,j) &
                         + vec_in(i,8,k) * Mat_tr(8,j) &
                         + vec_in(i,9,k) * Mat_tr(9,j) &
                         + vec_in(i,10,k) * Mat_tr(10,j) &
                         + vec_in(i,11,k) * Mat_tr(11,j) 
    end do
    end do
    end do
    
    ! Z-dir
    do k=1, 11
    do j=1, 11
    do i=1, 11
        vec_out_z(i,j,k) = vec_in(i,1,k) * Mat_tr(1,j) &
                         + vec_in(i,j,2) * Mat_tr(2,k) &
                         + vec_in(i,j,3) * Mat_tr(3,k) &
                         + vec_in(i,j,4) * Mat_tr(4,k) &
                         + vec_in(i,j,5) * Mat_tr(5,k) &
                         + vec_in(i,j,6) * Mat_tr(6,k) &
                         + vec_in(i,j,7) * Mat_tr(7,k) &
                         + vec_in(i,j,8) * Mat_tr(8,k) &
                         + vec_in(i,j,9) * Mat_tr(9,k) &
                         + vec_in(i,j,10) * Mat_tr(10,k) &
                         + vec_in(i,j,11) * Mat_tr(11,k) 
    end do
    end do
    end do

    return
  end subroutine element_operation_kernel_matvec_gradlike_dirXYZ_P10

!> Calculate a matrix-vector multiplication associated with mathematical operations in the x, y, and z direction (third dimension of vec_in) with p=10
!! For a matrix-vector multiplication (vec_d_out = Mat_d vec_d_in where d=x,y,z), the passed variables of Mat_y and Mat_z should be transposed.
!! Note that we assume that vec_in_ has same data as vec_in, but are reshaped via the call of this subroutine. 
!!
!OCL SERIAL
  subroutine element_operation_kernel_matvec_divlike_dirXYZ_P10( &
    Mat, Mat_tr, vec_in_x, vec_in_y, vec_in_z, &
    vec_out_x, vec_out_y, vec_out_z  )
    implicit none
    real(RP), intent(in) :: Mat(11,11)
    real(RP), intent(in) :: Mat_tr(11,11)
    real(RP), intent(in) :: vec_in_x(11,11**2)
    real(RP), intent(in) :: vec_in_y(11,11,11)
    real(RP), intent(in) :: vec_in_z(11,11,11)
    real(RP), intent(out) :: vec_out_x(11,11**2)
    real(RP), intent(out) :: vec_out_y(11,11**2)
    real(RP), intent(out) :: vec_out_z(11,11**2)

    integer :: i, j, k, jk
    real(RP) :: tmp1, tmp2, tmp3
    !----------------------------------------------------------

    ! X-dir

    do jk=1, 11**2
    do i=1, 11
      tmp1 = Mat(i,1) * vec_in_x(1,jk) &
           + Mat(i,2) * vec_in_x(2,jk) &
           + Mat(i,3) * vec_in_x(3,jk) &
           + Mat(i,4) * vec_in_x(4,jk)
      tmp2 = Mat(i,5) * vec_in_x(5,jk) &
           + Mat(i,6) * vec_in_x(6,jk) &
           + Mat(i,7) * vec_in_x(7,jk) &
           + Mat(i,8) * vec_in_x(8,jk)
      tmp3 = Mat(i,9) * vec_in_x(9,jk) &
           + Mat(i,10) * vec_in_x(10,jk) &
           + Mat(i,11) * vec_in_x(11,jk)
      vec_out_x(i,jk) = tmp1 + tmp2 + tmp3
    end do
    end do

    ! Y-dir
    do k=1, 11
    do j=1, 11
      jk = j + (k-1)*11
      do i=1, 11
        tmp1 = vec_in_y(i,1,k) * Mat_tr(1,j) &
             + vec_in_y(i,2,k) * Mat_tr(2,j) &
             + vec_in_y(i,3,k) * Mat_tr(3,j) &
             + vec_in_y(i,4,k) * Mat_tr(4,j) 
        tmp2 = vec_in_y(i,5,k) * Mat_tr(5,j) &
             + vec_in_y(i,6,k) * Mat_tr(6,j) &
             + vec_in_y(i,7,k) * Mat_tr(7,j) &
             + vec_in_y(i,8,k) * Mat_tr(8,j) 
        tmp3 = vec_in_y(i,9,k) * Mat_tr(9,j) &
             + vec_in_y(i,10,k) * Mat_tr(10,j) &
             + vec_in_y(i,11,k) * Mat_tr(11,j) 
      vec_out_y(i,jk) = tmp1 + tmp2 + tmp3
      end do
    end do
    end do
    
    ! Z-dir
    do k=1, 11
    do j=1, 11
      jk = j + (k-1)*11
      do i=1, 11
        tmp1 = vec_in_z(i,j,1) * Mat_tr(1,k) &
             + vec_in_z(i,j,2) * Mat_tr(2,k) &
             + vec_in_z(i,j,3) * Mat_tr(3,k) &
             + vec_in_z(i,j,4) * Mat_tr(4,k) 
        tmp2 = vec_in_z(i,j,5) * Mat_tr(5,k) &
             + vec_in_z(i,j,6) * Mat_tr(6,k) &
             + vec_in_z(i,j,7) * Mat_tr(7,k) &
             + vec_in_z(i,j,8) * Mat_tr(8,k) 
        tmp3 = vec_in_z(i,j,9) * Mat_tr(9,k) &
             + vec_in_z(i,j,10) * Mat_tr(10,k) &
             + vec_in_z(i,j,11) * Mat_tr(11,k) 
      vec_out_z(i,jk) = tmp1 + tmp2 + tmp3
      end do
    end do
    end do
    return
  end subroutine element_operation_kernel_matvec_divlike_dirXYZ_P10

!OCL SERIAL
  subroutine element_operation_kernel_matvec_divlike_dirXYZ_var5_P10( &
    Mat, Mat_tr, vec_in_x, vec_in_y, vec_in_z, &
    vec_out_x, vec_out_y, vec_out_z  )
    implicit none
    real(RP), intent(in) :: Mat(11,11)
    real(RP), intent(in) :: Mat_tr(11,11)
    real(RP), intent(in) :: vec_in_x(11,11**2*5)
    real(RP), intent(in) :: vec_in_y(11,11,11*5)
    real(RP), intent(in) :: vec_in_z(11,11,11,5)
    real(RP), intent(out) :: vec_out_x(11,11**2*5)
    real(RP), intent(out) :: vec_out_y(11,11**2*5)
    real(RP), intent(out) :: vec_out_z(11,11**2,5)

    integer :: i, j, k, jkv, jk, v, kv
    real(RP) :: tmp1, tmp2, tmp3
    !----------------------------------------------------------

    ! X-dir

    do jkv=1, 11**2*5
    do i=1, 11
      tmp1 = Mat(i,1) * vec_in_x(1,jkv) &
           + Mat(i,2) * vec_in_x(2,jkv) &
           + Mat(i,3) * vec_in_x(3,jkv) &
           + Mat(i,4) * vec_in_x(4,jkv)
      tmp2 = Mat(i,5) * vec_in_x(5,jkv) &
           + Mat(i,6) * vec_in_x(6,jkv) &
           + Mat(i,7) * vec_in_x(7,jkv) &
           + Mat(i,8) * vec_in_x(8,jkv)
      tmp3 = Mat(i,9) * vec_in_x(9,jkv) &
           + Mat(i,10) * vec_in_x(10,jkv) &
           + Mat(i,11) * vec_in_x(11,jkv)
      vec_out_x(i,jkv) = tmp1 + tmp2 + tmp3
    end do
    end do

    ! Y-dir
    do kv=1, 11*5
    do j=1, 11
      jkv = j + (kv-1)*55
      do i=1, 11
        tmp1 = vec_in_y(i,1,kv) * Mat_tr(1,j) &
             + vec_in_y(i,2,kv) * Mat_tr(2,j) &
             + vec_in_y(i,3,kv) * Mat_tr(3,j) &
             + vec_in_y(i,4,kv) * Mat_tr(4,j) 
        tmp2 = vec_in_y(i,5,kv) * Mat_tr(5,j) &
             + vec_in_y(i,6,kv) * Mat_tr(6,j) &
             + vec_in_y(i,7,kv) * Mat_tr(7,j) &
             + vec_in_y(i,8,kv) * Mat_tr(8,j) 
        tmp3 = vec_in_y(i,9,kv) * Mat_tr(9,j) &
             + vec_in_y(i,10,kv) * Mat_tr(10,j) &
             + vec_in_y(i,11,kv) * Mat_tr(11,j) 
      vec_out_y(i,jkv) = tmp1 + tmp2 + tmp3
      end do
    end do
    end do
    
    ! Z-dir
    do v=1, 5
    do k=1, 11
    do j=1, 11
      jk = j + (k-1)*11
      do i=1, 11
        tmp1 = vec_in_z(i,j,1,v) * Mat_tr(1,k) &
             + vec_in_z(i,j,2,v) * Mat_tr(2,k) &
             + vec_in_z(i,j,3,v) * Mat_tr(3,k) &
             + vec_in_z(i,j,4,v) * Mat_tr(4,k) 
        tmp2 = vec_in_z(i,j,5,v) * Mat_tr(5,k) &
             + vec_in_z(i,j,6,v) * Mat_tr(6,k) &
             + vec_in_z(i,j,7,v) * Mat_tr(7,k) &
             + vec_in_z(i,j,8,v) * Mat_tr(8,k) 
        tmp3 = vec_in_z(i,j,9,v) * Mat_tr(9,k) &
             + vec_in_z(i,j,10,v) * Mat_tr(10,k) &
             + vec_in_z(i,j,11,v) * Mat_tr(11,k) 
      vec_out_z(i,jk,v) = tmp1 + tmp2 + tmp3
      end do
    end do
    end do
    end do
    return
  end subroutine element_operation_kernel_matvec_divlike_dirXYZ_var5_P10

!> Calculate a matrix-vector multiplication associated with 3D modal filtering with p=10
!!
!OCL SERIAL
  subroutine element_operation_kernel_matvec_ModalFilter_P10( Mat_h1D, Mat_h1D_tr, Mat_v1D_tr, vec_in, vec_work, &
    vec_out  )
    implicit none
    real(RP), intent(in) :: Mat_h1D(11,11)
    real(RP), intent(in) :: Mat_h1D_tr(11,11)
    real(RP), intent(in) :: Mat_v1D_tr(11,11)
    real(RP), intent(in) :: vec_in(11,11,11)
    real(RP), intent(out) :: vec_work(11,11,11)
    real(RP), intent(out) :: vec_out(11,11,11)

    integer :: i, j, k
    real(RP) :: tmp1, tmp2, tmp3
    !----------------------------------------------------------

    ! X-dir

    do k=1, 11
    do j=1, 11
    do i=1, 11
      tmp1 = Mat_h1D(i,1) * vec_in(1,j,k) &
           + Mat_h1D(i,2) * vec_in(2,j,k) &
           + Mat_h1D(i,3) * vec_in(3,j,k) &
           + Mat_h1D(i,4) * vec_in(4,j,k)
      tmp2 = Mat_h1D(i,5) * vec_in(5,j,k) &
           + Mat_h1D(i,6) * vec_in(6,j,k) &
           + Mat_h1D(i,7) * vec_in(7,j,k) &
           + Mat_h1D(i,8) * vec_in(8,j,k)
      tmp3 = Mat_h1D(i,9) * vec_in(9,j,k) &
           + Mat_h1D(i,10) * vec_in(10,j,k) &
           + Mat_h1D(i,11) * vec_in(11,j,k)
      vec_out(i,j,k) = tmp1 + tmp2 + tmp3
    end do
    end do
    end do
    
    ! Y-dir
    do k=1, 11
    do j=1, 11
    do i=1, 11
      tmp1 = vec_out(i,1,k) * Mat_h1D_tr(1,j) &
           + vec_out(i,2,k) * Mat_h1D_tr(2,j) &
           + vec_out(i,3,k) * Mat_h1D_tr(3,j) &
           + vec_out(i,4,k) * Mat_h1D_tr(4,j) 
      tmp2 = vec_out(i,5,k) * Mat_h1D_tr(5,j) &
           + vec_out(i,6,k) * Mat_h1D_tr(6,j) &
           + vec_out(i,7,k) * Mat_h1D_tr(7,j) &
           + vec_out(i,8,k) * Mat_h1D_tr(8,j) 
      tmp3 = vec_out(i,9,k) * Mat_h1D_tr(9,j) &
           + vec_out(i,10,k) * Mat_h1D_tr(10,j) &
           + vec_out(i,11,k) * Mat_h1D_tr(11,j) 
      vec_work(i,j,k) = tmp1 + tmp2 + tmp3
    end do
    end do
    end do
    
    ! Z-dir
    do k=1, 11
    do j=1, 11
    do i=1, 11
      tmp1 = vec_work(i,j,1) * Mat_v1D_tr(1,k) &
           + vec_work(i,j,2) * Mat_v1D_tr(2,k) &
           + vec_work(i,j,3) * Mat_v1D_tr(3,k) &
           + vec_work(i,j,4) * Mat_v1D_tr(4,k) 
      tmp2 = vec_work(i,j,5) * Mat_v1D_tr(5,k) &
           + vec_work(i,j,6) * Mat_v1D_tr(6,k) &
           + vec_work(i,j,7) * Mat_v1D_tr(7,k) &
           + vec_work(i,j,8) * Mat_v1D_tr(8,k) 
      tmp3 = vec_work(i,j,9) * Mat_v1D_tr(9,k) &
           + vec_work(i,j,10) * Mat_v1D_tr(10,k) &
           + vec_work(i,j,11) * Mat_v1D_tr(11,k) 
      vec_out(i,j,k) = tmp1 + tmp2 + tmp3
    end do
    end do
    end do

    return
  end subroutine element_operation_kernel_matvec_ModalFilter_P10

!--- For p=11 ------------------------------------

!> Calculate a matrix-vector multiplication associated with mathematical operations in the x direction (first dimension of vec_in) with p=11
!!
!OCL SERIAL
  subroutine element_operation_kernel_matvec_dirX_P11( Mat_x, vec_in, vec_out )
    implicit none
    real(RP), intent(in) :: Mat_x(12,12)
    real(RP), intent(in) :: vec_in(12,12**2)
    real(RP), intent(out) :: vec_out(12,12**2)

    integer :: i, jk
    !----------------------------------------------------------

    do jk=1, 12**2
    do i=1, 12
        vec_out(i,jk) = Mat_x(i,1) * vec_in(1,jk) &
                      + Mat_x(i,2) * vec_in(2,jk) &
                      + Mat_x(i,3) * vec_in(3,jk) &
                      + Mat_x(i,4) * vec_in(4,jk) &
                      + Mat_x(i,5) * vec_in(5,jk) &
                      + Mat_x(i,6) * vec_in(6,jk) &
                      + Mat_x(i,7) * vec_in(7,jk) &
                      + Mat_x(i,8) * vec_in(8,jk) &
                      + Mat_x(i,9) * vec_in(9,jk) &
                      + Mat_x(i,10) * vec_in(10,jk) &
                      + Mat_x(i,11) * vec_in(11,jk) &
                      + Mat_x(i,12) * vec_in(12,jk)
    end do
    end do

    return
  end subroutine element_operation_kernel_matvec_dirX_P11

!> Calculate a matrix-vector multiplication associated with mathematical operations in the y direction (second dimension of vec_in) with p=11
!! For a matrix-vector multiplication (vec_out = Mat_y vec_in), the passed variable of Mat_y should be transposed.
!!
!OCL SERIAL
  subroutine element_operation_kernel_matvec_dirY_P11( Mat_y_tr, vec_in, vec_out )
    implicit none
    real(RP), intent(in) :: Mat_y_tr(12,12)
    real(RP), intent(in) :: vec_in(12,12,12)
    real(RP), intent(out) :: vec_out(12,12,12)

    integer :: i, j, k
    !----------------------------------------------------------

    do k=1, 12
    do j=1, 12
    do i=1, 12
        vec_out(i,j,k) = vec_in(i,1,k) * Mat_y_tr(1,j) &
                       + vec_in(i,2,k) * Mat_y_tr(2,j) &
                       + vec_in(i,3,k) * Mat_y_tr(3,j) &
                       + vec_in(i,4,k) * Mat_y_tr(4,j) &
                       + vec_in(i,5,k) * Mat_y_tr(5,j) &
                       + vec_in(i,6,k) * Mat_y_tr(6,j) &
                       + vec_in(i,7,k) * Mat_y_tr(7,j) &
                       + vec_in(i,8,k) * Mat_y_tr(8,j) &
                       + vec_in(i,9,k) * Mat_y_tr(9,j) &
                       + vec_in(i,10,k) * Mat_y_tr(10,j) &
                       + vec_in(i,11,k) * Mat_y_tr(11,j) &
                       + vec_in(i,12,k) * Mat_y_tr(12,j) 
    end do
    end do
    end do

    return
  end subroutine element_operation_kernel_matvec_dirY_P11

!> Calculate a matrix-vector multiplication associated with mathematical operations in the z direction (third dimension of vec_in) with p=11
!! For a matrix-vector multiplication (vec_out = Mat_z vec_in), the passed variable of Mat_z should be transposed.
!!
!OCL SERIAL
  subroutine element_operation_kernel_matvec_dirZ_P11( Mat_z_tr, vec_in, vec_out )
    implicit none
    real(RP), intent(in) :: Mat_z_tr(12,12)
    real(RP), intent(in) :: vec_in(12,12,12)
    real(RP), intent(out) :: vec_out(12,12,12)

    integer :: i, j, k
    !----------------------------------------------------------

    do k=1, 12
    do j=1, 12
    do i=1, 12
        vec_out(i,j,k) = vec_in(i,j,1) * Mat_z_tr(1,k) &
                       + vec_in(i,j,2) * Mat_z_tr(2,k) &
                       + vec_in(i,j,3) * Mat_z_tr(3,k) &
                       + vec_in(i,j,4) * Mat_z_tr(4,k) &
                       + vec_in(i,j,5) * Mat_z_tr(5,k) &
                       + vec_in(i,j,6) * Mat_z_tr(6,k) &
                       + vec_in(i,j,7) * Mat_z_tr(7,k) &
                       + vec_in(i,j,8) * Mat_z_tr(8,k) &
                       + vec_in(i,j,9) * Mat_z_tr(9,k) &
                       + vec_in(i,j,10) * Mat_z_tr(10,k) &
                       + vec_in(i,j,11) * Mat_z_tr(11,k) &
                       + vec_in(i,j,12) * Mat_z_tr(12,k) 
    end do
    end do
    end do

    return
  end subroutine element_operation_kernel_matvec_dirZ_P11

!> Calculate a matrix-vector multiplication with lifting operations for a hexahedral element of order p=11
!!
!OCL SERIAL
  subroutine element_operation_kernel_matvec_Lift_hexahedral_P11( Lift, vec_in, vec_out )
    implicit none
    real(RP), intent(in) :: Lift(12,12,12,6)
    real(RP), intent(in) :: vec_in(12,12,6)
    real(RP), intent(out) :: vec_out(12,12,12)

    integer :: i, j, k
    !----------------------------------------------------------

    do k=1, 12
    do j=1, 12
    do i=1, 12
        vec_out(i,j,k) = Lift(i,j,k,1) * vec_in(i,k,1) &
                       + Lift(i,j,k,2) * vec_in(j,k,2) &
                       + Lift(i,j,k,3) * vec_in(i,k,3) &
                       + Lift(i,j,k,4) * vec_in(j,k,4) &
                       + Lift(i,j,k,5) * vec_in(i,j,5) &
                       + Lift(i,j,k,6) * vec_in(i,j,6)
    end do
    end do
    end do

    return
  end subroutine element_operation_kernel_matvec_Lift_hexahedral_P11
  
!> Calculate a matrix-vector multiplication associated with mathematical operations in the x, y, and z direction (third dimension of vec_in) with p=11
!! For a matrix-vector multiplication (vec_d_out = Mat_d vec_in where d=x,y,z), the passed variables of Mat_y and Mat_z should be transposed.
!! Note that we assume that vec_in_ has same data as vec_in, but are reshaped via the call of this subroutine. 
!!
!OCL SERIAL
  subroutine element_operation_kernel_matvec_gradlike_dirXYZ_P11( Mat, Mat_tr, vec_in, vec_in_, &
    vec_out_x, vec_out_y, vec_out_z  )
    implicit none
    real(RP), intent(in) :: Mat(12,12)
    real(RP), intent(in) :: Mat_tr(12,12)
    real(RP), intent(in) :: vec_in_(12,12**2)
    real(RP), intent(in) :: vec_in(12,12,12)
    real(RP), intent(out) :: vec_out_x(12,12**2)
    real(RP), intent(out) :: vec_out_y(12,12,12)
    real(RP), intent(out) :: vec_out_z(12,12,12)

    integer :: i, j, k, jk
    !----------------------------------------------------------

    ! X-dir

    do jk=1, 12**2
    do i=1, 12
        vec_out_x(i,jk) = Mat(i,1) * vec_in_(1,jk) &
                        + Mat(i,2) * vec_in_(2,jk) &
                        + Mat(i,3) * vec_in_(3,jk) &
                        + Mat(i,4) * vec_in_(4,jk) &
                        + Mat(i,5) * vec_in_(5,jk) &
                        + Mat(i,6) * vec_in_(6,jk) &
                        + Mat(i,7) * vec_in_(7,jk) &
                        + Mat(i,8) * vec_in_(8,jk) &
                        + Mat(i,9) * vec_in_(9,jk) &
                        + Mat(i,10) * vec_in_(10,jk) &
                        + Mat(i,11) * vec_in_(11,jk) &
                        + Mat(i,12) * vec_in_(12,jk)
    end do
    end do

    ! Y-dir
    do k=1, 12
    do j=1, 12
    do i=1, 12
        vec_out_y(i,j,k) = vec_in(i,1,k) * Mat_tr(1,j) &
                         + vec_in(i,2,k) * Mat_tr(2,j) &
                         + vec_in(i,3,k) * Mat_tr(3,j) &
                         + vec_in(i,4,k) * Mat_tr(4,j) &
                         + vec_in(i,5,k) * Mat_tr(5,j) &
                         + vec_in(i,6,k) * Mat_tr(6,j) &
                         + vec_in(i,7,k) * Mat_tr(7,j) &
                         + vec_in(i,8,k) * Mat_tr(8,j) &
                         + vec_in(i,9,k) * Mat_tr(9,j) &
                         + vec_in(i,10,k) * Mat_tr(10,j) &
                         + vec_in(i,11,k) * Mat_tr(11,j) &
                         + vec_in(i,12,k) * Mat_tr(12,j) 
    end do
    end do
    end do
    
    ! Z-dir
    do k=1, 12
    do j=1, 12
    do i=1, 12
        vec_out_z(i,j,k) = vec_in(i,1,k) * Mat_tr(1,j) &
                         + vec_in(i,j,2) * Mat_tr(2,k) &
                         + vec_in(i,j,3) * Mat_tr(3,k) &
                         + vec_in(i,j,4) * Mat_tr(4,k) &
                         + vec_in(i,j,5) * Mat_tr(5,k) &
                         + vec_in(i,j,6) * Mat_tr(6,k) &
                         + vec_in(i,j,7) * Mat_tr(7,k) &
                         + vec_in(i,j,8) * Mat_tr(8,k) &
                         + vec_in(i,j,9) * Mat_tr(9,k) &
                         + vec_in(i,j,10) * Mat_tr(10,k) &
                         + vec_in(i,j,11) * Mat_tr(11,k) &
                         + vec_in(i,j,12) * Mat_tr(12,k) 
    end do
    end do
    end do

    return
  end subroutine element_operation_kernel_matvec_gradlike_dirXYZ_P11

!> Calculate a matrix-vector multiplication associated with mathematical operations in the x, y, and z direction (third dimension of vec_in) with p=11
!! For a matrix-vector multiplication (vec_d_out = Mat_d vec_d_in where d=x,y,z), the passed variables of Mat_y and Mat_z should be transposed.
!! Note that we assume that vec_in_ has same data as vec_in, but are reshaped via the call of this subroutine. 
!!
!OCL SERIAL
  subroutine element_operation_kernel_matvec_divlike_dirXYZ_P11( &
    Mat, Mat_tr, vec_in_x, vec_in_y, vec_in_z, &
    vec_out_x, vec_out_y, vec_out_z  )
    implicit none
    real(RP), intent(in) :: Mat(12,12)
    real(RP), intent(in) :: Mat_tr(12,12)
    real(RP), intent(in) :: vec_in_x(12,12**2)
    real(RP), intent(in) :: vec_in_y(12,12,12)
    real(RP), intent(in) :: vec_in_z(12,12,12)
    real(RP), intent(out) :: vec_out_x(12,12**2)
    real(RP), intent(out) :: vec_out_y(12,12**2)
    real(RP), intent(out) :: vec_out_z(12,12**2)

    integer :: i, j, k, jk
    real(RP) :: tmp1, tmp2, tmp3
    !----------------------------------------------------------

    ! X-dir

    do jk=1, 12**2
    do i=1, 12
      tmp1 = Mat(i,1) * vec_in_x(1,jk) &
           + Mat(i,2) * vec_in_x(2,jk) &
           + Mat(i,3) * vec_in_x(3,jk) &
           + Mat(i,4) * vec_in_x(4,jk)
      tmp2 = Mat(i,5) * vec_in_x(5,jk) &
           + Mat(i,6) * vec_in_x(6,jk) &
           + Mat(i,7) * vec_in_x(7,jk) &
           + Mat(i,8) * vec_in_x(8,jk)
      tmp3 = Mat(i,9) * vec_in_x(9,jk) &
           + Mat(i,10) * vec_in_x(10,jk) &
           + Mat(i,11) * vec_in_x(11,jk) &
           + Mat(i,12) * vec_in_x(12,jk)
      vec_out_x(i,jk) = tmp1 + tmp2 + tmp3
    end do
    end do

    ! Y-dir
    do k=1, 12
    do j=1, 12
      jk = j + (k-1)*12
      do i=1, 12
        tmp1 = vec_in_y(i,1,k) * Mat_tr(1,j) &
             + vec_in_y(i,2,k) * Mat_tr(2,j) &
             + vec_in_y(i,3,k) * Mat_tr(3,j) &
             + vec_in_y(i,4,k) * Mat_tr(4,j) 
        tmp2 = vec_in_y(i,5,k) * Mat_tr(5,j) &
             + vec_in_y(i,6,k) * Mat_tr(6,j) &
             + vec_in_y(i,7,k) * Mat_tr(7,j) &
             + vec_in_y(i,8,k) * Mat_tr(8,j) 
        tmp3 = vec_in_y(i,9,k) * Mat_tr(9,j) &
             + vec_in_y(i,10,k) * Mat_tr(10,j) &
             + vec_in_y(i,11,k) * Mat_tr(11,j) &
             + vec_in_y(i,12,k) * Mat_tr(12,j) 
      vec_out_y(i,jk) = tmp1 + tmp2 + tmp3
      end do
    end do
    end do
    
    ! Z-dir
    do k=1, 12
    do j=1, 12
      jk = j + (k-1)*12
      do i=1, 12
        tmp1 = vec_in_z(i,j,1) * Mat_tr(1,k) &
             + vec_in_z(i,j,2) * Mat_tr(2,k) &
             + vec_in_z(i,j,3) * Mat_tr(3,k) &
             + vec_in_z(i,j,4) * Mat_tr(4,k) 
        tmp2 = vec_in_z(i,j,5) * Mat_tr(5,k) &
             + vec_in_z(i,j,6) * Mat_tr(6,k) &
             + vec_in_z(i,j,7) * Mat_tr(7,k) &
             + vec_in_z(i,j,8) * Mat_tr(8,k) 
        tmp3 = vec_in_z(i,j,9) * Mat_tr(9,k) &
             + vec_in_z(i,j,10) * Mat_tr(10,k) &
             + vec_in_z(i,j,11) * Mat_tr(11,k) &
             + vec_in_z(i,j,12) * Mat_tr(12,k) 
      vec_out_z(i,jk) = tmp1 + tmp2 + tmp3
      end do
    end do
    end do
    return
  end subroutine element_operation_kernel_matvec_divlike_dirXYZ_P11

!OCL SERIAL
  subroutine element_operation_kernel_matvec_divlike_dirXYZ_var5_P11( &
    Mat, Mat_tr, vec_in_x, vec_in_y, vec_in_z, &
    vec_out_x, vec_out_y, vec_out_z  )
    implicit none
    real(RP), intent(in) :: Mat(12,12)
    real(RP), intent(in) :: Mat_tr(12,12)
    real(RP), intent(in) :: vec_in_x(12,12**2*5)
    real(RP), intent(in) :: vec_in_y(12,12,12*5)
    real(RP), intent(in) :: vec_in_z(12,12,12,5)
    real(RP), intent(out) :: vec_out_x(12,12**2*5)
    real(RP), intent(out) :: vec_out_y(12,12**2*5)
    real(RP), intent(out) :: vec_out_z(12,12**2,5)

    integer :: i, j, k, jkv, jk, v, kv
    real(RP) :: tmp1, tmp2, tmp3
    !----------------------------------------------------------

    ! X-dir

    do jkv=1, 12**2*5
    do i=1, 12
      tmp1 = Mat(i,1) * vec_in_x(1,jkv) &
           + Mat(i,2) * vec_in_x(2,jkv) &
           + Mat(i,3) * vec_in_x(3,jkv) &
           + Mat(i,4) * vec_in_x(4,jkv)
      tmp2 = Mat(i,5) * vec_in_x(5,jkv) &
           + Mat(i,6) * vec_in_x(6,jkv) &
           + Mat(i,7) * vec_in_x(7,jkv) &
           + Mat(i,8) * vec_in_x(8,jkv)
      tmp3 = Mat(i,9) * vec_in_x(9,jkv) &
           + Mat(i,10) * vec_in_x(10,jkv) &
           + Mat(i,11) * vec_in_x(11,jkv) &
           + Mat(i,12) * vec_in_x(12,jkv)
      vec_out_x(i,jkv) = tmp1 + tmp2 + tmp3
    end do
    end do

    ! Y-dir
    do kv=1, 12*5
    do j=1, 12
      jkv = j + (kv-1)*60
      do i=1, 12
        tmp1 = vec_in_y(i,1,kv) * Mat_tr(1,j) &
             + vec_in_y(i,2,kv) * Mat_tr(2,j) &
             + vec_in_y(i,3,kv) * Mat_tr(3,j) &
             + vec_in_y(i,4,kv) * Mat_tr(4,j) 
        tmp2 = vec_in_y(i,5,kv) * Mat_tr(5,j) &
             + vec_in_y(i,6,kv) * Mat_tr(6,j) &
             + vec_in_y(i,7,kv) * Mat_tr(7,j) &
             + vec_in_y(i,8,kv) * Mat_tr(8,j) 
        tmp3 = vec_in_y(i,9,kv) * Mat_tr(9,j) &
             + vec_in_y(i,10,kv) * Mat_tr(10,j) &
             + vec_in_y(i,11,kv) * Mat_tr(11,j) &
             + vec_in_y(i,12,kv) * Mat_tr(12,j) 
      vec_out_y(i,jkv) = tmp1 + tmp2 + tmp3
      end do
    end do
    end do
    
    ! Z-dir
    do v=1, 5
    do k=1, 12
    do j=1, 12
      jk = j + (k-1)*12
      do i=1, 12
        tmp1 = vec_in_z(i,j,1,v) * Mat_tr(1,k) &
             + vec_in_z(i,j,2,v) * Mat_tr(2,k) &
             + vec_in_z(i,j,3,v) * Mat_tr(3,k) &
             + vec_in_z(i,j,4,v) * Mat_tr(4,k) 
        tmp2 = vec_in_z(i,j,5,v) * Mat_tr(5,k) &
             + vec_in_z(i,j,6,v) * Mat_tr(6,k) &
             + vec_in_z(i,j,7,v) * Mat_tr(7,k) &
             + vec_in_z(i,j,8,v) * Mat_tr(8,k) 
        tmp3 = vec_in_z(i,j,9,v) * Mat_tr(9,k) &
             + vec_in_z(i,j,10,v) * Mat_tr(10,k) &
             + vec_in_z(i,j,11,v) * Mat_tr(11,k) &
             + vec_in_z(i,j,12,v) * Mat_tr(12,k) 
      vec_out_z(i,jk,v) = tmp1 + tmp2 + tmp3
      end do
    end do
    end do
    end do
    return
  end subroutine element_operation_kernel_matvec_divlike_dirXYZ_var5_P11

!> Calculate a matrix-vector multiplication associated with 3D modal filtering with p=11
!!
!OCL SERIAL
  subroutine element_operation_kernel_matvec_ModalFilter_P11( Mat_h1D, Mat_h1D_tr, Mat_v1D_tr, vec_in, vec_work, &
    vec_out  )
    implicit none
    real(RP), intent(in) :: Mat_h1D(12,12)
    real(RP), intent(in) :: Mat_h1D_tr(12,12)
    real(RP), intent(in) :: Mat_v1D_tr(12,12)
    real(RP), intent(in) :: vec_in(12,12,12)
    real(RP), intent(out) :: vec_work(12,12,12)
    real(RP), intent(out) :: vec_out(12,12,12)

    integer :: i, j, k
    real(RP) :: tmp1, tmp2, tmp3
    !----------------------------------------------------------

    ! X-dir

    do k=1, 12
    do j=1, 12
    do i=1, 12
      tmp1 = Mat_h1D(i,1) * vec_in(1,j,k) &
           + Mat_h1D(i,2) * vec_in(2,j,k) &
           + Mat_h1D(i,3) * vec_in(3,j,k) &
           + Mat_h1D(i,4) * vec_in(4,j,k)
      tmp2 = Mat_h1D(i,5) * vec_in(5,j,k) &
           + Mat_h1D(i,6) * vec_in(6,j,k) &
           + Mat_h1D(i,7) * vec_in(7,j,k) &
           + Mat_h1D(i,8) * vec_in(8,j,k)
      tmp3 = Mat_h1D(i,9) * vec_in(9,j,k) &
           + Mat_h1D(i,10) * vec_in(10,j,k) &
           + Mat_h1D(i,11) * vec_in(11,j,k) &
           + Mat_h1D(i,12) * vec_in(12,j,k)
      vec_out(i,j,k) = tmp1 + tmp2 + tmp3
    end do
    end do
    end do
    
    ! Y-dir
    do k=1, 12
    do j=1, 12
    do i=1, 12
      tmp1 = vec_out(i,1,k) * Mat_h1D_tr(1,j) &
           + vec_out(i,2,k) * Mat_h1D_tr(2,j) &
           + vec_out(i,3,k) * Mat_h1D_tr(3,j) &
           + vec_out(i,4,k) * Mat_h1D_tr(4,j) 
      tmp2 = vec_out(i,5,k) * Mat_h1D_tr(5,j) &
           + vec_out(i,6,k) * Mat_h1D_tr(6,j) &
           + vec_out(i,7,k) * Mat_h1D_tr(7,j) &
           + vec_out(i,8,k) * Mat_h1D_tr(8,j) 
      tmp3 = vec_out(i,9,k) * Mat_h1D_tr(9,j) &
           + vec_out(i,10,k) * Mat_h1D_tr(10,j) &
           + vec_out(i,11,k) * Mat_h1D_tr(11,j) &
           + vec_out(i,12,k) * Mat_h1D_tr(12,j) 
      vec_work(i,j,k) = tmp1 + tmp2 + tmp3
    end do
    end do
    end do
    
    ! Z-dir
    do k=1, 12
    do j=1, 12
    do i=1, 12
      tmp1 = vec_work(i,j,1) * Mat_v1D_tr(1,k) &
           + vec_work(i,j,2) * Mat_v1D_tr(2,k) &
           + vec_work(i,j,3) * Mat_v1D_tr(3,k) &
           + vec_work(i,j,4) * Mat_v1D_tr(4,k) 
      tmp2 = vec_work(i,j,5) * Mat_v1D_tr(5,k) &
           + vec_work(i,j,6) * Mat_v1D_tr(6,k) &
           + vec_work(i,j,7) * Mat_v1D_tr(7,k) &
           + vec_work(i,j,8) * Mat_v1D_tr(8,k) 
      tmp3 = vec_work(i,j,9) * Mat_v1D_tr(9,k) &
           + vec_work(i,j,10) * Mat_v1D_tr(10,k) &
           + vec_work(i,j,11) * Mat_v1D_tr(11,k) &
           + vec_work(i,j,12) * Mat_v1D_tr(12,k) 
      vec_out(i,j,k) = tmp1 + tmp2 + tmp3
    end do
    end do
    end do

    return
  end subroutine element_operation_kernel_matvec_ModalFilter_P11

!--- For p=12 ------------------------------------

!> Calculate a matrix-vector multiplication associated with mathematical operations in the x direction (first dimension of vec_in) with p=12
!!
!OCL SERIAL
  subroutine element_operation_kernel_matvec_dirX_P12( Mat_x, vec_in, vec_out )
    implicit none
    real(RP), intent(in) :: Mat_x(13,13)
    real(RP), intent(in) :: vec_in(13,13**2)
    real(RP), intent(out) :: vec_out(13,13**2)

    integer :: i, jk
    !----------------------------------------------------------

    do jk=1, 13**2
    do i=1, 13
        vec_out(i,jk) = Mat_x(i,1) * vec_in(1,jk) &
                      + Mat_x(i,2) * vec_in(2,jk) &
                      + Mat_x(i,3) * vec_in(3,jk) &
                      + Mat_x(i,4) * vec_in(4,jk) &
                      + Mat_x(i,5) * vec_in(5,jk) &
                      + Mat_x(i,6) * vec_in(6,jk) &
                      + Mat_x(i,7) * vec_in(7,jk) &
                      + Mat_x(i,8) * vec_in(8,jk) &
                      + Mat_x(i,9) * vec_in(9,jk) &
                      + Mat_x(i,10) * vec_in(10,jk) &
                      + Mat_x(i,11) * vec_in(11,jk) &
                      + Mat_x(i,12) * vec_in(12,jk) &
                      + Mat_x(i,13) * vec_in(13,jk)
    end do
    end do

    return
  end subroutine element_operation_kernel_matvec_dirX_P12

!> Calculate a matrix-vector multiplication associated with mathematical operations in the y direction (second dimension of vec_in) with p=12
!! For a matrix-vector multiplication (vec_out = Mat_y vec_in), the passed variable of Mat_y should be transposed.
!!
!OCL SERIAL
  subroutine element_operation_kernel_matvec_dirY_P12( Mat_y_tr, vec_in, vec_out )
    implicit none
    real(RP), intent(in) :: Mat_y_tr(13,13)
    real(RP), intent(in) :: vec_in(13,13,13)
    real(RP), intent(out) :: vec_out(13,13,13)

    integer :: i, j, k
    !----------------------------------------------------------

    do k=1, 13
    do j=1, 13
    do i=1, 13
        vec_out(i,j,k) = vec_in(i,1,k) * Mat_y_tr(1,j) &
                       + vec_in(i,2,k) * Mat_y_tr(2,j) &
                       + vec_in(i,3,k) * Mat_y_tr(3,j) &
                       + vec_in(i,4,k) * Mat_y_tr(4,j) &
                       + vec_in(i,5,k) * Mat_y_tr(5,j) &
                       + vec_in(i,6,k) * Mat_y_tr(6,j) &
                       + vec_in(i,7,k) * Mat_y_tr(7,j) &
                       + vec_in(i,8,k) * Mat_y_tr(8,j) &
                       + vec_in(i,9,k) * Mat_y_tr(9,j) &
                       + vec_in(i,10,k) * Mat_y_tr(10,j) &
                       + vec_in(i,11,k) * Mat_y_tr(11,j) &
                       + vec_in(i,12,k) * Mat_y_tr(12,j) &
                       + vec_in(i,13,k) * Mat_y_tr(13,j) 
    end do
    end do
    end do

    return
  end subroutine element_operation_kernel_matvec_dirY_P12

!> Calculate a matrix-vector multiplication associated with mathematical operations in the z direction (third dimension of vec_in) with p=12
!! For a matrix-vector multiplication (vec_out = Mat_z vec_in), the passed variable of Mat_z should be transposed.
!!
!OCL SERIAL
  subroutine element_operation_kernel_matvec_dirZ_P12( Mat_z_tr, vec_in, vec_out )
    implicit none
    real(RP), intent(in) :: Mat_z_tr(13,13)
    real(RP), intent(in) :: vec_in(13,13,13)
    real(RP), intent(out) :: vec_out(13,13,13)

    integer :: i, j, k
    !----------------------------------------------------------

    do k=1, 13
    do j=1, 13
    do i=1, 13
        vec_out(i,j,k) = vec_in(i,j,1) * Mat_z_tr(1,k) &
                       + vec_in(i,j,2) * Mat_z_tr(2,k) &
                       + vec_in(i,j,3) * Mat_z_tr(3,k) &
                       + vec_in(i,j,4) * Mat_z_tr(4,k) &
                       + vec_in(i,j,5) * Mat_z_tr(5,k) &
                       + vec_in(i,j,6) * Mat_z_tr(6,k) &
                       + vec_in(i,j,7) * Mat_z_tr(7,k) &
                       + vec_in(i,j,8) * Mat_z_tr(8,k) &
                       + vec_in(i,j,9) * Mat_z_tr(9,k) &
                       + vec_in(i,j,10) * Mat_z_tr(10,k) &
                       + vec_in(i,j,11) * Mat_z_tr(11,k) &
                       + vec_in(i,j,12) * Mat_z_tr(12,k) &
                       + vec_in(i,j,13) * Mat_z_tr(13,k) 
    end do
    end do
    end do

    return
  end subroutine element_operation_kernel_matvec_dirZ_P12

!> Calculate a matrix-vector multiplication with lifting operations for a hexahedral element of order p=12
!!
!OCL SERIAL
  subroutine element_operation_kernel_matvec_Lift_hexahedral_P12( Lift, vec_in, vec_out )
    implicit none
    real(RP), intent(in) :: Lift(13,13,13,6)
    real(RP), intent(in) :: vec_in(13,13,6)
    real(RP), intent(out) :: vec_out(13,13,13)

    integer :: i, j, k
    !----------------------------------------------------------

    do k=1, 13
    do j=1, 13
    do i=1, 13
        vec_out(i,j,k) = Lift(i,j,k,1) * vec_in(i,k,1) &
                       + Lift(i,j,k,2) * vec_in(j,k,2) &
                       + Lift(i,j,k,3) * vec_in(i,k,3) &
                       + Lift(i,j,k,4) * vec_in(j,k,4) &
                       + Lift(i,j,k,5) * vec_in(i,j,5) &
                       + Lift(i,j,k,6) * vec_in(i,j,6)
    end do
    end do
    end do

    return
  end subroutine element_operation_kernel_matvec_Lift_hexahedral_P12
  
!> Calculate a matrix-vector multiplication associated with mathematical operations in the x, y, and z direction (third dimension of vec_in) with p=12
!! For a matrix-vector multiplication (vec_d_out = Mat_d vec_in where d=x,y,z), the passed variables of Mat_y and Mat_z should be transposed.
!! Note that we assume that vec_in_ has same data as vec_in, but are reshaped via the call of this subroutine. 
!!
!OCL SERIAL
  subroutine element_operation_kernel_matvec_gradlike_dirXYZ_P12( Mat, Mat_tr, vec_in, vec_in_, &
    vec_out_x, vec_out_y, vec_out_z  )
    implicit none
    real(RP), intent(in) :: Mat(13,13)
    real(RP), intent(in) :: Mat_tr(13,13)
    real(RP), intent(in) :: vec_in_(13,13**2)
    real(RP), intent(in) :: vec_in(13,13,13)
    real(RP), intent(out) :: vec_out_x(13,13**2)
    real(RP), intent(out) :: vec_out_y(13,13,13)
    real(RP), intent(out) :: vec_out_z(13,13,13)

    integer :: i, j, k, jk
    !----------------------------------------------------------

    ! X-dir

    do jk=1, 13**2
    do i=1, 13
        vec_out_x(i,jk) = Mat(i,1) * vec_in_(1,jk) &
                        + Mat(i,2) * vec_in_(2,jk) &
                        + Mat(i,3) * vec_in_(3,jk) &
                        + Mat(i,4) * vec_in_(4,jk) &
                        + Mat(i,5) * vec_in_(5,jk) &
                        + Mat(i,6) * vec_in_(6,jk) &
                        + Mat(i,7) * vec_in_(7,jk) &
                        + Mat(i,8) * vec_in_(8,jk) &
                        + Mat(i,9) * vec_in_(9,jk) &
                        + Mat(i,10) * vec_in_(10,jk) &
                        + Mat(i,11) * vec_in_(11,jk) &
                        + Mat(i,12) * vec_in_(12,jk) &
                        + Mat(i,13) * vec_in_(13,jk)
    end do
    end do

    ! Y-dir
    do k=1, 13
    do j=1, 13
    do i=1, 13
        vec_out_y(i,j,k) = vec_in(i,1,k) * Mat_tr(1,j) &
                         + vec_in(i,2,k) * Mat_tr(2,j) &
                         + vec_in(i,3,k) * Mat_tr(3,j) &
                         + vec_in(i,4,k) * Mat_tr(4,j) &
                         + vec_in(i,5,k) * Mat_tr(5,j) &
                         + vec_in(i,6,k) * Mat_tr(6,j) &
                         + vec_in(i,7,k) * Mat_tr(7,j) &
                         + vec_in(i,8,k) * Mat_tr(8,j) &
                         + vec_in(i,9,k) * Mat_tr(9,j) &
                         + vec_in(i,10,k) * Mat_tr(10,j) &
                         + vec_in(i,11,k) * Mat_tr(11,j) &
                         + vec_in(i,12,k) * Mat_tr(12,j) &
                         + vec_in(i,13,k) * Mat_tr(13,j) 
    end do
    end do
    end do
    
    ! Z-dir
    do k=1, 13
    do j=1, 13
    do i=1, 13
        vec_out_z(i,j,k) = vec_in(i,1,k) * Mat_tr(1,j) &
                         + vec_in(i,j,2) * Mat_tr(2,k) &
                         + vec_in(i,j,3) * Mat_tr(3,k) &
                         + vec_in(i,j,4) * Mat_tr(4,k) &
                         + vec_in(i,j,5) * Mat_tr(5,k) &
                         + vec_in(i,j,6) * Mat_tr(6,k) &
                         + vec_in(i,j,7) * Mat_tr(7,k) &
                         + vec_in(i,j,8) * Mat_tr(8,k) &
                         + vec_in(i,j,9) * Mat_tr(9,k) &
                         + vec_in(i,j,10) * Mat_tr(10,k) &
                         + vec_in(i,j,11) * Mat_tr(11,k) &
                         + vec_in(i,j,12) * Mat_tr(12,k) &
                         + vec_in(i,j,13) * Mat_tr(13,k) 
    end do
    end do
    end do

    return
  end subroutine element_operation_kernel_matvec_gradlike_dirXYZ_P12

!> Calculate a matrix-vector multiplication associated with mathematical operations in the x, y, and z direction (third dimension of vec_in) with p=12
!! For a matrix-vector multiplication (vec_d_out = Mat_d vec_d_in where d=x,y,z), the passed variables of Mat_y and Mat_z should be transposed.
!! Note that we assume that vec_in_ has same data as vec_in, but are reshaped via the call of this subroutine. 
!!
!OCL SERIAL
  subroutine element_operation_kernel_matvec_divlike_dirXYZ_P12( &
    Mat, Mat_tr, vec_in_x, vec_in_y, vec_in_z, &
    vec_out_x, vec_out_y, vec_out_z  )
    implicit none
    real(RP), intent(in) :: Mat(13,13)
    real(RP), intent(in) :: Mat_tr(13,13)
    real(RP), intent(in) :: vec_in_x(13,13**2)
    real(RP), intent(in) :: vec_in_y(13,13,13)
    real(RP), intent(in) :: vec_in_z(13,13,13)
    real(RP), intent(out) :: vec_out_x(13,13**2)
    real(RP), intent(out) :: vec_out_y(13,13**2)
    real(RP), intent(out) :: vec_out_z(13,13**2)

    integer :: i, j, k, jk
    real(RP) :: tmp1, tmp2, tmp3
    !----------------------------------------------------------

    ! X-dir

    do jk=1, 13**2
    do i=1, 13
      tmp1 = Mat(i,1) * vec_in_x(1,jk) &
           + Mat(i,2) * vec_in_x(2,jk) &
           + Mat(i,3) * vec_in_x(3,jk) &
           + Mat(i,4) * vec_in_x(4,jk)
      tmp2 = Mat(i,5) * vec_in_x(5,jk) &
           + Mat(i,6) * vec_in_x(6,jk) &
           + Mat(i,7) * vec_in_x(7,jk) &
           + Mat(i,8) * vec_in_x(8,jk)
      tmp3 = Mat(i,9) * vec_in_x(9,jk) &
           + Mat(i,10) * vec_in_x(10,jk) &
           + Mat(i,11) * vec_in_x(11,jk) &
           + Mat(i,12) * vec_in_x(12,jk) &
           + Mat(i,13) * vec_in_x(13,jk)
      vec_out_x(i,jk) = tmp1 + tmp2 + tmp3
    end do
    end do

    ! Y-dir
    do k=1, 13
    do j=1, 13
      jk = j + (k-1)*13
      do i=1, 13
        tmp1 = vec_in_y(i,1,k) * Mat_tr(1,j) &
             + vec_in_y(i,2,k) * Mat_tr(2,j) &
             + vec_in_y(i,3,k) * Mat_tr(3,j) &
             + vec_in_y(i,4,k) * Mat_tr(4,j) 
        tmp2 = vec_in_y(i,5,k) * Mat_tr(5,j) &
             + vec_in_y(i,6,k) * Mat_tr(6,j) &
             + vec_in_y(i,7,k) * Mat_tr(7,j) &
             + vec_in_y(i,8,k) * Mat_tr(8,j) 
        tmp3 = vec_in_y(i,9,k) * Mat_tr(9,j) &
             + vec_in_y(i,10,k) * Mat_tr(10,j) &
             + vec_in_y(i,11,k) * Mat_tr(11,j) &
             + vec_in_y(i,12,k) * Mat_tr(12,j) &
             + vec_in_y(i,13,k) * Mat_tr(13,j) 
      vec_out_y(i,jk) = tmp1 + tmp2 + tmp3
      end do
    end do
    end do
    
    ! Z-dir
    do k=1, 13
    do j=1, 13
      jk = j + (k-1)*13
      do i=1, 13
        tmp1 = vec_in_z(i,j,1) * Mat_tr(1,k) &
             + vec_in_z(i,j,2) * Mat_tr(2,k) &
             + vec_in_z(i,j,3) * Mat_tr(3,k) &
             + vec_in_z(i,j,4) * Mat_tr(4,k) 
        tmp2 = vec_in_z(i,j,5) * Mat_tr(5,k) &
             + vec_in_z(i,j,6) * Mat_tr(6,k) &
             + vec_in_z(i,j,7) * Mat_tr(7,k) &
             + vec_in_z(i,j,8) * Mat_tr(8,k) 
        tmp3 = vec_in_z(i,j,9) * Mat_tr(9,k) &
             + vec_in_z(i,j,10) * Mat_tr(10,k) &
             + vec_in_z(i,j,11) * Mat_tr(11,k) &
             + vec_in_z(i,j,12) * Mat_tr(12,k) &
             + vec_in_z(i,j,13) * Mat_tr(13,k) 
      vec_out_z(i,jk) = tmp1 + tmp2 + tmp3
      end do
    end do
    end do
    return
  end subroutine element_operation_kernel_matvec_divlike_dirXYZ_P12

!OCL SERIAL
  subroutine element_operation_kernel_matvec_divlike_dirXYZ_var5_P12( &
    Mat, Mat_tr, vec_in_x, vec_in_y, vec_in_z, &
    vec_out_x, vec_out_y, vec_out_z  )
    implicit none
    real(RP), intent(in) :: Mat(13,13)
    real(RP), intent(in) :: Mat_tr(13,13)
    real(RP), intent(in) :: vec_in_x(13,13**2*5)
    real(RP), intent(in) :: vec_in_y(13,13,13*5)
    real(RP), intent(in) :: vec_in_z(13,13,13,5)
    real(RP), intent(out) :: vec_out_x(13,13**2*5)
    real(RP), intent(out) :: vec_out_y(13,13**2*5)
    real(RP), intent(out) :: vec_out_z(13,13**2,5)

    integer :: i, j, k, jkv, jk, v, kv
    real(RP) :: tmp1, tmp2, tmp3
    !----------------------------------------------------------

    ! X-dir

    do jkv=1, 13**2*5
    do i=1, 13
      tmp1 = Mat(i,1) * vec_in_x(1,jkv) &
           + Mat(i,2) * vec_in_x(2,jkv) &
           + Mat(i,3) * vec_in_x(3,jkv) &
           + Mat(i,4) * vec_in_x(4,jkv)
      tmp2 = Mat(i,5) * vec_in_x(5,jkv) &
           + Mat(i,6) * vec_in_x(6,jkv) &
           + Mat(i,7) * vec_in_x(7,jkv) &
           + Mat(i,8) * vec_in_x(8,jkv)
      tmp3 = Mat(i,9) * vec_in_x(9,jkv) &
           + Mat(i,10) * vec_in_x(10,jkv) &
           + Mat(i,11) * vec_in_x(11,jkv) &
           + Mat(i,12) * vec_in_x(12,jkv) &
           + Mat(i,13) * vec_in_x(13,jkv)
      vec_out_x(i,jkv) = tmp1 + tmp2 + tmp3
    end do
    end do

    ! Y-dir
    do kv=1, 13*5
    do j=1, 13
      jkv = j + (kv-1)*65
      do i=1, 13
        tmp1 = vec_in_y(i,1,kv) * Mat_tr(1,j) &
             + vec_in_y(i,2,kv) * Mat_tr(2,j) &
             + vec_in_y(i,3,kv) * Mat_tr(3,j) &
             + vec_in_y(i,4,kv) * Mat_tr(4,j) 
        tmp2 = vec_in_y(i,5,kv) * Mat_tr(5,j) &
             + vec_in_y(i,6,kv) * Mat_tr(6,j) &
             + vec_in_y(i,7,kv) * Mat_tr(7,j) &
             + vec_in_y(i,8,kv) * Mat_tr(8,j) 
        tmp3 = vec_in_y(i,9,kv) * Mat_tr(9,j) &
             + vec_in_y(i,10,kv) * Mat_tr(10,j) &
             + vec_in_y(i,11,kv) * Mat_tr(11,j) &
             + vec_in_y(i,12,kv) * Mat_tr(12,j) &
             + vec_in_y(i,13,kv) * Mat_tr(13,j) 
      vec_out_y(i,jkv) = tmp1 + tmp2 + tmp3
      end do
    end do
    end do
    
    ! Z-dir
    do v=1, 5
    do k=1, 13
    do j=1, 13
      jk = j + (k-1)*13
      do i=1, 13
        tmp1 = vec_in_z(i,j,1,v) * Mat_tr(1,k) &
             + vec_in_z(i,j,2,v) * Mat_tr(2,k) &
             + vec_in_z(i,j,3,v) * Mat_tr(3,k) &
             + vec_in_z(i,j,4,v) * Mat_tr(4,k) 
        tmp2 = vec_in_z(i,j,5,v) * Mat_tr(5,k) &
             + vec_in_z(i,j,6,v) * Mat_tr(6,k) &
             + vec_in_z(i,j,7,v) * Mat_tr(7,k) &
             + vec_in_z(i,j,8,v) * Mat_tr(8,k) 
        tmp3 = vec_in_z(i,j,9,v) * Mat_tr(9,k) &
             + vec_in_z(i,j,10,v) * Mat_tr(10,k) &
             + vec_in_z(i,j,11,v) * Mat_tr(11,k) &
             + vec_in_z(i,j,12,v) * Mat_tr(12,k) &
             + vec_in_z(i,j,13,v) * Mat_tr(13,k) 
      vec_out_z(i,jk,v) = tmp1 + tmp2 + tmp3
      end do
    end do
    end do
    end do
    return
  end subroutine element_operation_kernel_matvec_divlike_dirXYZ_var5_P12

!> Calculate a matrix-vector multiplication associated with 3D modal filtering with p=12
!!
!OCL SERIAL
  subroutine element_operation_kernel_matvec_ModalFilter_P12( Mat_h1D, Mat_h1D_tr, Mat_v1D_tr, vec_in, vec_work, &
    vec_out  )
    implicit none
    real(RP), intent(in) :: Mat_h1D(13,13)
    real(RP), intent(in) :: Mat_h1D_tr(13,13)
    real(RP), intent(in) :: Mat_v1D_tr(13,13)
    real(RP), intent(in) :: vec_in(13,13,13)
    real(RP), intent(out) :: vec_work(13,13,13)
    real(RP), intent(out) :: vec_out(13,13,13)

    integer :: i, j, k
    real(RP) :: tmp1, tmp2, tmp3
    !----------------------------------------------------------

    ! X-dir

    do k=1, 13
    do j=1, 13
    do i=1, 13
      tmp1 = Mat_h1D(i,1) * vec_in(1,j,k) &
           + Mat_h1D(i,2) * vec_in(2,j,k) &
           + Mat_h1D(i,3) * vec_in(3,j,k) &
           + Mat_h1D(i,4) * vec_in(4,j,k)
      tmp2 = Mat_h1D(i,5) * vec_in(5,j,k) &
           + Mat_h1D(i,6) * vec_in(6,j,k) &
           + Mat_h1D(i,7) * vec_in(7,j,k) &
           + Mat_h1D(i,8) * vec_in(8,j,k)
      tmp3 = Mat_h1D(i,9) * vec_in(9,j,k) &
           + Mat_h1D(i,10) * vec_in(10,j,k) &
           + Mat_h1D(i,11) * vec_in(11,j,k) &
           + Mat_h1D(i,12) * vec_in(12,j,k) &
           + Mat_h1D(i,13) * vec_in(13,j,k)
      vec_out(i,j,k) = tmp1 + tmp2 + tmp3
    end do
    end do
    end do
    
    ! Y-dir
    do k=1, 13
    do j=1, 13
    do i=1, 13
      tmp1 = vec_out(i,1,k) * Mat_h1D_tr(1,j) &
           + vec_out(i,2,k) * Mat_h1D_tr(2,j) &
           + vec_out(i,3,k) * Mat_h1D_tr(3,j) &
           + vec_out(i,4,k) * Mat_h1D_tr(4,j) 
      tmp2 = vec_out(i,5,k) * Mat_h1D_tr(5,j) &
           + vec_out(i,6,k) * Mat_h1D_tr(6,j) &
           + vec_out(i,7,k) * Mat_h1D_tr(7,j) &
           + vec_out(i,8,k) * Mat_h1D_tr(8,j) 
      tmp3 = vec_out(i,9,k) * Mat_h1D_tr(9,j) &
           + vec_out(i,10,k) * Mat_h1D_tr(10,j) &
           + vec_out(i,11,k) * Mat_h1D_tr(11,j) &
           + vec_out(i,12,k) * Mat_h1D_tr(12,j) &
           + vec_out(i,13,k) * Mat_h1D_tr(13,j) 
      vec_work(i,j,k) = tmp1 + tmp2 + tmp3
    end do
    end do
    end do
    
    ! Z-dir
    do k=1, 13
    do j=1, 13
    do i=1, 13
      tmp1 = vec_work(i,j,1) * Mat_v1D_tr(1,k) &
           + vec_work(i,j,2) * Mat_v1D_tr(2,k) &
           + vec_work(i,j,3) * Mat_v1D_tr(3,k) &
           + vec_work(i,j,4) * Mat_v1D_tr(4,k) 
      tmp2 = vec_work(i,j,5) * Mat_v1D_tr(5,k) &
           + vec_work(i,j,6) * Mat_v1D_tr(6,k) &
           + vec_work(i,j,7) * Mat_v1D_tr(7,k) &
           + vec_work(i,j,8) * Mat_v1D_tr(8,k) 
      tmp3 = vec_work(i,j,9) * Mat_v1D_tr(9,k) &
           + vec_work(i,j,10) * Mat_v1D_tr(10,k) &
           + vec_work(i,j,11) * Mat_v1D_tr(11,k) &
           + vec_work(i,j,12) * Mat_v1D_tr(12,k) &
           + vec_work(i,j,13) * Mat_v1D_tr(13,k) 
      vec_out(i,j,k) = tmp1 + tmp2 + tmp3
    end do
    end do
    end do

    return
  end subroutine element_operation_kernel_matvec_ModalFilter_P12

!--- For p=13 ------------------------------------

!> Calculate a matrix-vector multiplication associated with mathematical operations in the x direction (first dimension of vec_in) with p=13
!!
!OCL SERIAL
  subroutine element_operation_kernel_matvec_dirX_P13( Mat_x, vec_in, vec_out )
    implicit none
    real(RP), intent(in) :: Mat_x(14,14)
    real(RP), intent(in) :: vec_in(14,14**2)
    real(RP), intent(out) :: vec_out(14,14**2)

    integer :: i, jk
    !----------------------------------------------------------

    do jk=1, 14**2
    do i=1, 14
        vec_out(i,jk) = Mat_x(i,1) * vec_in(1,jk) &
                      + Mat_x(i,2) * vec_in(2,jk) &
                      + Mat_x(i,3) * vec_in(3,jk) &
                      + Mat_x(i,4) * vec_in(4,jk) &
                      + Mat_x(i,5) * vec_in(5,jk) &
                      + Mat_x(i,6) * vec_in(6,jk) &
                      + Mat_x(i,7) * vec_in(7,jk) &
                      + Mat_x(i,8) * vec_in(8,jk) &
                      + Mat_x(i,9) * vec_in(9,jk) &
                      + Mat_x(i,10) * vec_in(10,jk) &
                      + Mat_x(i,11) * vec_in(11,jk) &
                      + Mat_x(i,12) * vec_in(12,jk) &
                      + Mat_x(i,13) * vec_in(13,jk) &
                      + Mat_x(i,14) * vec_in(14,jk)
    end do
    end do

    return
  end subroutine element_operation_kernel_matvec_dirX_P13

!> Calculate a matrix-vector multiplication associated with mathematical operations in the y direction (second dimension of vec_in) with p=13
!! For a matrix-vector multiplication (vec_out = Mat_y vec_in), the passed variable of Mat_y should be transposed.
!!
!OCL SERIAL
  subroutine element_operation_kernel_matvec_dirY_P13( Mat_y_tr, vec_in, vec_out )
    implicit none
    real(RP), intent(in) :: Mat_y_tr(14,14)
    real(RP), intent(in) :: vec_in(14,14,14)
    real(RP), intent(out) :: vec_out(14,14,14)

    integer :: i, j, k
    !----------------------------------------------------------

    do k=1, 14
    do j=1, 14
    do i=1, 14
        vec_out(i,j,k) = vec_in(i,1,k) * Mat_y_tr(1,j) &
                       + vec_in(i,2,k) * Mat_y_tr(2,j) &
                       + vec_in(i,3,k) * Mat_y_tr(3,j) &
                       + vec_in(i,4,k) * Mat_y_tr(4,j) &
                       + vec_in(i,5,k) * Mat_y_tr(5,j) &
                       + vec_in(i,6,k) * Mat_y_tr(6,j) &
                       + vec_in(i,7,k) * Mat_y_tr(7,j) &
                       + vec_in(i,8,k) * Mat_y_tr(8,j) &
                       + vec_in(i,9,k) * Mat_y_tr(9,j) &
                       + vec_in(i,10,k) * Mat_y_tr(10,j) &
                       + vec_in(i,11,k) * Mat_y_tr(11,j) &
                       + vec_in(i,12,k) * Mat_y_tr(12,j) &
                       + vec_in(i,13,k) * Mat_y_tr(13,j) &
                       + vec_in(i,14,k) * Mat_y_tr(14,j) 
    end do
    end do
    end do

    return
  end subroutine element_operation_kernel_matvec_dirY_P13

!> Calculate a matrix-vector multiplication associated with mathematical operations in the z direction (third dimension of vec_in) with p=13
!! For a matrix-vector multiplication (vec_out = Mat_z vec_in), the passed variable of Mat_z should be transposed.
!!
!OCL SERIAL
  subroutine element_operation_kernel_matvec_dirZ_P13( Mat_z_tr, vec_in, vec_out )
    implicit none
    real(RP), intent(in) :: Mat_z_tr(14,14)
    real(RP), intent(in) :: vec_in(14,14,14)
    real(RP), intent(out) :: vec_out(14,14,14)

    integer :: i, j, k
    !----------------------------------------------------------

    do k=1, 14
    do j=1, 14
    do i=1, 14
        vec_out(i,j,k) = vec_in(i,j,1) * Mat_z_tr(1,k) &
                       + vec_in(i,j,2) * Mat_z_tr(2,k) &
                       + vec_in(i,j,3) * Mat_z_tr(3,k) &
                       + vec_in(i,j,4) * Mat_z_tr(4,k) &
                       + vec_in(i,j,5) * Mat_z_tr(5,k) &
                       + vec_in(i,j,6) * Mat_z_tr(6,k) &
                       + vec_in(i,j,7) * Mat_z_tr(7,k) &
                       + vec_in(i,j,8) * Mat_z_tr(8,k) &
                       + vec_in(i,j,9) * Mat_z_tr(9,k) &
                       + vec_in(i,j,10) * Mat_z_tr(10,k) &
                       + vec_in(i,j,11) * Mat_z_tr(11,k) &
                       + vec_in(i,j,12) * Mat_z_tr(12,k) &
                       + vec_in(i,j,13) * Mat_z_tr(13,k) &
                       + vec_in(i,j,14) * Mat_z_tr(14,k) 
    end do
    end do
    end do

    return
  end subroutine element_operation_kernel_matvec_dirZ_P13

!> Calculate a matrix-vector multiplication with lifting operations for a hexahedral element of order p=13
!!
!OCL SERIAL
  subroutine element_operation_kernel_matvec_Lift_hexahedral_P13( Lift, vec_in, vec_out )
    implicit none
    real(RP), intent(in) :: Lift(14,14,14,6)
    real(RP), intent(in) :: vec_in(14,14,6)
    real(RP), intent(out) :: vec_out(14,14,14)

    integer :: i, j, k
    !----------------------------------------------------------

    do k=1, 14
    do j=1, 14
    do i=1, 14
        vec_out(i,j,k) = Lift(i,j,k,1) * vec_in(i,k,1) &
                       + Lift(i,j,k,2) * vec_in(j,k,2) &
                       + Lift(i,j,k,3) * vec_in(i,k,3) &
                       + Lift(i,j,k,4) * vec_in(j,k,4) &
                       + Lift(i,j,k,5) * vec_in(i,j,5) &
                       + Lift(i,j,k,6) * vec_in(i,j,6)
    end do
    end do
    end do

    return
  end subroutine element_operation_kernel_matvec_Lift_hexahedral_P13
  
!> Calculate a matrix-vector multiplication associated with mathematical operations in the x, y, and z direction (third dimension of vec_in) with p=13
!! For a matrix-vector multiplication (vec_d_out = Mat_d vec_in where d=x,y,z), the passed variables of Mat_y and Mat_z should be transposed.
!! Note that we assume that vec_in_ has same data as vec_in, but are reshaped via the call of this subroutine. 
!!
!OCL SERIAL
  subroutine element_operation_kernel_matvec_gradlike_dirXYZ_P13( Mat, Mat_tr, vec_in, vec_in_, &
    vec_out_x, vec_out_y, vec_out_z  )
    implicit none
    real(RP), intent(in) :: Mat(14,14)
    real(RP), intent(in) :: Mat_tr(14,14)
    real(RP), intent(in) :: vec_in_(14,14**2)
    real(RP), intent(in) :: vec_in(14,14,14)
    real(RP), intent(out) :: vec_out_x(14,14**2)
    real(RP), intent(out) :: vec_out_y(14,14,14)
    real(RP), intent(out) :: vec_out_z(14,14,14)

    integer :: i, j, k, jk
    !----------------------------------------------------------

    ! X-dir

    do jk=1, 14**2
    do i=1, 14
        vec_out_x(i,jk) = Mat(i,1) * vec_in_(1,jk) &
                        + Mat(i,2) * vec_in_(2,jk) &
                        + Mat(i,3) * vec_in_(3,jk) &
                        + Mat(i,4) * vec_in_(4,jk) &
                        + Mat(i,5) * vec_in_(5,jk) &
                        + Mat(i,6) * vec_in_(6,jk) &
                        + Mat(i,7) * vec_in_(7,jk) &
                        + Mat(i,8) * vec_in_(8,jk) &
                        + Mat(i,9) * vec_in_(9,jk) &
                        + Mat(i,10) * vec_in_(10,jk) &
                        + Mat(i,11) * vec_in_(11,jk) &
                        + Mat(i,12) * vec_in_(12,jk) &
                        + Mat(i,13) * vec_in_(13,jk) &
                        + Mat(i,14) * vec_in_(14,jk)
    end do
    end do

    ! Y-dir
    do k=1, 14
    do j=1, 14
    do i=1, 14
        vec_out_y(i,j,k) = vec_in(i,1,k) * Mat_tr(1,j) &
                         + vec_in(i,2,k) * Mat_tr(2,j) &
                         + vec_in(i,3,k) * Mat_tr(3,j) &
                         + vec_in(i,4,k) * Mat_tr(4,j) &
                         + vec_in(i,5,k) * Mat_tr(5,j) &
                         + vec_in(i,6,k) * Mat_tr(6,j) &
                         + vec_in(i,7,k) * Mat_tr(7,j) &
                         + vec_in(i,8,k) * Mat_tr(8,j) &
                         + vec_in(i,9,k) * Mat_tr(9,j) &
                         + vec_in(i,10,k) * Mat_tr(10,j) &
                         + vec_in(i,11,k) * Mat_tr(11,j) &
                         + vec_in(i,12,k) * Mat_tr(12,j) &
                         + vec_in(i,13,k) * Mat_tr(13,j) &
                         + vec_in(i,14,k) * Mat_tr(14,j) 
    end do
    end do
    end do
    
    ! Z-dir
    do k=1, 14
    do j=1, 14
    do i=1, 14
        vec_out_z(i,j,k) = vec_in(i,1,k) * Mat_tr(1,j) &
                         + vec_in(i,j,2) * Mat_tr(2,k) &
                         + vec_in(i,j,3) * Mat_tr(3,k) &
                         + vec_in(i,j,4) * Mat_tr(4,k) &
                         + vec_in(i,j,5) * Mat_tr(5,k) &
                         + vec_in(i,j,6) * Mat_tr(6,k) &
                         + vec_in(i,j,7) * Mat_tr(7,k) &
                         + vec_in(i,j,8) * Mat_tr(8,k) &
                         + vec_in(i,j,9) * Mat_tr(9,k) &
                         + vec_in(i,j,10) * Mat_tr(10,k) &
                         + vec_in(i,j,11) * Mat_tr(11,k) &
                         + vec_in(i,j,12) * Mat_tr(12,k) &
                         + vec_in(i,j,13) * Mat_tr(13,k) &
                         + vec_in(i,j,14) * Mat_tr(14,k) 
    end do
    end do
    end do

    return
  end subroutine element_operation_kernel_matvec_gradlike_dirXYZ_P13

!> Calculate a matrix-vector multiplication associated with mathematical operations in the x, y, and z direction (third dimension of vec_in) with p=13
!! For a matrix-vector multiplication (vec_d_out = Mat_d vec_d_in where d=x,y,z), the passed variables of Mat_y and Mat_z should be transposed.
!! Note that we assume that vec_in_ has same data as vec_in, but are reshaped via the call of this subroutine. 
!!
!OCL SERIAL
  subroutine element_operation_kernel_matvec_divlike_dirXYZ_P13( &
    Mat, Mat_tr, vec_in_x, vec_in_y, vec_in_z, &
    vec_out_x, vec_out_y, vec_out_z  )
    implicit none
    real(RP), intent(in) :: Mat(14,14)
    real(RP), intent(in) :: Mat_tr(14,14)
    real(RP), intent(in) :: vec_in_x(14,14**2)
    real(RP), intent(in) :: vec_in_y(14,14,14)
    real(RP), intent(in) :: vec_in_z(14,14,14)
    real(RP), intent(out) :: vec_out_x(14,14**2)
    real(RP), intent(out) :: vec_out_y(14,14**2)
    real(RP), intent(out) :: vec_out_z(14,14**2)

    integer :: i, j, k, jk
    real(RP) :: tmp1, tmp2, tmp3
    !----------------------------------------------------------

    ! X-dir

    do jk=1, 14**2
    do i=1, 14
      tmp1 = Mat(i,1) * vec_in_x(1,jk) &
           + Mat(i,2) * vec_in_x(2,jk) &
           + Mat(i,3) * vec_in_x(3,jk) &
           + Mat(i,4) * vec_in_x(4,jk) &
           + Mat(i,5) * vec_in_x(5,jk)
      tmp2 = Mat(i,6) * vec_in_x(6,jk) &
           + Mat(i,7) * vec_in_x(7,jk) &
           + Mat(i,8) * vec_in_x(8,jk) &
           + Mat(i,9) * vec_in_x(9,jk) &
           + Mat(i,10) * vec_in_x(10,jk)
      tmp3 = Mat(i,11) * vec_in_x(11,jk) &
           + Mat(i,12) * vec_in_x(12,jk) &
           + Mat(i,13) * vec_in_x(13,jk) &
           + Mat(i,14) * vec_in_x(14,jk)
      vec_out_x(i,jk) = tmp1 + tmp2 + tmp3
    end do
    end do

    ! Y-dir
    do k=1, 14
    do j=1, 14
      jk = j + (k-1)*14
      do i=1, 14
        tmp1 = vec_in_y(i,1,k) * Mat_tr(1,j) &
             + vec_in_y(i,2,k) * Mat_tr(2,j) &
             + vec_in_y(i,3,k) * Mat_tr(3,j) &
             + vec_in_y(i,4,k) * Mat_tr(4,j) &
             + vec_in_y(i,5,k) * Mat_tr(5,j) 
        tmp2 = vec_in_y(i,6,k) * Mat_tr(6,j) &
             + vec_in_y(i,7,k) * Mat_tr(7,j) &
             + vec_in_y(i,8,k) * Mat_tr(8,j) &
             + vec_in_y(i,9,k) * Mat_tr(9,j) &
             + vec_in_y(i,10,k) * Mat_tr(10,j) 
        tmp3 = vec_in_y(i,11,k) * Mat_tr(11,j) &
             + vec_in_y(i,12,k) * Mat_tr(12,j) &
             + vec_in_y(i,13,k) * Mat_tr(13,j) &
             + vec_in_y(i,14,k) * Mat_tr(14,j) 
      vec_out_y(i,jk) = tmp1 + tmp2 + tmp3
      end do
    end do
    end do
    
    ! Z-dir
    do k=1, 14
    do j=1, 14
      jk = j + (k-1)*14
      do i=1, 14
        tmp1 = vec_in_z(i,j,1) * Mat_tr(1,k) &
             + vec_in_z(i,j,2) * Mat_tr(2,k) &
             + vec_in_z(i,j,3) * Mat_tr(3,k) &
             + vec_in_z(i,j,4) * Mat_tr(4,k) &
             + vec_in_z(i,j,5) * Mat_tr(5,k) 
        tmp2 = vec_in_z(i,j,6) * Mat_tr(6,k) &
             + vec_in_z(i,j,7) * Mat_tr(7,k) &
             + vec_in_z(i,j,8) * Mat_tr(8,k) &
             + vec_in_z(i,j,9) * Mat_tr(9,k) &
             + vec_in_z(i,j,10) * Mat_tr(10,k) 
        tmp3 = vec_in_z(i,j,11) * Mat_tr(11,k) &
             + vec_in_z(i,j,12) * Mat_tr(12,k) &
             + vec_in_z(i,j,13) * Mat_tr(13,k) &
             + vec_in_z(i,j,14) * Mat_tr(14,k) 
      vec_out_z(i,jk) = tmp1 + tmp2 + tmp3
      end do
    end do
    end do
    return
  end subroutine element_operation_kernel_matvec_divlike_dirXYZ_P13

!OCL SERIAL
  subroutine element_operation_kernel_matvec_divlike_dirXYZ_var5_P13( &
    Mat, Mat_tr, vec_in_x, vec_in_y, vec_in_z, &
    vec_out_x, vec_out_y, vec_out_z  )
    implicit none
    real(RP), intent(in) :: Mat(14,14)
    real(RP), intent(in) :: Mat_tr(14,14)
    real(RP), intent(in) :: vec_in_x(14,14**2*5)
    real(RP), intent(in) :: vec_in_y(14,14,14*5)
    real(RP), intent(in) :: vec_in_z(14,14,14,5)
    real(RP), intent(out) :: vec_out_x(14,14**2*5)
    real(RP), intent(out) :: vec_out_y(14,14**2*5)
    real(RP), intent(out) :: vec_out_z(14,14**2,5)

    integer :: i, j, k, jkv, jk, v, kv
    real(RP) :: tmp1, tmp2, tmp3
    !----------------------------------------------------------

    ! X-dir

    do jkv=1, 14**2*5
    do i=1, 14
      tmp1 = Mat(i,1) * vec_in_x(1,jkv) &
           + Mat(i,2) * vec_in_x(2,jkv) &
           + Mat(i,3) * vec_in_x(3,jkv) &
           + Mat(i,4) * vec_in_x(4,jkv) &
           + Mat(i,5) * vec_in_x(5,jkv)
      tmp2 = Mat(i,6) * vec_in_x(6,jkv) &
           + Mat(i,7) * vec_in_x(7,jkv) &
           + Mat(i,8) * vec_in_x(8,jkv) &
           + Mat(i,9) * vec_in_x(9,jkv) &
           + Mat(i,10) * vec_in_x(10,jkv)
      tmp3 = Mat(i,11) * vec_in_x(11,jkv) &
           + Mat(i,12) * vec_in_x(12,jkv) &
           + Mat(i,13) * vec_in_x(13,jkv) &
           + Mat(i,14) * vec_in_x(14,jkv)
      vec_out_x(i,jkv) = tmp1 + tmp2 + tmp3
    end do
    end do

    ! Y-dir
    do kv=1, 14*5
    do j=1, 14
      jkv = j + (kv-1)*70
      do i=1, 14
        tmp1 = vec_in_y(i,1,kv) * Mat_tr(1,j) &
             + vec_in_y(i,2,kv) * Mat_tr(2,j) &
             + vec_in_y(i,3,kv) * Mat_tr(3,j) &
             + vec_in_y(i,4,kv) * Mat_tr(4,j) &
             + vec_in_y(i,5,kv) * Mat_tr(5,j) 
        tmp2 = vec_in_y(i,6,kv) * Mat_tr(6,j) &
             + vec_in_y(i,7,kv) * Mat_tr(7,j) &
             + vec_in_y(i,8,kv) * Mat_tr(8,j) &
             + vec_in_y(i,9,kv) * Mat_tr(9,j) &
             + vec_in_y(i,10,kv) * Mat_tr(10,j) 
        tmp3 = vec_in_y(i,11,kv) * Mat_tr(11,j) &
             + vec_in_y(i,12,kv) * Mat_tr(12,j) &
             + vec_in_y(i,13,kv) * Mat_tr(13,j) &
             + vec_in_y(i,14,kv) * Mat_tr(14,j) 
      vec_out_y(i,jkv) = tmp1 + tmp2 + tmp3
      end do
    end do
    end do
    
    ! Z-dir
    do v=1, 5
    do k=1, 14
    do j=1, 14
      jk = j + (k-1)*14
      do i=1, 14
        tmp1 = vec_in_z(i,j,1,v) * Mat_tr(1,k) &
             + vec_in_z(i,j,2,v) * Mat_tr(2,k) &
             + vec_in_z(i,j,3,v) * Mat_tr(3,k) &
             + vec_in_z(i,j,4,v) * Mat_tr(4,k) &
             + vec_in_z(i,j,5,v) * Mat_tr(5,k) 
        tmp2 = vec_in_z(i,j,6,v) * Mat_tr(6,k) &
             + vec_in_z(i,j,7,v) * Mat_tr(7,k) &
             + vec_in_z(i,j,8,v) * Mat_tr(8,k) &
             + vec_in_z(i,j,9,v) * Mat_tr(9,k) &
             + vec_in_z(i,j,10,v) * Mat_tr(10,k) 
        tmp3 = vec_in_z(i,j,11,v) * Mat_tr(11,k) &
             + vec_in_z(i,j,12,v) * Mat_tr(12,k) &
             + vec_in_z(i,j,13,v) * Mat_tr(13,k) &
             + vec_in_z(i,j,14,v) * Mat_tr(14,k) 
      vec_out_z(i,jk,v) = tmp1 + tmp2 + tmp3
      end do
    end do
    end do
    end do
    return
  end subroutine element_operation_kernel_matvec_divlike_dirXYZ_var5_P13

!> Calculate a matrix-vector multiplication associated with 3D modal filtering with p=13
!!
!OCL SERIAL
  subroutine element_operation_kernel_matvec_ModalFilter_P13( Mat_h1D, Mat_h1D_tr, Mat_v1D_tr, vec_in, vec_work, &
    vec_out  )
    implicit none
    real(RP), intent(in) :: Mat_h1D(14,14)
    real(RP), intent(in) :: Mat_h1D_tr(14,14)
    real(RP), intent(in) :: Mat_v1D_tr(14,14)
    real(RP), intent(in) :: vec_in(14,14,14)
    real(RP), intent(out) :: vec_work(14,14,14)
    real(RP), intent(out) :: vec_out(14,14,14)

    integer :: i, j, k
    real(RP) :: tmp1, tmp2, tmp3
    !----------------------------------------------------------

    ! X-dir

    do k=1, 14
    do j=1, 14
    do i=1, 14
      tmp1 = Mat_h1D(i,1) * vec_in(1,j,k) &
           + Mat_h1D(i,2) * vec_in(2,j,k) &
           + Mat_h1D(i,3) * vec_in(3,j,k) &
           + Mat_h1D(i,4) * vec_in(4,j,k) &
           + Mat_h1D(i,5) * vec_in(5,j,k)
      tmp2 = Mat_h1D(i,6) * vec_in(6,j,k) &
           + Mat_h1D(i,7) * vec_in(7,j,k) &
           + Mat_h1D(i,8) * vec_in(8,j,k) &
           + Mat_h1D(i,9) * vec_in(9,j,k) &
           + Mat_h1D(i,10) * vec_in(10,j,k)
      tmp3 = Mat_h1D(i,11) * vec_in(11,j,k) &
           + Mat_h1D(i,12) * vec_in(12,j,k) &
           + Mat_h1D(i,13) * vec_in(13,j,k) &
           + Mat_h1D(i,14) * vec_in(14,j,k)
      vec_out(i,j,k) = tmp1 + tmp2 + tmp3
    end do
    end do
    end do
    
    ! Y-dir
    do k=1, 14
    do j=1, 14
    do i=1, 14
      tmp1 = vec_out(i,1,k) * Mat_h1D_tr(1,j) &
           + vec_out(i,2,k) * Mat_h1D_tr(2,j) &
           + vec_out(i,3,k) * Mat_h1D_tr(3,j) &
           + vec_out(i,4,k) * Mat_h1D_tr(4,j) &
           + vec_out(i,5,k) * Mat_h1D_tr(5,j) 
      tmp2 = vec_out(i,6,k) * Mat_h1D_tr(6,j) &
           + vec_out(i,7,k) * Mat_h1D_tr(7,j) &
           + vec_out(i,8,k) * Mat_h1D_tr(8,j) &
           + vec_out(i,9,k) * Mat_h1D_tr(9,j) &
           + vec_out(i,10,k) * Mat_h1D_tr(10,j) 
      tmp3 = vec_out(i,11,k) * Mat_h1D_tr(11,j) &
           + vec_out(i,12,k) * Mat_h1D_tr(12,j) &
           + vec_out(i,13,k) * Mat_h1D_tr(13,j) &
           + vec_out(i,14,k) * Mat_h1D_tr(14,j) 
      vec_work(i,j,k) = tmp1 + tmp2 + tmp3
    end do
    end do
    end do
    
    ! Z-dir
    do k=1, 14
    do j=1, 14
    do i=1, 14
      tmp1 = vec_work(i,j,1) * Mat_v1D_tr(1,k) &
           + vec_work(i,j,2) * Mat_v1D_tr(2,k) &
           + vec_work(i,j,3) * Mat_v1D_tr(3,k) &
           + vec_work(i,j,4) * Mat_v1D_tr(4,k) &
           + vec_work(i,j,5) * Mat_v1D_tr(5,k) 
      tmp2 = vec_work(i,j,6) * Mat_v1D_tr(6,k) &
           + vec_work(i,j,7) * Mat_v1D_tr(7,k) &
           + vec_work(i,j,8) * Mat_v1D_tr(8,k) &
           + vec_work(i,j,9) * Mat_v1D_tr(9,k) &
           + vec_work(i,j,10) * Mat_v1D_tr(10,k) 
      tmp3 = vec_work(i,j,11) * Mat_v1D_tr(11,k) &
           + vec_work(i,j,12) * Mat_v1D_tr(12,k) &
           + vec_work(i,j,13) * Mat_v1D_tr(13,k) &
           + vec_work(i,j,14) * Mat_v1D_tr(14,k) 
      vec_out(i,j,k) = tmp1 + tmp2 + tmp3
    end do
    end do
    end do

    return
  end subroutine element_operation_kernel_matvec_ModalFilter_P13

!--- For p=14 ------------------------------------

!> Calculate a matrix-vector multiplication associated with mathematical operations in the x direction (first dimension of vec_in) with p=14
!!
!OCL SERIAL
  subroutine element_operation_kernel_matvec_dirX_P14( Mat_x, vec_in, vec_out )
    implicit none
    real(RP), intent(in) :: Mat_x(15,15)
    real(RP), intent(in) :: vec_in(15,15**2)
    real(RP), intent(out) :: vec_out(15,15**2)

    integer :: i, jk
    !----------------------------------------------------------

    do jk=1, 15**2
    do i=1, 15
        vec_out(i,jk) = Mat_x(i,1) * vec_in(1,jk) &
                      + Mat_x(i,2) * vec_in(2,jk) &
                      + Mat_x(i,3) * vec_in(3,jk) &
                      + Mat_x(i,4) * vec_in(4,jk) &
                      + Mat_x(i,5) * vec_in(5,jk) &
                      + Mat_x(i,6) * vec_in(6,jk) &
                      + Mat_x(i,7) * vec_in(7,jk) &
                      + Mat_x(i,8) * vec_in(8,jk) &
                      + Mat_x(i,9) * vec_in(9,jk) &
                      + Mat_x(i,10) * vec_in(10,jk) &
                      + Mat_x(i,11) * vec_in(11,jk) &
                      + Mat_x(i,12) * vec_in(12,jk) &
                      + Mat_x(i,13) * vec_in(13,jk) &
                      + Mat_x(i,14) * vec_in(14,jk) &
                      + Mat_x(i,15) * vec_in(15,jk)
    end do
    end do

    return
  end subroutine element_operation_kernel_matvec_dirX_P14

!> Calculate a matrix-vector multiplication associated with mathematical operations in the y direction (second dimension of vec_in) with p=14
!! For a matrix-vector multiplication (vec_out = Mat_y vec_in), the passed variable of Mat_y should be transposed.
!!
!OCL SERIAL
  subroutine element_operation_kernel_matvec_dirY_P14( Mat_y_tr, vec_in, vec_out )
    implicit none
    real(RP), intent(in) :: Mat_y_tr(15,15)
    real(RP), intent(in) :: vec_in(15,15,15)
    real(RP), intent(out) :: vec_out(15,15,15)

    integer :: i, j, k
    !----------------------------------------------------------

    do k=1, 15
    do j=1, 15
    do i=1, 15
        vec_out(i,j,k) = vec_in(i,1,k) * Mat_y_tr(1,j) &
                       + vec_in(i,2,k) * Mat_y_tr(2,j) &
                       + vec_in(i,3,k) * Mat_y_tr(3,j) &
                       + vec_in(i,4,k) * Mat_y_tr(4,j) &
                       + vec_in(i,5,k) * Mat_y_tr(5,j) &
                       + vec_in(i,6,k) * Mat_y_tr(6,j) &
                       + vec_in(i,7,k) * Mat_y_tr(7,j) &
                       + vec_in(i,8,k) * Mat_y_tr(8,j) &
                       + vec_in(i,9,k) * Mat_y_tr(9,j) &
                       + vec_in(i,10,k) * Mat_y_tr(10,j) &
                       + vec_in(i,11,k) * Mat_y_tr(11,j) &
                       + vec_in(i,12,k) * Mat_y_tr(12,j) &
                       + vec_in(i,13,k) * Mat_y_tr(13,j) &
                       + vec_in(i,14,k) * Mat_y_tr(14,j) &
                       + vec_in(i,15,k) * Mat_y_tr(15,j) 
    end do
    end do
    end do

    return
  end subroutine element_operation_kernel_matvec_dirY_P14

!> Calculate a matrix-vector multiplication associated with mathematical operations in the z direction (third dimension of vec_in) with p=14
!! For a matrix-vector multiplication (vec_out = Mat_z vec_in), the passed variable of Mat_z should be transposed.
!!
!OCL SERIAL
  subroutine element_operation_kernel_matvec_dirZ_P14( Mat_z_tr, vec_in, vec_out )
    implicit none
    real(RP), intent(in) :: Mat_z_tr(15,15)
    real(RP), intent(in) :: vec_in(15,15,15)
    real(RP), intent(out) :: vec_out(15,15,15)

    integer :: i, j, k
    !----------------------------------------------------------

    do k=1, 15
    do j=1, 15
    do i=1, 15
        vec_out(i,j,k) = vec_in(i,j,1) * Mat_z_tr(1,k) &
                       + vec_in(i,j,2) * Mat_z_tr(2,k) &
                       + vec_in(i,j,3) * Mat_z_tr(3,k) &
                       + vec_in(i,j,4) * Mat_z_tr(4,k) &
                       + vec_in(i,j,5) * Mat_z_tr(5,k) &
                       + vec_in(i,j,6) * Mat_z_tr(6,k) &
                       + vec_in(i,j,7) * Mat_z_tr(7,k) &
                       + vec_in(i,j,8) * Mat_z_tr(8,k) &
                       + vec_in(i,j,9) * Mat_z_tr(9,k) &
                       + vec_in(i,j,10) * Mat_z_tr(10,k) &
                       + vec_in(i,j,11) * Mat_z_tr(11,k) &
                       + vec_in(i,j,12) * Mat_z_tr(12,k) &
                       + vec_in(i,j,13) * Mat_z_tr(13,k) &
                       + vec_in(i,j,14) * Mat_z_tr(14,k) &
                       + vec_in(i,j,15) * Mat_z_tr(15,k) 
    end do
    end do
    end do

    return
  end subroutine element_operation_kernel_matvec_dirZ_P14

!> Calculate a matrix-vector multiplication with lifting operations for a hexahedral element of order p=14
!!
!OCL SERIAL
  subroutine element_operation_kernel_matvec_Lift_hexahedral_P14( Lift, vec_in, vec_out )
    implicit none
    real(RP), intent(in) :: Lift(15,15,15,6)
    real(RP), intent(in) :: vec_in(15,15,6)
    real(RP), intent(out) :: vec_out(15,15,15)

    integer :: i, j, k
    !----------------------------------------------------------

    do k=1, 15
    do j=1, 15
    do i=1, 15
        vec_out(i,j,k) = Lift(i,j,k,1) * vec_in(i,k,1) &
                       + Lift(i,j,k,2) * vec_in(j,k,2) &
                       + Lift(i,j,k,3) * vec_in(i,k,3) &
                       + Lift(i,j,k,4) * vec_in(j,k,4) &
                       + Lift(i,j,k,5) * vec_in(i,j,5) &
                       + Lift(i,j,k,6) * vec_in(i,j,6)
    end do
    end do
    end do

    return
  end subroutine element_operation_kernel_matvec_Lift_hexahedral_P14
  
!> Calculate a matrix-vector multiplication associated with mathematical operations in the x, y, and z direction (third dimension of vec_in) with p=14
!! For a matrix-vector multiplication (vec_d_out = Mat_d vec_in where d=x,y,z), the passed variables of Mat_y and Mat_z should be transposed.
!! Note that we assume that vec_in_ has same data as vec_in, but are reshaped via the call of this subroutine. 
!!
!OCL SERIAL
  subroutine element_operation_kernel_matvec_gradlike_dirXYZ_P14( Mat, Mat_tr, vec_in, vec_in_, &
    vec_out_x, vec_out_y, vec_out_z  )
    implicit none
    real(RP), intent(in) :: Mat(15,15)
    real(RP), intent(in) :: Mat_tr(15,15)
    real(RP), intent(in) :: vec_in_(15,15**2)
    real(RP), intent(in) :: vec_in(15,15,15)
    real(RP), intent(out) :: vec_out_x(15,15**2)
    real(RP), intent(out) :: vec_out_y(15,15,15)
    real(RP), intent(out) :: vec_out_z(15,15,15)

    integer :: i, j, k, jk
    !----------------------------------------------------------

    ! X-dir

    do jk=1, 15**2
    do i=1, 15
        vec_out_x(i,jk) = Mat(i,1) * vec_in_(1,jk) &
                        + Mat(i,2) * vec_in_(2,jk) &
                        + Mat(i,3) * vec_in_(3,jk) &
                        + Mat(i,4) * vec_in_(4,jk) &
                        + Mat(i,5) * vec_in_(5,jk) &
                        + Mat(i,6) * vec_in_(6,jk) &
                        + Mat(i,7) * vec_in_(7,jk) &
                        + Mat(i,8) * vec_in_(8,jk) &
                        + Mat(i,9) * vec_in_(9,jk) &
                        + Mat(i,10) * vec_in_(10,jk) &
                        + Mat(i,11) * vec_in_(11,jk) &
                        + Mat(i,12) * vec_in_(12,jk) &
                        + Mat(i,13) * vec_in_(13,jk) &
                        + Mat(i,14) * vec_in_(14,jk) &
                        + Mat(i,15) * vec_in_(15,jk)
    end do
    end do

    ! Y-dir
    do k=1, 15
    do j=1, 15
    do i=1, 15
        vec_out_y(i,j,k) = vec_in(i,1,k) * Mat_tr(1,j) &
                         + vec_in(i,2,k) * Mat_tr(2,j) &
                         + vec_in(i,3,k) * Mat_tr(3,j) &
                         + vec_in(i,4,k) * Mat_tr(4,j) &
                         + vec_in(i,5,k) * Mat_tr(5,j) &
                         + vec_in(i,6,k) * Mat_tr(6,j) &
                         + vec_in(i,7,k) * Mat_tr(7,j) &
                         + vec_in(i,8,k) * Mat_tr(8,j) &
                         + vec_in(i,9,k) * Mat_tr(9,j) &
                         + vec_in(i,10,k) * Mat_tr(10,j) &
                         + vec_in(i,11,k) * Mat_tr(11,j) &
                         + vec_in(i,12,k) * Mat_tr(12,j) &
                         + vec_in(i,13,k) * Mat_tr(13,j) &
                         + vec_in(i,14,k) * Mat_tr(14,j) &
                         + vec_in(i,15,k) * Mat_tr(15,j) 
    end do
    end do
    end do
    
    ! Z-dir
    do k=1, 15
    do j=1, 15
    do i=1, 15
        vec_out_z(i,j,k) = vec_in(i,1,k) * Mat_tr(1,j) &
                         + vec_in(i,j,2) * Mat_tr(2,k) &
                         + vec_in(i,j,3) * Mat_tr(3,k) &
                         + vec_in(i,j,4) * Mat_tr(4,k) &
                         + vec_in(i,j,5) * Mat_tr(5,k) &
                         + vec_in(i,j,6) * Mat_tr(6,k) &
                         + vec_in(i,j,7) * Mat_tr(7,k) &
                         + vec_in(i,j,8) * Mat_tr(8,k) &
                         + vec_in(i,j,9) * Mat_tr(9,k) &
                         + vec_in(i,j,10) * Mat_tr(10,k) &
                         + vec_in(i,j,11) * Mat_tr(11,k) &
                         + vec_in(i,j,12) * Mat_tr(12,k) &
                         + vec_in(i,j,13) * Mat_tr(13,k) &
                         + vec_in(i,j,14) * Mat_tr(14,k) &
                         + vec_in(i,j,15) * Mat_tr(15,k) 
    end do
    end do
    end do

    return
  end subroutine element_operation_kernel_matvec_gradlike_dirXYZ_P14

!> Calculate a matrix-vector multiplication associated with mathematical operations in the x, y, and z direction (third dimension of vec_in) with p=14
!! For a matrix-vector multiplication (vec_d_out = Mat_d vec_d_in where d=x,y,z), the passed variables of Mat_y and Mat_z should be transposed.
!! Note that we assume that vec_in_ has same data as vec_in, but are reshaped via the call of this subroutine. 
!!
!OCL SERIAL
  subroutine element_operation_kernel_matvec_divlike_dirXYZ_P14( &
    Mat, Mat_tr, vec_in_x, vec_in_y, vec_in_z, &
    vec_out_x, vec_out_y, vec_out_z  )
    implicit none
    real(RP), intent(in) :: Mat(15,15)
    real(RP), intent(in) :: Mat_tr(15,15)
    real(RP), intent(in) :: vec_in_x(15,15**2)
    real(RP), intent(in) :: vec_in_y(15,15,15)
    real(RP), intent(in) :: vec_in_z(15,15,15)
    real(RP), intent(out) :: vec_out_x(15,15**2)
    real(RP), intent(out) :: vec_out_y(15,15**2)
    real(RP), intent(out) :: vec_out_z(15,15**2)

    integer :: i, j, k, jk
    real(RP) :: tmp1, tmp2, tmp3
    !----------------------------------------------------------

    ! X-dir

    do jk=1, 15**2
    do i=1, 15
      tmp1 = Mat(i,1) * vec_in_x(1,jk) &
           + Mat(i,2) * vec_in_x(2,jk) &
           + Mat(i,3) * vec_in_x(3,jk) &
           + Mat(i,4) * vec_in_x(4,jk) &
           + Mat(i,5) * vec_in_x(5,jk)
      tmp2 = Mat(i,6) * vec_in_x(6,jk) &
           + Mat(i,7) * vec_in_x(7,jk) &
           + Mat(i,8) * vec_in_x(8,jk) &
           + Mat(i,9) * vec_in_x(9,jk) &
           + Mat(i,10) * vec_in_x(10,jk)
      tmp3 = Mat(i,11) * vec_in_x(11,jk) &
           + Mat(i,12) * vec_in_x(12,jk) &
           + Mat(i,13) * vec_in_x(13,jk) &
           + Mat(i,14) * vec_in_x(14,jk) &
           + Mat(i,15) * vec_in_x(15,jk)
      vec_out_x(i,jk) = tmp1 + tmp2 + tmp3
    end do
    end do

    ! Y-dir
    do k=1, 15
    do j=1, 15
      jk = j + (k-1)*15
      do i=1, 15
        tmp1 = vec_in_y(i,1,k) * Mat_tr(1,j) &
             + vec_in_y(i,2,k) * Mat_tr(2,j) &
             + vec_in_y(i,3,k) * Mat_tr(3,j) &
             + vec_in_y(i,4,k) * Mat_tr(4,j) &
             + vec_in_y(i,5,k) * Mat_tr(5,j) 
        tmp2 = vec_in_y(i,6,k) * Mat_tr(6,j) &
             + vec_in_y(i,7,k) * Mat_tr(7,j) &
             + vec_in_y(i,8,k) * Mat_tr(8,j) &
             + vec_in_y(i,9,k) * Mat_tr(9,j) &
             + vec_in_y(i,10,k) * Mat_tr(10,j) 
        tmp3 = vec_in_y(i,11,k) * Mat_tr(11,j) &
             + vec_in_y(i,12,k) * Mat_tr(12,j) &
             + vec_in_y(i,13,k) * Mat_tr(13,j) &
             + vec_in_y(i,14,k) * Mat_tr(14,j) &
             + vec_in_y(i,15,k) * Mat_tr(15,j) 
      vec_out_y(i,jk) = tmp1 + tmp2 + tmp3
      end do
    end do
    end do
    
    ! Z-dir
    do k=1, 15
    do j=1, 15
      jk = j + (k-1)*15
      do i=1, 15
        tmp1 = vec_in_z(i,j,1) * Mat_tr(1,k) &
             + vec_in_z(i,j,2) * Mat_tr(2,k) &
             + vec_in_z(i,j,3) * Mat_tr(3,k) &
             + vec_in_z(i,j,4) * Mat_tr(4,k) &
             + vec_in_z(i,j,5) * Mat_tr(5,k) 
        tmp2 = vec_in_z(i,j,6) * Mat_tr(6,k) &
             + vec_in_z(i,j,7) * Mat_tr(7,k) &
             + vec_in_z(i,j,8) * Mat_tr(8,k) &
             + vec_in_z(i,j,9) * Mat_tr(9,k) &
             + vec_in_z(i,j,10) * Mat_tr(10,k) 
        tmp3 = vec_in_z(i,j,11) * Mat_tr(11,k) &
             + vec_in_z(i,j,12) * Mat_tr(12,k) &
             + vec_in_z(i,j,13) * Mat_tr(13,k) &
             + vec_in_z(i,j,14) * Mat_tr(14,k) &
             + vec_in_z(i,j,15) * Mat_tr(15,k) 
      vec_out_z(i,jk) = tmp1 + tmp2 + tmp3
      end do
    end do
    end do
    return
  end subroutine element_operation_kernel_matvec_divlike_dirXYZ_P14

!OCL SERIAL
  subroutine element_operation_kernel_matvec_divlike_dirXYZ_var5_P14( &
    Mat, Mat_tr, vec_in_x, vec_in_y, vec_in_z, &
    vec_out_x, vec_out_y, vec_out_z  )
    implicit none
    real(RP), intent(in) :: Mat(15,15)
    real(RP), intent(in) :: Mat_tr(15,15)
    real(RP), intent(in) :: vec_in_x(15,15**2*5)
    real(RP), intent(in) :: vec_in_y(15,15,15*5)
    real(RP), intent(in) :: vec_in_z(15,15,15,5)
    real(RP), intent(out) :: vec_out_x(15,15**2*5)
    real(RP), intent(out) :: vec_out_y(15,15**2*5)
    real(RP), intent(out) :: vec_out_z(15,15**2,5)

    integer :: i, j, k, jkv, jk, v, kv
    real(RP) :: tmp1, tmp2, tmp3
    !----------------------------------------------------------

    ! X-dir

    do jkv=1, 15**2*5
    do i=1, 15
      tmp1 = Mat(i,1) * vec_in_x(1,jkv) &
           + Mat(i,2) * vec_in_x(2,jkv) &
           + Mat(i,3) * vec_in_x(3,jkv) &
           + Mat(i,4) * vec_in_x(4,jkv) &
           + Mat(i,5) * vec_in_x(5,jkv)
      tmp2 = Mat(i,6) * vec_in_x(6,jkv) &
           + Mat(i,7) * vec_in_x(7,jkv) &
           + Mat(i,8) * vec_in_x(8,jkv) &
           + Mat(i,9) * vec_in_x(9,jkv) &
           + Mat(i,10) * vec_in_x(10,jkv)
      tmp3 = Mat(i,11) * vec_in_x(11,jkv) &
           + Mat(i,12) * vec_in_x(12,jkv) &
           + Mat(i,13) * vec_in_x(13,jkv) &
           + Mat(i,14) * vec_in_x(14,jkv) &
           + Mat(i,15) * vec_in_x(15,jkv)
      vec_out_x(i,jkv) = tmp1 + tmp2 + tmp3
    end do
    end do

    ! Y-dir
    do kv=1, 15*5
    do j=1, 15
      jkv = j + (kv-1)*75
      do i=1, 15
        tmp1 = vec_in_y(i,1,kv) * Mat_tr(1,j) &
             + vec_in_y(i,2,kv) * Mat_tr(2,j) &
             + vec_in_y(i,3,kv) * Mat_tr(3,j) &
             + vec_in_y(i,4,kv) * Mat_tr(4,j) &
             + vec_in_y(i,5,kv) * Mat_tr(5,j) 
        tmp2 = vec_in_y(i,6,kv) * Mat_tr(6,j) &
             + vec_in_y(i,7,kv) * Mat_tr(7,j) &
             + vec_in_y(i,8,kv) * Mat_tr(8,j) &
             + vec_in_y(i,9,kv) * Mat_tr(9,j) &
             + vec_in_y(i,10,kv) * Mat_tr(10,j) 
        tmp3 = vec_in_y(i,11,kv) * Mat_tr(11,j) &
             + vec_in_y(i,12,kv) * Mat_tr(12,j) &
             + vec_in_y(i,13,kv) * Mat_tr(13,j) &
             + vec_in_y(i,14,kv) * Mat_tr(14,j) &
             + vec_in_y(i,15,kv) * Mat_tr(15,j) 
      vec_out_y(i,jkv) = tmp1 + tmp2 + tmp3
      end do
    end do
    end do
    
    ! Z-dir
    do v=1, 5
    do k=1, 15
    do j=1, 15
      jk = j + (k-1)*15
      do i=1, 15
        tmp1 = vec_in_z(i,j,1,v) * Mat_tr(1,k) &
             + vec_in_z(i,j,2,v) * Mat_tr(2,k) &
             + vec_in_z(i,j,3,v) * Mat_tr(3,k) &
             + vec_in_z(i,j,4,v) * Mat_tr(4,k) &
             + vec_in_z(i,j,5,v) * Mat_tr(5,k) 
        tmp2 = vec_in_z(i,j,6,v) * Mat_tr(6,k) &
             + vec_in_z(i,j,7,v) * Mat_tr(7,k) &
             + vec_in_z(i,j,8,v) * Mat_tr(8,k) &
             + vec_in_z(i,j,9,v) * Mat_tr(9,k) &
             + vec_in_z(i,j,10,v) * Mat_tr(10,k) 
        tmp3 = vec_in_z(i,j,11,v) * Mat_tr(11,k) &
             + vec_in_z(i,j,12,v) * Mat_tr(12,k) &
             + vec_in_z(i,j,13,v) * Mat_tr(13,k) &
             + vec_in_z(i,j,14,v) * Mat_tr(14,k) &
             + vec_in_z(i,j,15,v) * Mat_tr(15,k) 
      vec_out_z(i,jk,v) = tmp1 + tmp2 + tmp3
      end do
    end do
    end do
    end do
    return
  end subroutine element_operation_kernel_matvec_divlike_dirXYZ_var5_P14

!> Calculate a matrix-vector multiplication associated with 3D modal filtering with p=14
!!
!OCL SERIAL
  subroutine element_operation_kernel_matvec_ModalFilter_P14( Mat_h1D, Mat_h1D_tr, Mat_v1D_tr, vec_in, vec_work, &
    vec_out  )
    implicit none
    real(RP), intent(in) :: Mat_h1D(15,15)
    real(RP), intent(in) :: Mat_h1D_tr(15,15)
    real(RP), intent(in) :: Mat_v1D_tr(15,15)
    real(RP), intent(in) :: vec_in(15,15,15)
    real(RP), intent(out) :: vec_work(15,15,15)
    real(RP), intent(out) :: vec_out(15,15,15)

    integer :: i, j, k
    real(RP) :: tmp1, tmp2, tmp3
    !----------------------------------------------------------

    ! X-dir

    do k=1, 15
    do j=1, 15
    do i=1, 15
      tmp1 = Mat_h1D(i,1) * vec_in(1,j,k) &
           + Mat_h1D(i,2) * vec_in(2,j,k) &
           + Mat_h1D(i,3) * vec_in(3,j,k) &
           + Mat_h1D(i,4) * vec_in(4,j,k) &
           + Mat_h1D(i,5) * vec_in(5,j,k)
      tmp2 = Mat_h1D(i,6) * vec_in(6,j,k) &
           + Mat_h1D(i,7) * vec_in(7,j,k) &
           + Mat_h1D(i,8) * vec_in(8,j,k) &
           + Mat_h1D(i,9) * vec_in(9,j,k) &
           + Mat_h1D(i,10) * vec_in(10,j,k)
      tmp3 = Mat_h1D(i,11) * vec_in(11,j,k) &
           + Mat_h1D(i,12) * vec_in(12,j,k) &
           + Mat_h1D(i,13) * vec_in(13,j,k) &
           + Mat_h1D(i,14) * vec_in(14,j,k) &
           + Mat_h1D(i,15) * vec_in(15,j,k)
      vec_out(i,j,k) = tmp1 + tmp2 + tmp3
    end do
    end do
    end do
    
    ! Y-dir
    do k=1, 15
    do j=1, 15
    do i=1, 15
      tmp1 = vec_out(i,1,k) * Mat_h1D_tr(1,j) &
           + vec_out(i,2,k) * Mat_h1D_tr(2,j) &
           + vec_out(i,3,k) * Mat_h1D_tr(3,j) &
           + vec_out(i,4,k) * Mat_h1D_tr(4,j) &
           + vec_out(i,5,k) * Mat_h1D_tr(5,j) 
      tmp2 = vec_out(i,6,k) * Mat_h1D_tr(6,j) &
           + vec_out(i,7,k) * Mat_h1D_tr(7,j) &
           + vec_out(i,8,k) * Mat_h1D_tr(8,j) &
           + vec_out(i,9,k) * Mat_h1D_tr(9,j) &
           + vec_out(i,10,k) * Mat_h1D_tr(10,j) 
      tmp3 = vec_out(i,11,k) * Mat_h1D_tr(11,j) &
           + vec_out(i,12,k) * Mat_h1D_tr(12,j) &
           + vec_out(i,13,k) * Mat_h1D_tr(13,j) &
           + vec_out(i,14,k) * Mat_h1D_tr(14,j) &
           + vec_out(i,15,k) * Mat_h1D_tr(15,j) 
      vec_work(i,j,k) = tmp1 + tmp2 + tmp3
    end do
    end do
    end do
    
    ! Z-dir
    do k=1, 15
    do j=1, 15
    do i=1, 15
      tmp1 = vec_work(i,j,1) * Mat_v1D_tr(1,k) &
           + vec_work(i,j,2) * Mat_v1D_tr(2,k) &
           + vec_work(i,j,3) * Mat_v1D_tr(3,k) &
           + vec_work(i,j,4) * Mat_v1D_tr(4,k) &
           + vec_work(i,j,5) * Mat_v1D_tr(5,k) 
      tmp2 = vec_work(i,j,6) * Mat_v1D_tr(6,k) &
           + vec_work(i,j,7) * Mat_v1D_tr(7,k) &
           + vec_work(i,j,8) * Mat_v1D_tr(8,k) &
           + vec_work(i,j,9) * Mat_v1D_tr(9,k) &
           + vec_work(i,j,10) * Mat_v1D_tr(10,k) 
      tmp3 = vec_work(i,j,11) * Mat_v1D_tr(11,k) &
           + vec_work(i,j,12) * Mat_v1D_tr(12,k) &
           + vec_work(i,j,13) * Mat_v1D_tr(13,k) &
           + vec_work(i,j,14) * Mat_v1D_tr(14,k) &
           + vec_work(i,j,15) * Mat_v1D_tr(15,k) 
      vec_out(i,j,k) = tmp1 + tmp2 + tmp3
    end do
    end do
    end do

    return
  end subroutine element_operation_kernel_matvec_ModalFilter_P14

!--- For p=15 ------------------------------------

!> Calculate a matrix-vector multiplication associated with mathematical operations in the x direction (first dimension of vec_in) with p=15
!!
!OCL SERIAL
  subroutine element_operation_kernel_matvec_dirX_P15( Mat_x, vec_in, vec_out )
    implicit none
    real(RP), intent(in) :: Mat_x(16,16)
    real(RP), intent(in) :: vec_in(16,16**2)
    real(RP), intent(out) :: vec_out(16,16**2)

    integer :: i, jk
    !----------------------------------------------------------

    do jk=1, 16**2
    do i=1, 16
        vec_out(i,jk) = Mat_x(i,1) * vec_in(1,jk) &
                      + Mat_x(i,2) * vec_in(2,jk) &
                      + Mat_x(i,3) * vec_in(3,jk) &
                      + Mat_x(i,4) * vec_in(4,jk) &
                      + Mat_x(i,5) * vec_in(5,jk) &
                      + Mat_x(i,6) * vec_in(6,jk) &
                      + Mat_x(i,7) * vec_in(7,jk) &
                      + Mat_x(i,8) * vec_in(8,jk) &
                      + Mat_x(i,9) * vec_in(9,jk) &
                      + Mat_x(i,10) * vec_in(10,jk) &
                      + Mat_x(i,11) * vec_in(11,jk) &
                      + Mat_x(i,12) * vec_in(12,jk) &
                      + Mat_x(i,13) * vec_in(13,jk) &
                      + Mat_x(i,14) * vec_in(14,jk) &
                      + Mat_x(i,15) * vec_in(15,jk) &
                      + Mat_x(i,16) * vec_in(16,jk)
    end do
    end do

    return
  end subroutine element_operation_kernel_matvec_dirX_P15

!> Calculate a matrix-vector multiplication associated with mathematical operations in the y direction (second dimension of vec_in) with p=15
!! For a matrix-vector multiplication (vec_out = Mat_y vec_in), the passed variable of Mat_y should be transposed.
!!
!OCL SERIAL
  subroutine element_operation_kernel_matvec_dirY_P15( Mat_y_tr, vec_in, vec_out )
    implicit none
    real(RP), intent(in) :: Mat_y_tr(16,16)
    real(RP), intent(in) :: vec_in(16,16,16)
    real(RP), intent(out) :: vec_out(16,16,16)

    integer :: i, j, k
    !----------------------------------------------------------

    do k=1, 16
    do j=1, 16
    do i=1, 16
        vec_out(i,j,k) = vec_in(i,1,k) * Mat_y_tr(1,j) &
                       + vec_in(i,2,k) * Mat_y_tr(2,j) &
                       + vec_in(i,3,k) * Mat_y_tr(3,j) &
                       + vec_in(i,4,k) * Mat_y_tr(4,j) &
                       + vec_in(i,5,k) * Mat_y_tr(5,j) &
                       + vec_in(i,6,k) * Mat_y_tr(6,j) &
                       + vec_in(i,7,k) * Mat_y_tr(7,j) &
                       + vec_in(i,8,k) * Mat_y_tr(8,j) &
                       + vec_in(i,9,k) * Mat_y_tr(9,j) &
                       + vec_in(i,10,k) * Mat_y_tr(10,j) &
                       + vec_in(i,11,k) * Mat_y_tr(11,j) &
                       + vec_in(i,12,k) * Mat_y_tr(12,j) &
                       + vec_in(i,13,k) * Mat_y_tr(13,j) &
                       + vec_in(i,14,k) * Mat_y_tr(14,j) &
                       + vec_in(i,15,k) * Mat_y_tr(15,j) &
                       + vec_in(i,16,k) * Mat_y_tr(16,j) 
    end do
    end do
    end do

    return
  end subroutine element_operation_kernel_matvec_dirY_P15

!> Calculate a matrix-vector multiplication associated with mathematical operations in the z direction (third dimension of vec_in) with p=15
!! For a matrix-vector multiplication (vec_out = Mat_z vec_in), the passed variable of Mat_z should be transposed.
!!
!OCL SERIAL
  subroutine element_operation_kernel_matvec_dirZ_P15( Mat_z_tr, vec_in, vec_out )
    implicit none
    real(RP), intent(in) :: Mat_z_tr(16,16)
    real(RP), intent(in) :: vec_in(16,16,16)
    real(RP), intent(out) :: vec_out(16,16,16)

    integer :: i, j, k
    !----------------------------------------------------------

    do k=1, 16
    do j=1, 16
    do i=1, 16
        vec_out(i,j,k) = vec_in(i,j,1) * Mat_z_tr(1,k) &
                       + vec_in(i,j,2) * Mat_z_tr(2,k) &
                       + vec_in(i,j,3) * Mat_z_tr(3,k) &
                       + vec_in(i,j,4) * Mat_z_tr(4,k) &
                       + vec_in(i,j,5) * Mat_z_tr(5,k) &
                       + vec_in(i,j,6) * Mat_z_tr(6,k) &
                       + vec_in(i,j,7) * Mat_z_tr(7,k) &
                       + vec_in(i,j,8) * Mat_z_tr(8,k) &
                       + vec_in(i,j,9) * Mat_z_tr(9,k) &
                       + vec_in(i,j,10) * Mat_z_tr(10,k) &
                       + vec_in(i,j,11) * Mat_z_tr(11,k) &
                       + vec_in(i,j,12) * Mat_z_tr(12,k) &
                       + vec_in(i,j,13) * Mat_z_tr(13,k) &
                       + vec_in(i,j,14) * Mat_z_tr(14,k) &
                       + vec_in(i,j,15) * Mat_z_tr(15,k) &
                       + vec_in(i,j,16) * Mat_z_tr(16,k) 
    end do
    end do
    end do

    return
  end subroutine element_operation_kernel_matvec_dirZ_P15

!> Calculate a matrix-vector multiplication with lifting operations for a hexahedral element of order p=15
!!
!OCL SERIAL
  subroutine element_operation_kernel_matvec_Lift_hexahedral_P15( Lift, vec_in, vec_out )
    implicit none
    real(RP), intent(in) :: Lift(16,16,16,6)
    real(RP), intent(in) :: vec_in(16,16,6)
    real(RP), intent(out) :: vec_out(16,16,16)

    integer :: i, j, k
    !----------------------------------------------------------

    do k=1, 16
    do j=1, 16
    do i=1, 16
        vec_out(i,j,k) = Lift(i,j,k,1) * vec_in(i,k,1) &
                       + Lift(i,j,k,2) * vec_in(j,k,2) &
                       + Lift(i,j,k,3) * vec_in(i,k,3) &
                       + Lift(i,j,k,4) * vec_in(j,k,4) &
                       + Lift(i,j,k,5) * vec_in(i,j,5) &
                       + Lift(i,j,k,6) * vec_in(i,j,6)
    end do
    end do
    end do

    return
  end subroutine element_operation_kernel_matvec_Lift_hexahedral_P15
  
!> Calculate a matrix-vector multiplication associated with mathematical operations in the x, y, and z direction (third dimension of vec_in) with p=15
!! For a matrix-vector multiplication (vec_d_out = Mat_d vec_in where d=x,y,z), the passed variables of Mat_y and Mat_z should be transposed.
!! Note that we assume that vec_in_ has same data as vec_in, but are reshaped via the call of this subroutine. 
!!
!OCL SERIAL
  subroutine element_operation_kernel_matvec_gradlike_dirXYZ_P15( Mat, Mat_tr, vec_in, vec_in_, &
    vec_out_x, vec_out_y, vec_out_z  )
    implicit none
    real(RP), intent(in) :: Mat(16,16)
    real(RP), intent(in) :: Mat_tr(16,16)
    real(RP), intent(in) :: vec_in_(16,16**2)
    real(RP), intent(in) :: vec_in(16,16,16)
    real(RP), intent(out) :: vec_out_x(16,16**2)
    real(RP), intent(out) :: vec_out_y(16,16,16)
    real(RP), intent(out) :: vec_out_z(16,16,16)

    integer :: i, j, k, jk
    !----------------------------------------------------------

    ! X-dir

    do jk=1, 16**2
    do i=1, 16
        vec_out_x(i,jk) = Mat(i,1) * vec_in_(1,jk) &
                        + Mat(i,2) * vec_in_(2,jk) &
                        + Mat(i,3) * vec_in_(3,jk) &
                        + Mat(i,4) * vec_in_(4,jk) &
                        + Mat(i,5) * vec_in_(5,jk) &
                        + Mat(i,6) * vec_in_(6,jk) &
                        + Mat(i,7) * vec_in_(7,jk) &
                        + Mat(i,8) * vec_in_(8,jk) &
                        + Mat(i,9) * vec_in_(9,jk) &
                        + Mat(i,10) * vec_in_(10,jk) &
                        + Mat(i,11) * vec_in_(11,jk) &
                        + Mat(i,12) * vec_in_(12,jk) &
                        + Mat(i,13) * vec_in_(13,jk) &
                        + Mat(i,14) * vec_in_(14,jk) &
                        + Mat(i,15) * vec_in_(15,jk) &
                        + Mat(i,16) * vec_in_(16,jk)
    end do
    end do

    ! Y-dir
    do k=1, 16
    do j=1, 16
    do i=1, 16
        vec_out_y(i,j,k) = vec_in(i,1,k) * Mat_tr(1,j) &
                         + vec_in(i,2,k) * Mat_tr(2,j) &
                         + vec_in(i,3,k) * Mat_tr(3,j) &
                         + vec_in(i,4,k) * Mat_tr(4,j) &
                         + vec_in(i,5,k) * Mat_tr(5,j) &
                         + vec_in(i,6,k) * Mat_tr(6,j) &
                         + vec_in(i,7,k) * Mat_tr(7,j) &
                         + vec_in(i,8,k) * Mat_tr(8,j) &
                         + vec_in(i,9,k) * Mat_tr(9,j) &
                         + vec_in(i,10,k) * Mat_tr(10,j) &
                         + vec_in(i,11,k) * Mat_tr(11,j) &
                         + vec_in(i,12,k) * Mat_tr(12,j) &
                         + vec_in(i,13,k) * Mat_tr(13,j) &
                         + vec_in(i,14,k) * Mat_tr(14,j) &
                         + vec_in(i,15,k) * Mat_tr(15,j) &
                         + vec_in(i,16,k) * Mat_tr(16,j) 
    end do
    end do
    end do
    
    ! Z-dir
    do k=1, 16
    do j=1, 16
    do i=1, 16
        vec_out_z(i,j,k) = vec_in(i,1,k) * Mat_tr(1,j) &
                         + vec_in(i,j,2) * Mat_tr(2,k) &
                         + vec_in(i,j,3) * Mat_tr(3,k) &
                         + vec_in(i,j,4) * Mat_tr(4,k) &
                         + vec_in(i,j,5) * Mat_tr(5,k) &
                         + vec_in(i,j,6) * Mat_tr(6,k) &
                         + vec_in(i,j,7) * Mat_tr(7,k) &
                         + vec_in(i,j,8) * Mat_tr(8,k) &
                         + vec_in(i,j,9) * Mat_tr(9,k) &
                         + vec_in(i,j,10) * Mat_tr(10,k) &
                         + vec_in(i,j,11) * Mat_tr(11,k) &
                         + vec_in(i,j,12) * Mat_tr(12,k) &
                         + vec_in(i,j,13) * Mat_tr(13,k) &
                         + vec_in(i,j,14) * Mat_tr(14,k) &
                         + vec_in(i,j,15) * Mat_tr(15,k) &
                         + vec_in(i,j,16) * Mat_tr(16,k) 
    end do
    end do
    end do

    return
  end subroutine element_operation_kernel_matvec_gradlike_dirXYZ_P15

!> Calculate a matrix-vector multiplication associated with mathematical operations in the x, y, and z direction (third dimension of vec_in) with p=15
!! For a matrix-vector multiplication (vec_d_out = Mat_d vec_d_in where d=x,y,z), the passed variables of Mat_y and Mat_z should be transposed.
!! Note that we assume that vec_in_ has same data as vec_in, but are reshaped via the call of this subroutine. 
!!
!OCL SERIAL
  subroutine element_operation_kernel_matvec_divlike_dirXYZ_P15( &
    Mat, Mat_tr, vec_in_x, vec_in_y, vec_in_z, &
    vec_out_x, vec_out_y, vec_out_z  )
    implicit none
    real(RP), intent(in) :: Mat(16,16)
    real(RP), intent(in) :: Mat_tr(16,16)
    real(RP), intent(in) :: vec_in_x(16,16**2)
    real(RP), intent(in) :: vec_in_y(16,16,16)
    real(RP), intent(in) :: vec_in_z(16,16,16)
    real(RP), intent(out) :: vec_out_x(16,16**2)
    real(RP), intent(out) :: vec_out_y(16,16**2)
    real(RP), intent(out) :: vec_out_z(16,16**2)

    integer :: i, j, k, jk
    real(RP) :: tmp1, tmp2, tmp3
    !----------------------------------------------------------

    ! X-dir

    do jk=1, 16**2
    do i=1, 16
      tmp1 = Mat(i,1) * vec_in_x(1,jk) &
           + Mat(i,2) * vec_in_x(2,jk) &
           + Mat(i,3) * vec_in_x(3,jk) &
           + Mat(i,4) * vec_in_x(4,jk) &
           + Mat(i,5) * vec_in_x(5,jk)
      tmp2 = Mat(i,6) * vec_in_x(6,jk) &
           + Mat(i,7) * vec_in_x(7,jk) &
           + Mat(i,8) * vec_in_x(8,jk) &
           + Mat(i,9) * vec_in_x(9,jk) &
           + Mat(i,10) * vec_in_x(10,jk)
      tmp3 = Mat(i,11) * vec_in_x(11,jk) &
           + Mat(i,12) * vec_in_x(12,jk) &
           + Mat(i,13) * vec_in_x(13,jk) &
           + Mat(i,14) * vec_in_x(14,jk) &
           + Mat(i,15) * vec_in_x(15,jk) &
           + Mat(i,16) * vec_in_x(16,jk)
      vec_out_x(i,jk) = tmp1 + tmp2 + tmp3
    end do
    end do

    ! Y-dir
    do k=1, 16
    do j=1, 16
      jk = j + (k-1)*16
      do i=1, 16
        tmp1 = vec_in_y(i,1,k) * Mat_tr(1,j) &
             + vec_in_y(i,2,k) * Mat_tr(2,j) &
             + vec_in_y(i,3,k) * Mat_tr(3,j) &
             + vec_in_y(i,4,k) * Mat_tr(4,j) &
             + vec_in_y(i,5,k) * Mat_tr(5,j) 
        tmp2 = vec_in_y(i,6,k) * Mat_tr(6,j) &
             + vec_in_y(i,7,k) * Mat_tr(7,j) &
             + vec_in_y(i,8,k) * Mat_tr(8,j) &
             + vec_in_y(i,9,k) * Mat_tr(9,j) &
             + vec_in_y(i,10,k) * Mat_tr(10,j) 
        tmp3 = vec_in_y(i,11,k) * Mat_tr(11,j) &
             + vec_in_y(i,12,k) * Mat_tr(12,j) &
             + vec_in_y(i,13,k) * Mat_tr(13,j) &
             + vec_in_y(i,14,k) * Mat_tr(14,j) &
             + vec_in_y(i,15,k) * Mat_tr(15,j) &
             + vec_in_y(i,16,k) * Mat_tr(16,j) 
      vec_out_y(i,jk) = tmp1 + tmp2 + tmp3
      end do
    end do
    end do
    
    ! Z-dir
    do k=1, 16
    do j=1, 16
      jk = j + (k-1)*16
      do i=1, 16
        tmp1 = vec_in_z(i,j,1) * Mat_tr(1,k) &
             + vec_in_z(i,j,2) * Mat_tr(2,k) &
             + vec_in_z(i,j,3) * Mat_tr(3,k) &
             + vec_in_z(i,j,4) * Mat_tr(4,k) &
             + vec_in_z(i,j,5) * Mat_tr(5,k) 
        tmp2 = vec_in_z(i,j,6) * Mat_tr(6,k) &
             + vec_in_z(i,j,7) * Mat_tr(7,k) &
             + vec_in_z(i,j,8) * Mat_tr(8,k) &
             + vec_in_z(i,j,9) * Mat_tr(9,k) &
             + vec_in_z(i,j,10) * Mat_tr(10,k) 
        tmp3 = vec_in_z(i,j,11) * Mat_tr(11,k) &
             + vec_in_z(i,j,12) * Mat_tr(12,k) &
             + vec_in_z(i,j,13) * Mat_tr(13,k) &
             + vec_in_z(i,j,14) * Mat_tr(14,k) &
             + vec_in_z(i,j,15) * Mat_tr(15,k) &
             + vec_in_z(i,j,16) * Mat_tr(16,k) 
      vec_out_z(i,jk) = tmp1 + tmp2 + tmp3
      end do
    end do
    end do
    return
  end subroutine element_operation_kernel_matvec_divlike_dirXYZ_P15

!OCL SERIAL
  subroutine element_operation_kernel_matvec_divlike_dirXYZ_var5_P15( &
    Mat, Mat_tr, vec_in_x, vec_in_y, vec_in_z, &
    vec_out_x, vec_out_y, vec_out_z  )
    implicit none
    real(RP), intent(in) :: Mat(16,16)
    real(RP), intent(in) :: Mat_tr(16,16)
    real(RP), intent(in) :: vec_in_x(16,16**2*5)
    real(RP), intent(in) :: vec_in_y(16,16,16*5)
    real(RP), intent(in) :: vec_in_z(16,16,16,5)
    real(RP), intent(out) :: vec_out_x(16,16**2*5)
    real(RP), intent(out) :: vec_out_y(16,16**2*5)
    real(RP), intent(out) :: vec_out_z(16,16**2,5)

    integer :: i, j, k, jkv, jk, v, kv
    real(RP) :: tmp1, tmp2, tmp3
    !----------------------------------------------------------

    ! X-dir

    do jkv=1, 16**2*5
    do i=1, 16
      tmp1 = Mat(i,1) * vec_in_x(1,jkv) &
           + Mat(i,2) * vec_in_x(2,jkv) &
           + Mat(i,3) * vec_in_x(3,jkv) &
           + Mat(i,4) * vec_in_x(4,jkv) &
           + Mat(i,5) * vec_in_x(5,jkv)
      tmp2 = Mat(i,6) * vec_in_x(6,jkv) &
           + Mat(i,7) * vec_in_x(7,jkv) &
           + Mat(i,8) * vec_in_x(8,jkv) &
           + Mat(i,9) * vec_in_x(9,jkv) &
           + Mat(i,10) * vec_in_x(10,jkv)
      tmp3 = Mat(i,11) * vec_in_x(11,jkv) &
           + Mat(i,12) * vec_in_x(12,jkv) &
           + Mat(i,13) * vec_in_x(13,jkv) &
           + Mat(i,14) * vec_in_x(14,jkv) &
           + Mat(i,15) * vec_in_x(15,jkv) &
           + Mat(i,16) * vec_in_x(16,jkv)
      vec_out_x(i,jkv) = tmp1 + tmp2 + tmp3
    end do
    end do

    ! Y-dir
    do kv=1, 16*5
    do j=1, 16
      jkv = j + (kv-1)*80
      do i=1, 16
        tmp1 = vec_in_y(i,1,kv) * Mat_tr(1,j) &
             + vec_in_y(i,2,kv) * Mat_tr(2,j) &
             + vec_in_y(i,3,kv) * Mat_tr(3,j) &
             + vec_in_y(i,4,kv) * Mat_tr(4,j) &
             + vec_in_y(i,5,kv) * Mat_tr(5,j) 
        tmp2 = vec_in_y(i,6,kv) * Mat_tr(6,j) &
             + vec_in_y(i,7,kv) * Mat_tr(7,j) &
             + vec_in_y(i,8,kv) * Mat_tr(8,j) &
             + vec_in_y(i,9,kv) * Mat_tr(9,j) &
             + vec_in_y(i,10,kv) * Mat_tr(10,j) 
        tmp3 = vec_in_y(i,11,kv) * Mat_tr(11,j) &
             + vec_in_y(i,12,kv) * Mat_tr(12,j) &
             + vec_in_y(i,13,kv) * Mat_tr(13,j) &
             + vec_in_y(i,14,kv) * Mat_tr(14,j) &
             + vec_in_y(i,15,kv) * Mat_tr(15,j) &
             + vec_in_y(i,16,kv) * Mat_tr(16,j) 
      vec_out_y(i,jkv) = tmp1 + tmp2 + tmp3
      end do
    end do
    end do
    
    ! Z-dir
    do v=1, 5
    do k=1, 16
    do j=1, 16
      jk = j + (k-1)*16
      do i=1, 16
        tmp1 = vec_in_z(i,j,1,v) * Mat_tr(1,k) &
             + vec_in_z(i,j,2,v) * Mat_tr(2,k) &
             + vec_in_z(i,j,3,v) * Mat_tr(3,k) &
             + vec_in_z(i,j,4,v) * Mat_tr(4,k) &
             + vec_in_z(i,j,5,v) * Mat_tr(5,k) 
        tmp2 = vec_in_z(i,j,6,v) * Mat_tr(6,k) &
             + vec_in_z(i,j,7,v) * Mat_tr(7,k) &
             + vec_in_z(i,j,8,v) * Mat_tr(8,k) &
             + vec_in_z(i,j,9,v) * Mat_tr(9,k) &
             + vec_in_z(i,j,10,v) * Mat_tr(10,k) 
        tmp3 = vec_in_z(i,j,11,v) * Mat_tr(11,k) &
             + vec_in_z(i,j,12,v) * Mat_tr(12,k) &
             + vec_in_z(i,j,13,v) * Mat_tr(13,k) &
             + vec_in_z(i,j,14,v) * Mat_tr(14,k) &
             + vec_in_z(i,j,15,v) * Mat_tr(15,k) &
             + vec_in_z(i,j,16,v) * Mat_tr(16,k) 
      vec_out_z(i,jk,v) = tmp1 + tmp2 + tmp3
      end do
    end do
    end do
    end do
    return
  end subroutine element_operation_kernel_matvec_divlike_dirXYZ_var5_P15

!> Calculate a matrix-vector multiplication associated with 3D modal filtering with p=15
!!
!OCL SERIAL
  subroutine element_operation_kernel_matvec_ModalFilter_P15( Mat_h1D, Mat_h1D_tr, Mat_v1D_tr, vec_in, vec_work, &
    vec_out  )
    implicit none
    real(RP), intent(in) :: Mat_h1D(16,16)
    real(RP), intent(in) :: Mat_h1D_tr(16,16)
    real(RP), intent(in) :: Mat_v1D_tr(16,16)
    real(RP), intent(in) :: vec_in(16,16,16)
    real(RP), intent(out) :: vec_work(16,16,16)
    real(RP), intent(out) :: vec_out(16,16,16)

    integer :: i, j, k
    real(RP) :: tmp1, tmp2, tmp3
    !----------------------------------------------------------

    ! X-dir

    do k=1, 16
    do j=1, 16
    do i=1, 16
      tmp1 = Mat_h1D(i,1) * vec_in(1,j,k) &
           + Mat_h1D(i,2) * vec_in(2,j,k) &
           + Mat_h1D(i,3) * vec_in(3,j,k) &
           + Mat_h1D(i,4) * vec_in(4,j,k) &
           + Mat_h1D(i,5) * vec_in(5,j,k)
      tmp2 = Mat_h1D(i,6) * vec_in(6,j,k) &
           + Mat_h1D(i,7) * vec_in(7,j,k) &
           + Mat_h1D(i,8) * vec_in(8,j,k) &
           + Mat_h1D(i,9) * vec_in(9,j,k) &
           + Mat_h1D(i,10) * vec_in(10,j,k)
      tmp3 = Mat_h1D(i,11) * vec_in(11,j,k) &
           + Mat_h1D(i,12) * vec_in(12,j,k) &
           + Mat_h1D(i,13) * vec_in(13,j,k) &
           + Mat_h1D(i,14) * vec_in(14,j,k) &
           + Mat_h1D(i,15) * vec_in(15,j,k) &
           + Mat_h1D(i,16) * vec_in(16,j,k)
      vec_out(i,j,k) = tmp1 + tmp2 + tmp3
    end do
    end do
    end do
    
    ! Y-dir
    do k=1, 16
    do j=1, 16
    do i=1, 16
      tmp1 = vec_out(i,1,k) * Mat_h1D_tr(1,j) &
           + vec_out(i,2,k) * Mat_h1D_tr(2,j) &
           + vec_out(i,3,k) * Mat_h1D_tr(3,j) &
           + vec_out(i,4,k) * Mat_h1D_tr(4,j) &
           + vec_out(i,5,k) * Mat_h1D_tr(5,j) 
      tmp2 = vec_out(i,6,k) * Mat_h1D_tr(6,j) &
           + vec_out(i,7,k) * Mat_h1D_tr(7,j) &
           + vec_out(i,8,k) * Mat_h1D_tr(8,j) &
           + vec_out(i,9,k) * Mat_h1D_tr(9,j) &
           + vec_out(i,10,k) * Mat_h1D_tr(10,j) 
      tmp3 = vec_out(i,11,k) * Mat_h1D_tr(11,j) &
           + vec_out(i,12,k) * Mat_h1D_tr(12,j) &
           + vec_out(i,13,k) * Mat_h1D_tr(13,j) &
           + vec_out(i,14,k) * Mat_h1D_tr(14,j) &
           + vec_out(i,15,k) * Mat_h1D_tr(15,j) &
           + vec_out(i,16,k) * Mat_h1D_tr(16,j) 
      vec_work(i,j,k) = tmp1 + tmp2 + tmp3
    end do
    end do
    end do
    
    ! Z-dir
    do k=1, 16
    do j=1, 16
    do i=1, 16
      tmp1 = vec_work(i,j,1) * Mat_v1D_tr(1,k) &
           + vec_work(i,j,2) * Mat_v1D_tr(2,k) &
           + vec_work(i,j,3) * Mat_v1D_tr(3,k) &
           + vec_work(i,j,4) * Mat_v1D_tr(4,k) &
           + vec_work(i,j,5) * Mat_v1D_tr(5,k) 
      tmp2 = vec_work(i,j,6) * Mat_v1D_tr(6,k) &
           + vec_work(i,j,7) * Mat_v1D_tr(7,k) &
           + vec_work(i,j,8) * Mat_v1D_tr(8,k) &
           + vec_work(i,j,9) * Mat_v1D_tr(9,k) &
           + vec_work(i,j,10) * Mat_v1D_tr(10,k) 
      tmp3 = vec_work(i,j,11) * Mat_v1D_tr(11,k) &
           + vec_work(i,j,12) * Mat_v1D_tr(12,k) &
           + vec_work(i,j,13) * Mat_v1D_tr(13,k) &
           + vec_work(i,j,14) * Mat_v1D_tr(14,k) &
           + vec_work(i,j,15) * Mat_v1D_tr(15,k) &
           + vec_work(i,j,16) * Mat_v1D_tr(16,k) 
      vec_out(i,j,k) = tmp1 + tmp2 + tmp3
    end do
    end do
    end do

    return
  end subroutine element_operation_kernel_matvec_ModalFilter_P15


end module scale_element_operation_tensorprod3D_kernel