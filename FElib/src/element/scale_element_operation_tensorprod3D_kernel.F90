
!-------------------------------------------------------------------------------
! Warning: This file was generated from element/scale_element_operation_tensorprod3D_kernel.F90.erb.
!          Do not edit this file.
!-------------------------------------------------------------------------------
!-------------------------------------------------------------------------------
!> module FElib / Element / Operation with 3D tensor product elements
!!
!! @par Description
!!           A module for providing kernels of matrix and vector operations assuming a 3D tensor product element with (p+1)^3 DOF
!!
!! @author Yuta Kawai, Xuanzhengbo Ren, and Team SCALE
!!
!<
#include "scaleFElib.h"
module scale_element_operation_tensorprod3D_kernel

  !-----------------------------------------------------------------------------
  !
  !++ used modules
  !
  use scale_precision

  use scale_element_base, only: &
    ElementBase3D, &
    ElementBase3D_Init, ElementBase3D_Final
  !-----------------------------------------------------------------------------
  implicit none
  private

  !-----------------------------------------------------------------------------
  !
  !++ Public type & procedure
  !  
  public :: element_operation_tensorprod3D_kernel_matrix_vec_dirX_P1
  public :: element_operation_tensorprod3D_kernel_matrix_vec_dirY_P1  
  public :: element_operation_tensorprod3D_kernel_matrix_vec_dirZ_P1
  public :: element_operation_tensorprod3D_kernel_matrix_vec_gradlike_dirXYZ_P1
  public :: element_operation_tensorprod3D_kernel_matrix_vec_dirX_P2
  public :: element_operation_tensorprod3D_kernel_matrix_vec_dirY_P2  
  public :: element_operation_tensorprod3D_kernel_matrix_vec_dirZ_P2
  public :: element_operation_tensorprod3D_kernel_matrix_vec_gradlike_dirXYZ_P2
  public :: element_operation_tensorprod3D_kernel_matrix_vec_dirX_P3
  public :: element_operation_tensorprod3D_kernel_matrix_vec_dirY_P3  
  public :: element_operation_tensorprod3D_kernel_matrix_vec_dirZ_P3
  public :: element_operation_tensorprod3D_kernel_matrix_vec_gradlike_dirXYZ_P3
  public :: element_operation_tensorprod3D_kernel_matrix_vec_dirX_P4
  public :: element_operation_tensorprod3D_kernel_matrix_vec_dirY_P4  
  public :: element_operation_tensorprod3D_kernel_matrix_vec_dirZ_P4
  public :: element_operation_tensorprod3D_kernel_matrix_vec_gradlike_dirXYZ_P4
  public :: element_operation_tensorprod3D_kernel_matrix_vec_dirX_P5
  public :: element_operation_tensorprod3D_kernel_matrix_vec_dirY_P5  
  public :: element_operation_tensorprod3D_kernel_matrix_vec_dirZ_P5
  public :: element_operation_tensorprod3D_kernel_matrix_vec_gradlike_dirXYZ_P5
  public :: element_operation_tensorprod3D_kernel_matrix_vec_dirX_P6
  public :: element_operation_tensorprod3D_kernel_matrix_vec_dirY_P6  
  public :: element_operation_tensorprod3D_kernel_matrix_vec_dirZ_P6
  public :: element_operation_tensorprod3D_kernel_matrix_vec_gradlike_dirXYZ_P6
  public :: element_operation_tensorprod3D_kernel_matrix_vec_dirX_P7
  public :: element_operation_tensorprod3D_kernel_matrix_vec_dirY_P7  
  public :: element_operation_tensorprod3D_kernel_matrix_vec_dirZ_P7
  public :: element_operation_tensorprod3D_kernel_matrix_vec_gradlike_dirXYZ_P7
  public :: element_operation_tensorprod3D_kernel_matrix_vec_dirX_P8
  public :: element_operation_tensorprod3D_kernel_matrix_vec_dirY_P8  
  public :: element_operation_tensorprod3D_kernel_matrix_vec_dirZ_P8
  public :: element_operation_tensorprod3D_kernel_matrix_vec_gradlike_dirXYZ_P8
  public :: element_operation_tensorprod3D_kernel_matrix_vec_dirX_P9
  public :: element_operation_tensorprod3D_kernel_matrix_vec_dirY_P9  
  public :: element_operation_tensorprod3D_kernel_matrix_vec_dirZ_P9
  public :: element_operation_tensorprod3D_kernel_matrix_vec_gradlike_dirXYZ_P9
  public :: element_operation_tensorprod3D_kernel_matrix_vec_dirX_P10
  public :: element_operation_tensorprod3D_kernel_matrix_vec_dirY_P10  
  public :: element_operation_tensorprod3D_kernel_matrix_vec_dirZ_P10
  public :: element_operation_tensorprod3D_kernel_matrix_vec_gradlike_dirXYZ_P10
  public :: element_operation_tensorprod3D_kernel_matrix_vec_dirX_P11
  public :: element_operation_tensorprod3D_kernel_matrix_vec_dirY_P11  
  public :: element_operation_tensorprod3D_kernel_matrix_vec_dirZ_P11
  public :: element_operation_tensorprod3D_kernel_matrix_vec_gradlike_dirXYZ_P11
  public :: element_operation_tensorprod3D_kernel_matrix_vec_dirX_P12
  public :: element_operation_tensorprod3D_kernel_matrix_vec_dirY_P12  
  public :: element_operation_tensorprod3D_kernel_matrix_vec_dirZ_P12
  public :: element_operation_tensorprod3D_kernel_matrix_vec_gradlike_dirXYZ_P12
  public :: element_operation_tensorprod3D_kernel_matrix_vec_dirX_P13
  public :: element_operation_tensorprod3D_kernel_matrix_vec_dirY_P13  
  public :: element_operation_tensorprod3D_kernel_matrix_vec_dirZ_P13
  public :: element_operation_tensorprod3D_kernel_matrix_vec_gradlike_dirXYZ_P13

contains

!> Calculate a matrix-vector multiplication associated with mathematical operations in the x direction (first dimension of vec_in) with p=1
!!
!OCL SERIAL
  subroutine element_operation_tensorprod3D_kernel_matrix_vec_dirX_P1( Mat_x, vec_in, vec_out )
    implicit none
    real(RP), intent(in) :: Mat_x(2,2)
    real(RP), intent(in) :: vec_in(2,2**2)
    real(RP), intent(out) :: vec_out(2,2**2)

    integer :: i, jk
    !----------------------------------------------------------

    do jk=1, 2**2
    do i=1, 2
        vec_out(i,jk) = Mat_x(i,1) * vec_in(1,jk) &
                      + Mat_x(i,2) * vec_in(2,jk)
    end do
    end do

    return
  end subroutine element_operation_tensorprod3D_kernel_matrix_vec_dirX_P1

!> Calculate a matrix-vector multiplication associated with mathematical operations in the x direction (first dimension of vec_in) with p=2
!!
!OCL SERIAL
  subroutine element_operation_tensorprod3D_kernel_matrix_vec_dirX_P2( Mat_x, vec_in, vec_out )
    implicit none
    real(RP), intent(in) :: Mat_x(3,3)
    real(RP), intent(in) :: vec_in(3,3**2)
    real(RP), intent(out) :: vec_out(3,3**2)

    integer :: i, jk
    !----------------------------------------------------------

    do jk=1, 3**2
    do i=1, 3
        vec_out(i,jk) = Mat_x(i,1) * vec_in(1,jk) &
                      + Mat_x(i,2) * vec_in(2,jk) &
                      + Mat_x(i,3) * vec_in(3,jk)
    end do
    end do

    return
  end subroutine element_operation_tensorprod3D_kernel_matrix_vec_dirX_P2

!> Calculate a matrix-vector multiplication associated with mathematical operations in the x direction (first dimension of vec_in) with p=3
!!
!OCL SERIAL
  subroutine element_operation_tensorprod3D_kernel_matrix_vec_dirX_P3( Mat_x, vec_in, vec_out )
    implicit none
    real(RP), intent(in) :: Mat_x(4,4)
    real(RP), intent(in) :: vec_in(4,4**2)
    real(RP), intent(out) :: vec_out(4,4**2)

    integer :: i, jk
    !----------------------------------------------------------

    do jk=1, 4**2
    do i=1, 4
        vec_out(i,jk) = Mat_x(i,1) * vec_in(1,jk) &
                      + Mat_x(i,2) * vec_in(2,jk) &
                      + Mat_x(i,3) * vec_in(3,jk) &
                      + Mat_x(i,4) * vec_in(4,jk)
    end do
    end do

    return
  end subroutine element_operation_tensorprod3D_kernel_matrix_vec_dirX_P3

!> Calculate a matrix-vector multiplication associated with mathematical operations in the x direction (first dimension of vec_in) with p=4
!!
!OCL SERIAL
  subroutine element_operation_tensorprod3D_kernel_matrix_vec_dirX_P4( Mat_x, vec_in, vec_out )
    implicit none
    real(RP), intent(in) :: Mat_x(5,5)
    real(RP), intent(in) :: vec_in(5,5**2)
    real(RP), intent(out) :: vec_out(5,5**2)

    integer :: i, jk
    !----------------------------------------------------------

    do jk=1, 5**2
    do i=1, 5
        vec_out(i,jk) = Mat_x(i,1) * vec_in(1,jk) &
                      + Mat_x(i,2) * vec_in(2,jk) &
                      + Mat_x(i,3) * vec_in(3,jk) &
                      + Mat_x(i,4) * vec_in(4,jk) &
                      + Mat_x(i,5) * vec_in(5,jk)
    end do
    end do

    return
  end subroutine element_operation_tensorprod3D_kernel_matrix_vec_dirX_P4

!> Calculate a matrix-vector multiplication associated with mathematical operations in the x direction (first dimension of vec_in) with p=5
!!
!OCL SERIAL
  subroutine element_operation_tensorprod3D_kernel_matrix_vec_dirX_P5( Mat_x, vec_in, vec_out )
    implicit none
    real(RP), intent(in) :: Mat_x(6,6)
    real(RP), intent(in) :: vec_in(6,6**2)
    real(RP), intent(out) :: vec_out(6,6**2)

    integer :: i, jk
    !----------------------------------------------------------

    do jk=1, 6**2
    do i=1, 6
        vec_out(i,jk) = Mat_x(i,1) * vec_in(1,jk) &
                      + Mat_x(i,2) * vec_in(2,jk) &
                      + Mat_x(i,3) * vec_in(3,jk) &
                      + Mat_x(i,4) * vec_in(4,jk) &
                      + Mat_x(i,5) * vec_in(5,jk) &
                      + Mat_x(i,6) * vec_in(6,jk)
    end do
    end do

    return
  end subroutine element_operation_tensorprod3D_kernel_matrix_vec_dirX_P5

!> Calculate a matrix-vector multiplication associated with mathematical operations in the x direction (first dimension of vec_in) with p=6
!!
!OCL SERIAL
  subroutine element_operation_tensorprod3D_kernel_matrix_vec_dirX_P6( Mat_x, vec_in, vec_out )
    implicit none
    real(RP), intent(in) :: Mat_x(7,7)
    real(RP), intent(in) :: vec_in(7,7**2)
    real(RP), intent(out) :: vec_out(7,7**2)

    integer :: i, jk
    !----------------------------------------------------------

    do jk=1, 7**2
    do i=1, 7
        vec_out(i,jk) = Mat_x(i,1) * vec_in(1,jk) &
                      + Mat_x(i,2) * vec_in(2,jk) &
                      + Mat_x(i,3) * vec_in(3,jk) &
                      + Mat_x(i,4) * vec_in(4,jk) &
                      + Mat_x(i,5) * vec_in(5,jk) &
                      + Mat_x(i,6) * vec_in(6,jk) &
                      + Mat_x(i,7) * vec_in(7,jk)
    end do
    end do

    return
  end subroutine element_operation_tensorprod3D_kernel_matrix_vec_dirX_P6

!> Calculate a matrix-vector multiplication associated with mathematical operations in the x direction (first dimension of vec_in) with p=7
!!
!OCL SERIAL
  subroutine element_operation_tensorprod3D_kernel_matrix_vec_dirX_P7( Mat_x, vec_in, vec_out )
    implicit none
    real(RP), intent(in) :: Mat_x(8,8)
    real(RP), intent(in) :: vec_in(8,8**2)
    real(RP), intent(out) :: vec_out(8,8**2)

    integer :: i, jk
    !----------------------------------------------------------

    do jk=1, 8**2
    do i=1, 8
        vec_out(i,jk) = Mat_x(i,1) * vec_in(1,jk) &
                      + Mat_x(i,2) * vec_in(2,jk) &
                      + Mat_x(i,3) * vec_in(3,jk) &
                      + Mat_x(i,4) * vec_in(4,jk) &
                      + Mat_x(i,5) * vec_in(5,jk) &
                      + Mat_x(i,6) * vec_in(6,jk) &
                      + Mat_x(i,7) * vec_in(7,jk) &
                      + Mat_x(i,8) * vec_in(8,jk)
    end do
    end do

    return
  end subroutine element_operation_tensorprod3D_kernel_matrix_vec_dirX_P7

!> Calculate a matrix-vector multiplication associated with mathematical operations in the x direction (first dimension of vec_in) with p=8
!!
!OCL SERIAL
  subroutine element_operation_tensorprod3D_kernel_matrix_vec_dirX_P8( Mat_x, vec_in, vec_out )
    implicit none
    real(RP), intent(in) :: Mat_x(9,9)
    real(RP), intent(in) :: vec_in(9,9**2)
    real(RP), intent(out) :: vec_out(9,9**2)

    integer :: i, jk
    !----------------------------------------------------------

    do jk=1, 9**2
    do i=1, 9
        vec_out(i,jk) = Mat_x(i,1) * vec_in(1,jk) &
                      + Mat_x(i,2) * vec_in(2,jk) &
                      + Mat_x(i,3) * vec_in(3,jk) &
                      + Mat_x(i,4) * vec_in(4,jk) &
                      + Mat_x(i,5) * vec_in(5,jk) &
                      + Mat_x(i,6) * vec_in(6,jk) &
                      + Mat_x(i,7) * vec_in(7,jk) &
                      + Mat_x(i,8) * vec_in(8,jk) &
                      + Mat_x(i,9) * vec_in(9,jk)
    end do
    end do

    return
  end subroutine element_operation_tensorprod3D_kernel_matrix_vec_dirX_P8

!> Calculate a matrix-vector multiplication associated with mathematical operations in the x direction (first dimension of vec_in) with p=9
!!
!OCL SERIAL
  subroutine element_operation_tensorprod3D_kernel_matrix_vec_dirX_P9( Mat_x, vec_in, vec_out )
    implicit none
    real(RP), intent(in) :: Mat_x(10,10)
    real(RP), intent(in) :: vec_in(10,10**2)
    real(RP), intent(out) :: vec_out(10,10**2)

    integer :: i, jk
    !----------------------------------------------------------

    do jk=1, 10**2
    do i=1, 10
        vec_out(i,jk) = Mat_x(i,1) * vec_in(1,jk) &
                      + Mat_x(i,2) * vec_in(2,jk) &
                      + Mat_x(i,3) * vec_in(3,jk) &
                      + Mat_x(i,4) * vec_in(4,jk) &
                      + Mat_x(i,5) * vec_in(5,jk) &
                      + Mat_x(i,6) * vec_in(6,jk) &
                      + Mat_x(i,7) * vec_in(7,jk) &
                      + Mat_x(i,8) * vec_in(8,jk) &
                      + Mat_x(i,9) * vec_in(9,jk) &
                      + Mat_x(i,10) * vec_in(10,jk)
    end do
    end do

    return
  end subroutine element_operation_tensorprod3D_kernel_matrix_vec_dirX_P9

!> Calculate a matrix-vector multiplication associated with mathematical operations in the x direction (first dimension of vec_in) with p=10
!!
!OCL SERIAL
  subroutine element_operation_tensorprod3D_kernel_matrix_vec_dirX_P10( Mat_x, vec_in, vec_out )
    implicit none
    real(RP), intent(in) :: Mat_x(11,11)
    real(RP), intent(in) :: vec_in(11,11**2)
    real(RP), intent(out) :: vec_out(11,11**2)

    integer :: i, jk
    !----------------------------------------------------------

    do jk=1, 11**2
    do i=1, 11
        vec_out(i,jk) = Mat_x(i,1) * vec_in(1,jk) &
                      + Mat_x(i,2) * vec_in(2,jk) &
                      + Mat_x(i,3) * vec_in(3,jk) &
                      + Mat_x(i,4) * vec_in(4,jk) &
                      + Mat_x(i,5) * vec_in(5,jk) &
                      + Mat_x(i,6) * vec_in(6,jk) &
                      + Mat_x(i,7) * vec_in(7,jk) &
                      + Mat_x(i,8) * vec_in(8,jk) &
                      + Mat_x(i,9) * vec_in(9,jk) &
                      + Mat_x(i,10) * vec_in(10,jk) &
                      + Mat_x(i,11) * vec_in(11,jk)
    end do
    end do

    return
  end subroutine element_operation_tensorprod3D_kernel_matrix_vec_dirX_P10

!> Calculate a matrix-vector multiplication associated with mathematical operations in the x direction (first dimension of vec_in) with p=11
!!
!OCL SERIAL
  subroutine element_operation_tensorprod3D_kernel_matrix_vec_dirX_P11( Mat_x, vec_in, vec_out )
    implicit none
    real(RP), intent(in) :: Mat_x(12,12)
    real(RP), intent(in) :: vec_in(12,12**2)
    real(RP), intent(out) :: vec_out(12,12**2)

    integer :: i, jk
    !----------------------------------------------------------

    do jk=1, 12**2
    do i=1, 12
        vec_out(i,jk) = Mat_x(i,1) * vec_in(1,jk) &
                      + Mat_x(i,2) * vec_in(2,jk) &
                      + Mat_x(i,3) * vec_in(3,jk) &
                      + Mat_x(i,4) * vec_in(4,jk) &
                      + Mat_x(i,5) * vec_in(5,jk) &
                      + Mat_x(i,6) * vec_in(6,jk) &
                      + Mat_x(i,7) * vec_in(7,jk) &
                      + Mat_x(i,8) * vec_in(8,jk) &
                      + Mat_x(i,9) * vec_in(9,jk) &
                      + Mat_x(i,10) * vec_in(10,jk) &
                      + Mat_x(i,11) * vec_in(11,jk) &
                      + Mat_x(i,12) * vec_in(12,jk)
    end do
    end do

    return
  end subroutine element_operation_tensorprod3D_kernel_matrix_vec_dirX_P11

!> Calculate a matrix-vector multiplication associated with mathematical operations in the x direction (first dimension of vec_in) with p=12
!!
!OCL SERIAL
  subroutine element_operation_tensorprod3D_kernel_matrix_vec_dirX_P12( Mat_x, vec_in, vec_out )
    implicit none
    real(RP), intent(in) :: Mat_x(13,13)
    real(RP), intent(in) :: vec_in(13,13**2)
    real(RP), intent(out) :: vec_out(13,13**2)

    integer :: i, jk
    !----------------------------------------------------------

    do jk=1, 13**2
    do i=1, 13
        vec_out(i,jk) = Mat_x(i,1) * vec_in(1,jk) &
                      + Mat_x(i,2) * vec_in(2,jk) &
                      + Mat_x(i,3) * vec_in(3,jk) &
                      + Mat_x(i,4) * vec_in(4,jk) &
                      + Mat_x(i,5) * vec_in(5,jk) &
                      + Mat_x(i,6) * vec_in(6,jk) &
                      + Mat_x(i,7) * vec_in(7,jk) &
                      + Mat_x(i,8) * vec_in(8,jk) &
                      + Mat_x(i,9) * vec_in(9,jk) &
                      + Mat_x(i,10) * vec_in(10,jk) &
                      + Mat_x(i,11) * vec_in(11,jk) &
                      + Mat_x(i,12) * vec_in(12,jk) &
                      + Mat_x(i,13) * vec_in(13,jk)
    end do
    end do

    return
  end subroutine element_operation_tensorprod3D_kernel_matrix_vec_dirX_P12

!> Calculate a matrix-vector multiplication associated with mathematical operations in the x direction (first dimension of vec_in) with p=13
!!
!OCL SERIAL
  subroutine element_operation_tensorprod3D_kernel_matrix_vec_dirX_P13( Mat_x, vec_in, vec_out )
    implicit none
    real(RP), intent(in) :: Mat_x(14,14)
    real(RP), intent(in) :: vec_in(14,14**2)
    real(RP), intent(out) :: vec_out(14,14**2)

    integer :: i, jk
    !----------------------------------------------------------

    do jk=1, 14**2
    do i=1, 14
        vec_out(i,jk) = Mat_x(i,1) * vec_in(1,jk) &
                      + Mat_x(i,2) * vec_in(2,jk) &
                      + Mat_x(i,3) * vec_in(3,jk) &
                      + Mat_x(i,4) * vec_in(4,jk) &
                      + Mat_x(i,5) * vec_in(5,jk) &
                      + Mat_x(i,6) * vec_in(6,jk) &
                      + Mat_x(i,7) * vec_in(7,jk) &
                      + Mat_x(i,8) * vec_in(8,jk) &
                      + Mat_x(i,9) * vec_in(9,jk) &
                      + Mat_x(i,10) * vec_in(10,jk) &
                      + Mat_x(i,11) * vec_in(11,jk) &
                      + Mat_x(i,12) * vec_in(12,jk) &
                      + Mat_x(i,13) * vec_in(13,jk) &
                      + Mat_x(i,14) * vec_in(14,jk)
    end do
    end do

    return
  end subroutine element_operation_tensorprod3D_kernel_matrix_vec_dirX_P13
!-------------------------------------------------------------


!> Calculate a matrix-vector multiplication associated with mathematical operations in the y direction (second dimension of vec_in) with p=1
!! For a matrix-vector multiplication (vec_out = Mat_y vec_in), the passed variable of Mat_y should be transposed.
!!
!OCL SERIAL
  subroutine element_operation_tensorprod3D_kernel_matrix_vec_dirY_P1( Mat_y_tr, vec_in, vec_out )
    implicit none
    real(RP), intent(in) :: Mat_y_tr(2,2)
    real(RP), intent(in) :: vec_in(2,2,2)
    real(RP), intent(out) :: vec_out(2,2,2)

    integer :: i, j, k
    !----------------------------------------------------------

    do k=1, 2
    do j=1, 2
    do i=1, 2
        vec_out(i,j,k) = vec_in(i,1,k) * Mat_y_tr(1,j) &
                       + vec_in(i,2,k) * Mat_y_tr(2,j) 
    end do
    end do
    end do

    return
  end subroutine element_operation_tensorprod3D_kernel_matrix_vec_dirY_P1

!> Calculate a matrix-vector multiplication associated with mathematical operations in the y direction (second dimension of vec_in) with p=2
!! For a matrix-vector multiplication (vec_out = Mat_y vec_in), the passed variable of Mat_y should be transposed.
!!
!OCL SERIAL
  subroutine element_operation_tensorprod3D_kernel_matrix_vec_dirY_P2( Mat_y_tr, vec_in, vec_out )
    implicit none
    real(RP), intent(in) :: Mat_y_tr(3,3)
    real(RP), intent(in) :: vec_in(3,3,3)
    real(RP), intent(out) :: vec_out(3,3,3)

    integer :: i, j, k
    !----------------------------------------------------------

    do k=1, 3
    do j=1, 3
    do i=1, 3
        vec_out(i,j,k) = vec_in(i,1,k) * Mat_y_tr(1,j) &
                       + vec_in(i,2,k) * Mat_y_tr(2,j) &
                       + vec_in(i,3,k) * Mat_y_tr(3,j) 
    end do
    end do
    end do

    return
  end subroutine element_operation_tensorprod3D_kernel_matrix_vec_dirY_P2

!> Calculate a matrix-vector multiplication associated with mathematical operations in the y direction (second dimension of vec_in) with p=3
!! For a matrix-vector multiplication (vec_out = Mat_y vec_in), the passed variable of Mat_y should be transposed.
!!
!OCL SERIAL
  subroutine element_operation_tensorprod3D_kernel_matrix_vec_dirY_P3( Mat_y_tr, vec_in, vec_out )
    implicit none
    real(RP), intent(in) :: Mat_y_tr(4,4)
    real(RP), intent(in) :: vec_in(4,4,4)
    real(RP), intent(out) :: vec_out(4,4,4)

    integer :: i, j, k
    !----------------------------------------------------------

    do k=1, 4
    do j=1, 4
    do i=1, 4
        vec_out(i,j,k) = vec_in(i,1,k) * Mat_y_tr(1,j) &
                       + vec_in(i,2,k) * Mat_y_tr(2,j) &
                       + vec_in(i,3,k) * Mat_y_tr(3,j) &
                       + vec_in(i,4,k) * Mat_y_tr(4,j) 
    end do
    end do
    end do

    return
  end subroutine element_operation_tensorprod3D_kernel_matrix_vec_dirY_P3

!> Calculate a matrix-vector multiplication associated with mathematical operations in the y direction (second dimension of vec_in) with p=4
!! For a matrix-vector multiplication (vec_out = Mat_y vec_in), the passed variable of Mat_y should be transposed.
!!
!OCL SERIAL
  subroutine element_operation_tensorprod3D_kernel_matrix_vec_dirY_P4( Mat_y_tr, vec_in, vec_out )
    implicit none
    real(RP), intent(in) :: Mat_y_tr(5,5)
    real(RP), intent(in) :: vec_in(5,5,5)
    real(RP), intent(out) :: vec_out(5,5,5)

    integer :: i, j, k
    !----------------------------------------------------------

    do k=1, 5
    do j=1, 5
    do i=1, 5
        vec_out(i,j,k) = vec_in(i,1,k) * Mat_y_tr(1,j) &
                       + vec_in(i,2,k) * Mat_y_tr(2,j) &
                       + vec_in(i,3,k) * Mat_y_tr(3,j) &
                       + vec_in(i,4,k) * Mat_y_tr(4,j) &
                       + vec_in(i,5,k) * Mat_y_tr(5,j) 
    end do
    end do
    end do

    return
  end subroutine element_operation_tensorprod3D_kernel_matrix_vec_dirY_P4

!> Calculate a matrix-vector multiplication associated with mathematical operations in the y direction (second dimension of vec_in) with p=5
!! For a matrix-vector multiplication (vec_out = Mat_y vec_in), the passed variable of Mat_y should be transposed.
!!
!OCL SERIAL
  subroutine element_operation_tensorprod3D_kernel_matrix_vec_dirY_P5( Mat_y_tr, vec_in, vec_out )
    implicit none
    real(RP), intent(in) :: Mat_y_tr(6,6)
    real(RP), intent(in) :: vec_in(6,6,6)
    real(RP), intent(out) :: vec_out(6,6,6)

    integer :: i, j, k
    !----------------------------------------------------------

    do k=1, 6
    do j=1, 6
    do i=1, 6
        vec_out(i,j,k) = vec_in(i,1,k) * Mat_y_tr(1,j) &
                       + vec_in(i,2,k) * Mat_y_tr(2,j) &
                       + vec_in(i,3,k) * Mat_y_tr(3,j) &
                       + vec_in(i,4,k) * Mat_y_tr(4,j) &
                       + vec_in(i,5,k) * Mat_y_tr(5,j) &
                       + vec_in(i,6,k) * Mat_y_tr(6,j) 
    end do
    end do
    end do

    return
  end subroutine element_operation_tensorprod3D_kernel_matrix_vec_dirY_P5

!> Calculate a matrix-vector multiplication associated with mathematical operations in the y direction (second dimension of vec_in) with p=6
!! For a matrix-vector multiplication (vec_out = Mat_y vec_in), the passed variable of Mat_y should be transposed.
!!
!OCL SERIAL
  subroutine element_operation_tensorprod3D_kernel_matrix_vec_dirY_P6( Mat_y_tr, vec_in, vec_out )
    implicit none
    real(RP), intent(in) :: Mat_y_tr(7,7)
    real(RP), intent(in) :: vec_in(7,7,7)
    real(RP), intent(out) :: vec_out(7,7,7)

    integer :: i, j, k
    !----------------------------------------------------------

    do k=1, 7
    do j=1, 7
    do i=1, 7
        vec_out(i,j,k) = vec_in(i,1,k) * Mat_y_tr(1,j) &
                       + vec_in(i,2,k) * Mat_y_tr(2,j) &
                       + vec_in(i,3,k) * Mat_y_tr(3,j) &
                       + vec_in(i,4,k) * Mat_y_tr(4,j) &
                       + vec_in(i,5,k) * Mat_y_tr(5,j) &
                       + vec_in(i,6,k) * Mat_y_tr(6,j) &
                       + vec_in(i,7,k) * Mat_y_tr(7,j) 
    end do
    end do
    end do

    return
  end subroutine element_operation_tensorprod3D_kernel_matrix_vec_dirY_P6

!> Calculate a matrix-vector multiplication associated with mathematical operations in the y direction (second dimension of vec_in) with p=7
!! For a matrix-vector multiplication (vec_out = Mat_y vec_in), the passed variable of Mat_y should be transposed.
!!
!OCL SERIAL
  subroutine element_operation_tensorprod3D_kernel_matrix_vec_dirY_P7( Mat_y_tr, vec_in, vec_out )
    implicit none
    real(RP), intent(in) :: Mat_y_tr(8,8)
    real(RP), intent(in) :: vec_in(8,8,8)
    real(RP), intent(out) :: vec_out(8,8,8)

    integer :: i, j, k
    !----------------------------------------------------------

    do k=1, 8
    do j=1, 8
    do i=1, 8
        vec_out(i,j,k) = vec_in(i,1,k) * Mat_y_tr(1,j) &
                       + vec_in(i,2,k) * Mat_y_tr(2,j) &
                       + vec_in(i,3,k) * Mat_y_tr(3,j) &
                       + vec_in(i,4,k) * Mat_y_tr(4,j) &
                       + vec_in(i,5,k) * Mat_y_tr(5,j) &
                       + vec_in(i,6,k) * Mat_y_tr(6,j) &
                       + vec_in(i,7,k) * Mat_y_tr(7,j) &
                       + vec_in(i,8,k) * Mat_y_tr(8,j) 
    end do
    end do
    end do

    return
  end subroutine element_operation_tensorprod3D_kernel_matrix_vec_dirY_P7

!> Calculate a matrix-vector multiplication associated with mathematical operations in the y direction (second dimension of vec_in) with p=8
!! For a matrix-vector multiplication (vec_out = Mat_y vec_in), the passed variable of Mat_y should be transposed.
!!
!OCL SERIAL
  subroutine element_operation_tensorprod3D_kernel_matrix_vec_dirY_P8( Mat_y_tr, vec_in, vec_out )
    implicit none
    real(RP), intent(in) :: Mat_y_tr(9,9)
    real(RP), intent(in) :: vec_in(9,9,9)
    real(RP), intent(out) :: vec_out(9,9,9)

    integer :: i, j, k
    !----------------------------------------------------------

    do k=1, 9
    do j=1, 9
    do i=1, 9
        vec_out(i,j,k) = vec_in(i,1,k) * Mat_y_tr(1,j) &
                       + vec_in(i,2,k) * Mat_y_tr(2,j) &
                       + vec_in(i,3,k) * Mat_y_tr(3,j) &
                       + vec_in(i,4,k) * Mat_y_tr(4,j) &
                       + vec_in(i,5,k) * Mat_y_tr(5,j) &
                       + vec_in(i,6,k) * Mat_y_tr(6,j) &
                       + vec_in(i,7,k) * Mat_y_tr(7,j) &
                       + vec_in(i,8,k) * Mat_y_tr(8,j) &
                       + vec_in(i,9,k) * Mat_y_tr(9,j) 
    end do
    end do
    end do

    return
  end subroutine element_operation_tensorprod3D_kernel_matrix_vec_dirY_P8

!> Calculate a matrix-vector multiplication associated with mathematical operations in the y direction (second dimension of vec_in) with p=9
!! For a matrix-vector multiplication (vec_out = Mat_y vec_in), the passed variable of Mat_y should be transposed.
!!
!OCL SERIAL
  subroutine element_operation_tensorprod3D_kernel_matrix_vec_dirY_P9( Mat_y_tr, vec_in, vec_out )
    implicit none
    real(RP), intent(in) :: Mat_y_tr(10,10)
    real(RP), intent(in) :: vec_in(10,10,10)
    real(RP), intent(out) :: vec_out(10,10,10)

    integer :: i, j, k
    !----------------------------------------------------------

    do k=1, 10
    do j=1, 10
    do i=1, 10
        vec_out(i,j,k) = vec_in(i,1,k) * Mat_y_tr(1,j) &
                       + vec_in(i,2,k) * Mat_y_tr(2,j) &
                       + vec_in(i,3,k) * Mat_y_tr(3,j) &
                       + vec_in(i,4,k) * Mat_y_tr(4,j) &
                       + vec_in(i,5,k) * Mat_y_tr(5,j) &
                       + vec_in(i,6,k) * Mat_y_tr(6,j) &
                       + vec_in(i,7,k) * Mat_y_tr(7,j) &
                       + vec_in(i,8,k) * Mat_y_tr(8,j) &
                       + vec_in(i,9,k) * Mat_y_tr(9,j) &
                       + vec_in(i,10,k) * Mat_y_tr(10,j) 
    end do
    end do
    end do

    return
  end subroutine element_operation_tensorprod3D_kernel_matrix_vec_dirY_P9

!> Calculate a matrix-vector multiplication associated with mathematical operations in the y direction (second dimension of vec_in) with p=10
!! For a matrix-vector multiplication (vec_out = Mat_y vec_in), the passed variable of Mat_y should be transposed.
!!
!OCL SERIAL
  subroutine element_operation_tensorprod3D_kernel_matrix_vec_dirY_P10( Mat_y_tr, vec_in, vec_out )
    implicit none
    real(RP), intent(in) :: Mat_y_tr(11,11)
    real(RP), intent(in) :: vec_in(11,11,11)
    real(RP), intent(out) :: vec_out(11,11,11)

    integer :: i, j, k
    !----------------------------------------------------------

    do k=1, 11
    do j=1, 11
    do i=1, 11
        vec_out(i,j,k) = vec_in(i,1,k) * Mat_y_tr(1,j) &
                       + vec_in(i,2,k) * Mat_y_tr(2,j) &
                       + vec_in(i,3,k) * Mat_y_tr(3,j) &
                       + vec_in(i,4,k) * Mat_y_tr(4,j) &
                       + vec_in(i,5,k) * Mat_y_tr(5,j) &
                       + vec_in(i,6,k) * Mat_y_tr(6,j) &
                       + vec_in(i,7,k) * Mat_y_tr(7,j) &
                       + vec_in(i,8,k) * Mat_y_tr(8,j) &
                       + vec_in(i,9,k) * Mat_y_tr(9,j) &
                       + vec_in(i,10,k) * Mat_y_tr(10,j) &
                       + vec_in(i,11,k) * Mat_y_tr(11,j) 
    end do
    end do
    end do

    return
  end subroutine element_operation_tensorprod3D_kernel_matrix_vec_dirY_P10

!> Calculate a matrix-vector multiplication associated with mathematical operations in the y direction (second dimension of vec_in) with p=11
!! For a matrix-vector multiplication (vec_out = Mat_y vec_in), the passed variable of Mat_y should be transposed.
!!
!OCL SERIAL
  subroutine element_operation_tensorprod3D_kernel_matrix_vec_dirY_P11( Mat_y_tr, vec_in, vec_out )
    implicit none
    real(RP), intent(in) :: Mat_y_tr(12,12)
    real(RP), intent(in) :: vec_in(12,12,12)
    real(RP), intent(out) :: vec_out(12,12,12)

    integer :: i, j, k
    !----------------------------------------------------------

    do k=1, 12
    do j=1, 12
    do i=1, 12
        vec_out(i,j,k) = vec_in(i,1,k) * Mat_y_tr(1,j) &
                       + vec_in(i,2,k) * Mat_y_tr(2,j) &
                       + vec_in(i,3,k) * Mat_y_tr(3,j) &
                       + vec_in(i,4,k) * Mat_y_tr(4,j) &
                       + vec_in(i,5,k) * Mat_y_tr(5,j) &
                       + vec_in(i,6,k) * Mat_y_tr(6,j) &
                       + vec_in(i,7,k) * Mat_y_tr(7,j) &
                       + vec_in(i,8,k) * Mat_y_tr(8,j) &
                       + vec_in(i,9,k) * Mat_y_tr(9,j) &
                       + vec_in(i,10,k) * Mat_y_tr(10,j) &
                       + vec_in(i,11,k) * Mat_y_tr(11,j) &
                       + vec_in(i,12,k) * Mat_y_tr(12,j) 
    end do
    end do
    end do

    return
  end subroutine element_operation_tensorprod3D_kernel_matrix_vec_dirY_P11

!> Calculate a matrix-vector multiplication associated with mathematical operations in the y direction (second dimension of vec_in) with p=12
!! For a matrix-vector multiplication (vec_out = Mat_y vec_in), the passed variable of Mat_y should be transposed.
!!
!OCL SERIAL
  subroutine element_operation_tensorprod3D_kernel_matrix_vec_dirY_P12( Mat_y_tr, vec_in, vec_out )
    implicit none
    real(RP), intent(in) :: Mat_y_tr(13,13)
    real(RP), intent(in) :: vec_in(13,13,13)
    real(RP), intent(out) :: vec_out(13,13,13)

    integer :: i, j, k
    !----------------------------------------------------------

    do k=1, 13
    do j=1, 13
    do i=1, 13
        vec_out(i,j,k) = vec_in(i,1,k) * Mat_y_tr(1,j) &
                       + vec_in(i,2,k) * Mat_y_tr(2,j) &
                       + vec_in(i,3,k) * Mat_y_tr(3,j) &
                       + vec_in(i,4,k) * Mat_y_tr(4,j) &
                       + vec_in(i,5,k) * Mat_y_tr(5,j) &
                       + vec_in(i,6,k) * Mat_y_tr(6,j) &
                       + vec_in(i,7,k) * Mat_y_tr(7,j) &
                       + vec_in(i,8,k) * Mat_y_tr(8,j) &
                       + vec_in(i,9,k) * Mat_y_tr(9,j) &
                       + vec_in(i,10,k) * Mat_y_tr(10,j) &
                       + vec_in(i,11,k) * Mat_y_tr(11,j) &
                       + vec_in(i,12,k) * Mat_y_tr(12,j) &
                       + vec_in(i,13,k) * Mat_y_tr(13,j) 
    end do
    end do
    end do

    return
  end subroutine element_operation_tensorprod3D_kernel_matrix_vec_dirY_P12

!> Calculate a matrix-vector multiplication associated with mathematical operations in the y direction (second dimension of vec_in) with p=13
!! For a matrix-vector multiplication (vec_out = Mat_y vec_in), the passed variable of Mat_y should be transposed.
!!
!OCL SERIAL
  subroutine element_operation_tensorprod3D_kernel_matrix_vec_dirY_P13( Mat_y_tr, vec_in, vec_out )
    implicit none
    real(RP), intent(in) :: Mat_y_tr(14,14)
    real(RP), intent(in) :: vec_in(14,14,14)
    real(RP), intent(out) :: vec_out(14,14,14)

    integer :: i, j, k
    !----------------------------------------------------------

    do k=1, 14
    do j=1, 14
    do i=1, 14
        vec_out(i,j,k) = vec_in(i,1,k) * Mat_y_tr(1,j) &
                       + vec_in(i,2,k) * Mat_y_tr(2,j) &
                       + vec_in(i,3,k) * Mat_y_tr(3,j) &
                       + vec_in(i,4,k) * Mat_y_tr(4,j) &
                       + vec_in(i,5,k) * Mat_y_tr(5,j) &
                       + vec_in(i,6,k) * Mat_y_tr(6,j) &
                       + vec_in(i,7,k) * Mat_y_tr(7,j) &
                       + vec_in(i,8,k) * Mat_y_tr(8,j) &
                       + vec_in(i,9,k) * Mat_y_tr(9,j) &
                       + vec_in(i,10,k) * Mat_y_tr(10,j) &
                       + vec_in(i,11,k) * Mat_y_tr(11,j) &
                       + vec_in(i,12,k) * Mat_y_tr(12,j) &
                       + vec_in(i,13,k) * Mat_y_tr(13,j) &
                       + vec_in(i,14,k) * Mat_y_tr(14,j) 
    end do
    end do
    end do

    return
  end subroutine element_operation_tensorprod3D_kernel_matrix_vec_dirY_P13

!-------------------------------------------------------------


!> Calculate a matrix-vector multiplication associated with mathematical operations in the z direction (third dimension of vec_in) with p=1
!! For a matrix-vector multiplication (vec_out = Mat_z vec_in), the passed variable of Mat_z should be transposed.
!!
!OCL SERIAL
  subroutine element_operation_tensorprod3D_kernel_matrix_vec_dirZ_P1( Mat_z_tr, vec_in, vec_out )
    implicit none
    real(RP), intent(in) :: Mat_z_tr(2,2)
    real(RP), intent(in) :: vec_in(2,2,2)
    real(RP), intent(out) :: vec_out(2,2,2)

    integer :: i, j, k
    !----------------------------------------------------------

    do k=1, 2
    do j=1, 2
    do i=1, 2
        vec_out(i,j,k) = vec_in(i,1,k) * Mat_z_tr(1,j) &
                       + vec_in(i,j,2) * Mat_z_tr(2,k) 
    end do
    end do
    end do

    return
  end subroutine element_operation_tensorprod3D_kernel_matrix_vec_dirZ_P1

!> Calculate a matrix-vector multiplication associated with mathematical operations in the z direction (third dimension of vec_in) with p=2
!! For a matrix-vector multiplication (vec_out = Mat_z vec_in), the passed variable of Mat_z should be transposed.
!!
!OCL SERIAL
  subroutine element_operation_tensorprod3D_kernel_matrix_vec_dirZ_P2( Mat_z_tr, vec_in, vec_out )
    implicit none
    real(RP), intent(in) :: Mat_z_tr(3,3)
    real(RP), intent(in) :: vec_in(3,3,3)
    real(RP), intent(out) :: vec_out(3,3,3)

    integer :: i, j, k
    !----------------------------------------------------------

    do k=1, 3
    do j=1, 3
    do i=1, 3
        vec_out(i,j,k) = vec_in(i,1,k) * Mat_z_tr(1,j) &
                       + vec_in(i,j,2) * Mat_z_tr(2,k) &
                       + vec_in(i,j,3) * Mat_z_tr(3,k) 
    end do
    end do
    end do

    return
  end subroutine element_operation_tensorprod3D_kernel_matrix_vec_dirZ_P2

!> Calculate a matrix-vector multiplication associated with mathematical operations in the z direction (third dimension of vec_in) with p=3
!! For a matrix-vector multiplication (vec_out = Mat_z vec_in), the passed variable of Mat_z should be transposed.
!!
!OCL SERIAL
  subroutine element_operation_tensorprod3D_kernel_matrix_vec_dirZ_P3( Mat_z_tr, vec_in, vec_out )
    implicit none
    real(RP), intent(in) :: Mat_z_tr(4,4)
    real(RP), intent(in) :: vec_in(4,4,4)
    real(RP), intent(out) :: vec_out(4,4,4)

    integer :: i, j, k
    !----------------------------------------------------------

    do k=1, 4
    do j=1, 4
    do i=1, 4
        vec_out(i,j,k) = vec_in(i,1,k) * Mat_z_tr(1,j) &
                       + vec_in(i,j,2) * Mat_z_tr(2,k) &
                       + vec_in(i,j,3) * Mat_z_tr(3,k) &
                       + vec_in(i,j,4) * Mat_z_tr(4,k) 
    end do
    end do
    end do

    return
  end subroutine element_operation_tensorprod3D_kernel_matrix_vec_dirZ_P3

!> Calculate a matrix-vector multiplication associated with mathematical operations in the z direction (third dimension of vec_in) with p=4
!! For a matrix-vector multiplication (vec_out = Mat_z vec_in), the passed variable of Mat_z should be transposed.
!!
!OCL SERIAL
  subroutine element_operation_tensorprod3D_kernel_matrix_vec_dirZ_P4( Mat_z_tr, vec_in, vec_out )
    implicit none
    real(RP), intent(in) :: Mat_z_tr(5,5)
    real(RP), intent(in) :: vec_in(5,5,5)
    real(RP), intent(out) :: vec_out(5,5,5)

    integer :: i, j, k
    !----------------------------------------------------------

    do k=1, 5
    do j=1, 5
    do i=1, 5
        vec_out(i,j,k) = vec_in(i,1,k) * Mat_z_tr(1,j) &
                       + vec_in(i,j,2) * Mat_z_tr(2,k) &
                       + vec_in(i,j,3) * Mat_z_tr(3,k) &
                       + vec_in(i,j,4) * Mat_z_tr(4,k) &
                       + vec_in(i,j,5) * Mat_z_tr(5,k) 
    end do
    end do
    end do

    return
  end subroutine element_operation_tensorprod3D_kernel_matrix_vec_dirZ_P4

!> Calculate a matrix-vector multiplication associated with mathematical operations in the z direction (third dimension of vec_in) with p=5
!! For a matrix-vector multiplication (vec_out = Mat_z vec_in), the passed variable of Mat_z should be transposed.
!!
!OCL SERIAL
  subroutine element_operation_tensorprod3D_kernel_matrix_vec_dirZ_P5( Mat_z_tr, vec_in, vec_out )
    implicit none
    real(RP), intent(in) :: Mat_z_tr(6,6)
    real(RP), intent(in) :: vec_in(6,6,6)
    real(RP), intent(out) :: vec_out(6,6,6)

    integer :: i, j, k
    !----------------------------------------------------------

    do k=1, 6
    do j=1, 6
    do i=1, 6
        vec_out(i,j,k) = vec_in(i,1,k) * Mat_z_tr(1,j) &
                       + vec_in(i,j,2) * Mat_z_tr(2,k) &
                       + vec_in(i,j,3) * Mat_z_tr(3,k) &
                       + vec_in(i,j,4) * Mat_z_tr(4,k) &
                       + vec_in(i,j,5) * Mat_z_tr(5,k) &
                       + vec_in(i,j,6) * Mat_z_tr(6,k) 
    end do
    end do
    end do

    return
  end subroutine element_operation_tensorprod3D_kernel_matrix_vec_dirZ_P5

!> Calculate a matrix-vector multiplication associated with mathematical operations in the z direction (third dimension of vec_in) with p=6
!! For a matrix-vector multiplication (vec_out = Mat_z vec_in), the passed variable of Mat_z should be transposed.
!!
!OCL SERIAL
  subroutine element_operation_tensorprod3D_kernel_matrix_vec_dirZ_P6( Mat_z_tr, vec_in, vec_out )
    implicit none
    real(RP), intent(in) :: Mat_z_tr(7,7)
    real(RP), intent(in) :: vec_in(7,7,7)
    real(RP), intent(out) :: vec_out(7,7,7)

    integer :: i, j, k
    !----------------------------------------------------------

    do k=1, 7
    do j=1, 7
    do i=1, 7
        vec_out(i,j,k) = vec_in(i,1,k) * Mat_z_tr(1,j) &
                       + vec_in(i,j,2) * Mat_z_tr(2,k) &
                       + vec_in(i,j,3) * Mat_z_tr(3,k) &
                       + vec_in(i,j,4) * Mat_z_tr(4,k) &
                       + vec_in(i,j,5) * Mat_z_tr(5,k) &
                       + vec_in(i,j,6) * Mat_z_tr(6,k) &
                       + vec_in(i,j,7) * Mat_z_tr(7,k) 
    end do
    end do
    end do

    return
  end subroutine element_operation_tensorprod3D_kernel_matrix_vec_dirZ_P6

!> Calculate a matrix-vector multiplication associated with mathematical operations in the z direction (third dimension of vec_in) with p=7
!! For a matrix-vector multiplication (vec_out = Mat_z vec_in), the passed variable of Mat_z should be transposed.
!!
!OCL SERIAL
  subroutine element_operation_tensorprod3D_kernel_matrix_vec_dirZ_P7( Mat_z_tr, vec_in, vec_out )
    implicit none
    real(RP), intent(in) :: Mat_z_tr(8,8)
    real(RP), intent(in) :: vec_in(8,8,8)
    real(RP), intent(out) :: vec_out(8,8,8)

    integer :: i, j, k
    !----------------------------------------------------------

    do k=1, 8
    do j=1, 8
    do i=1, 8
        vec_out(i,j,k) = vec_in(i,1,k) * Mat_z_tr(1,j) &
                       + vec_in(i,j,2) * Mat_z_tr(2,k) &
                       + vec_in(i,j,3) * Mat_z_tr(3,k) &
                       + vec_in(i,j,4) * Mat_z_tr(4,k) &
                       + vec_in(i,j,5) * Mat_z_tr(5,k) &
                       + vec_in(i,j,6) * Mat_z_tr(6,k) &
                       + vec_in(i,j,7) * Mat_z_tr(7,k) &
                       + vec_in(i,j,8) * Mat_z_tr(8,k) 
    end do
    end do
    end do

    return
  end subroutine element_operation_tensorprod3D_kernel_matrix_vec_dirZ_P7

!> Calculate a matrix-vector multiplication associated with mathematical operations in the z direction (third dimension of vec_in) with p=8
!! For a matrix-vector multiplication (vec_out = Mat_z vec_in), the passed variable of Mat_z should be transposed.
!!
!OCL SERIAL
  subroutine element_operation_tensorprod3D_kernel_matrix_vec_dirZ_P8( Mat_z_tr, vec_in, vec_out )
    implicit none
    real(RP), intent(in) :: Mat_z_tr(9,9)
    real(RP), intent(in) :: vec_in(9,9,9)
    real(RP), intent(out) :: vec_out(9,9,9)

    integer :: i, j, k
    !----------------------------------------------------------

    do k=1, 9
    do j=1, 9
    do i=1, 9
        vec_out(i,j,k) = vec_in(i,1,k) * Mat_z_tr(1,j) &
                       + vec_in(i,j,2) * Mat_z_tr(2,k) &
                       + vec_in(i,j,3) * Mat_z_tr(3,k) &
                       + vec_in(i,j,4) * Mat_z_tr(4,k) &
                       + vec_in(i,j,5) * Mat_z_tr(5,k) &
                       + vec_in(i,j,6) * Mat_z_tr(6,k) &
                       + vec_in(i,j,7) * Mat_z_tr(7,k) &
                       + vec_in(i,j,8) * Mat_z_tr(8,k) &
                       + vec_in(i,j,9) * Mat_z_tr(9,k) 
    end do
    end do
    end do

    return
  end subroutine element_operation_tensorprod3D_kernel_matrix_vec_dirZ_P8

!> Calculate a matrix-vector multiplication associated with mathematical operations in the z direction (third dimension of vec_in) with p=9
!! For a matrix-vector multiplication (vec_out = Mat_z vec_in), the passed variable of Mat_z should be transposed.
!!
!OCL SERIAL
  subroutine element_operation_tensorprod3D_kernel_matrix_vec_dirZ_P9( Mat_z_tr, vec_in, vec_out )
    implicit none
    real(RP), intent(in) :: Mat_z_tr(10,10)
    real(RP), intent(in) :: vec_in(10,10,10)
    real(RP), intent(out) :: vec_out(10,10,10)

    integer :: i, j, k
    !----------------------------------------------------------

    do k=1, 10
    do j=1, 10
    do i=1, 10
        vec_out(i,j,k) = vec_in(i,1,k) * Mat_z_tr(1,j) &
                       + vec_in(i,j,2) * Mat_z_tr(2,k) &
                       + vec_in(i,j,3) * Mat_z_tr(3,k) &
                       + vec_in(i,j,4) * Mat_z_tr(4,k) &
                       + vec_in(i,j,5) * Mat_z_tr(5,k) &
                       + vec_in(i,j,6) * Mat_z_tr(6,k) &
                       + vec_in(i,j,7) * Mat_z_tr(7,k) &
                       + vec_in(i,j,8) * Mat_z_tr(8,k) &
                       + vec_in(i,j,9) * Mat_z_tr(9,k) &
                       + vec_in(i,j,10) * Mat_z_tr(10,k) 
    end do
    end do
    end do

    return
  end subroutine element_operation_tensorprod3D_kernel_matrix_vec_dirZ_P9

!> Calculate a matrix-vector multiplication associated with mathematical operations in the z direction (third dimension of vec_in) with p=10
!! For a matrix-vector multiplication (vec_out = Mat_z vec_in), the passed variable of Mat_z should be transposed.
!!
!OCL SERIAL
  subroutine element_operation_tensorprod3D_kernel_matrix_vec_dirZ_P10( Mat_z_tr, vec_in, vec_out )
    implicit none
    real(RP), intent(in) :: Mat_z_tr(11,11)
    real(RP), intent(in) :: vec_in(11,11,11)
    real(RP), intent(out) :: vec_out(11,11,11)

    integer :: i, j, k
    !----------------------------------------------------------

    do k=1, 11
    do j=1, 11
    do i=1, 11
        vec_out(i,j,k) = vec_in(i,1,k) * Mat_z_tr(1,j) &
                       + vec_in(i,j,2) * Mat_z_tr(2,k) &
                       + vec_in(i,j,3) * Mat_z_tr(3,k) &
                       + vec_in(i,j,4) * Mat_z_tr(4,k) &
                       + vec_in(i,j,5) * Mat_z_tr(5,k) &
                       + vec_in(i,j,6) * Mat_z_tr(6,k) &
                       + vec_in(i,j,7) * Mat_z_tr(7,k) &
                       + vec_in(i,j,8) * Mat_z_tr(8,k) &
                       + vec_in(i,j,9) * Mat_z_tr(9,k) &
                       + vec_in(i,j,10) * Mat_z_tr(10,k) &
                       + vec_in(i,j,11) * Mat_z_tr(11,k) 
    end do
    end do
    end do

    return
  end subroutine element_operation_tensorprod3D_kernel_matrix_vec_dirZ_P10

!> Calculate a matrix-vector multiplication associated with mathematical operations in the z direction (third dimension of vec_in) with p=11
!! For a matrix-vector multiplication (vec_out = Mat_z vec_in), the passed variable of Mat_z should be transposed.
!!
!OCL SERIAL
  subroutine element_operation_tensorprod3D_kernel_matrix_vec_dirZ_P11( Mat_z_tr, vec_in, vec_out )
    implicit none
    real(RP), intent(in) :: Mat_z_tr(12,12)
    real(RP), intent(in) :: vec_in(12,12,12)
    real(RP), intent(out) :: vec_out(12,12,12)

    integer :: i, j, k
    !----------------------------------------------------------

    do k=1, 12
    do j=1, 12
    do i=1, 12
        vec_out(i,j,k) = vec_in(i,1,k) * Mat_z_tr(1,j) &
                       + vec_in(i,j,2) * Mat_z_tr(2,k) &
                       + vec_in(i,j,3) * Mat_z_tr(3,k) &
                       + vec_in(i,j,4) * Mat_z_tr(4,k) &
                       + vec_in(i,j,5) * Mat_z_tr(5,k) &
                       + vec_in(i,j,6) * Mat_z_tr(6,k) &
                       + vec_in(i,j,7) * Mat_z_tr(7,k) &
                       + vec_in(i,j,8) * Mat_z_tr(8,k) &
                       + vec_in(i,j,9) * Mat_z_tr(9,k) &
                       + vec_in(i,j,10) * Mat_z_tr(10,k) &
                       + vec_in(i,j,11) * Mat_z_tr(11,k) &
                       + vec_in(i,j,12) * Mat_z_tr(12,k) 
    end do
    end do
    end do

    return
  end subroutine element_operation_tensorprod3D_kernel_matrix_vec_dirZ_P11

!> Calculate a matrix-vector multiplication associated with mathematical operations in the z direction (third dimension of vec_in) with p=12
!! For a matrix-vector multiplication (vec_out = Mat_z vec_in), the passed variable of Mat_z should be transposed.
!!
!OCL SERIAL
  subroutine element_operation_tensorprod3D_kernel_matrix_vec_dirZ_P12( Mat_z_tr, vec_in, vec_out )
    implicit none
    real(RP), intent(in) :: Mat_z_tr(13,13)
    real(RP), intent(in) :: vec_in(13,13,13)
    real(RP), intent(out) :: vec_out(13,13,13)

    integer :: i, j, k
    !----------------------------------------------------------

    do k=1, 13
    do j=1, 13
    do i=1, 13
        vec_out(i,j,k) = vec_in(i,1,k) * Mat_z_tr(1,j) &
                       + vec_in(i,j,2) * Mat_z_tr(2,k) &
                       + vec_in(i,j,3) * Mat_z_tr(3,k) &
                       + vec_in(i,j,4) * Mat_z_tr(4,k) &
                       + vec_in(i,j,5) * Mat_z_tr(5,k) &
                       + vec_in(i,j,6) * Mat_z_tr(6,k) &
                       + vec_in(i,j,7) * Mat_z_tr(7,k) &
                       + vec_in(i,j,8) * Mat_z_tr(8,k) &
                       + vec_in(i,j,9) * Mat_z_tr(9,k) &
                       + vec_in(i,j,10) * Mat_z_tr(10,k) &
                       + vec_in(i,j,11) * Mat_z_tr(11,k) &
                       + vec_in(i,j,12) * Mat_z_tr(12,k) &
                       + vec_in(i,j,13) * Mat_z_tr(13,k) 
    end do
    end do
    end do

    return
  end subroutine element_operation_tensorprod3D_kernel_matrix_vec_dirZ_P12

!> Calculate a matrix-vector multiplication associated with mathematical operations in the z direction (third dimension of vec_in) with p=13
!! For a matrix-vector multiplication (vec_out = Mat_z vec_in), the passed variable of Mat_z should be transposed.
!!
!OCL SERIAL
  subroutine element_operation_tensorprod3D_kernel_matrix_vec_dirZ_P13( Mat_z_tr, vec_in, vec_out )
    implicit none
    real(RP), intent(in) :: Mat_z_tr(14,14)
    real(RP), intent(in) :: vec_in(14,14,14)
    real(RP), intent(out) :: vec_out(14,14,14)

    integer :: i, j, k
    !----------------------------------------------------------

    do k=1, 14
    do j=1, 14
    do i=1, 14
        vec_out(i,j,k) = vec_in(i,1,k) * Mat_z_tr(1,j) &
                       + vec_in(i,j,2) * Mat_z_tr(2,k) &
                       + vec_in(i,j,3) * Mat_z_tr(3,k) &
                       + vec_in(i,j,4) * Mat_z_tr(4,k) &
                       + vec_in(i,j,5) * Mat_z_tr(5,k) &
                       + vec_in(i,j,6) * Mat_z_tr(6,k) &
                       + vec_in(i,j,7) * Mat_z_tr(7,k) &
                       + vec_in(i,j,8) * Mat_z_tr(8,k) &
                       + vec_in(i,j,9) * Mat_z_tr(9,k) &
                       + vec_in(i,j,10) * Mat_z_tr(10,k) &
                       + vec_in(i,j,11) * Mat_z_tr(11,k) &
                       + vec_in(i,j,12) * Mat_z_tr(12,k) &
                       + vec_in(i,j,13) * Mat_z_tr(13,k) &
                       + vec_in(i,j,14) * Mat_z_tr(14,k) 
    end do
    end do
    end do

    return
  end subroutine element_operation_tensorprod3D_kernel_matrix_vec_dirZ_P13

!-------------------------------------------------------------


!> Calculate a matrix-vector multiplication associated with mathematical operations in the x, y, and z direction (third dimension of vec_in) with p=1
!! For a matrix-vector multiplication (vec_d_out = Mat_d vec_in where d=x,y,z), the passed variables of Mat_y and Mat_z should be transposed.
!! Note that we assume that vec_in_ has same data as vec_in, but are reshaped via the call of this subroutine. 
!!
!OCL SERIAL
  subroutine element_operation_tensorprod3D_kernel_matrix_vec_gradlike_dirXYZ_P1( Mat_x, Mat_y_tr, Mat_z_tr, vec_in, vec_in_, &
    vec_out_x, vec_out_y, vec_out_z  )
    implicit none
    real(RP), intent(in) :: Mat_x(2,2)
    real(RP), intent(in) :: Mat_y_tr(2,2)
    real(RP), intent(in) :: Mat_z_tr(2,2)
    real(RP), intent(in) :: vec_in_(2,2**2)
    real(RP), intent(in) :: vec_in(2,2,2)
    real(RP), intent(out) :: vec_out_x(2,2**2)
    real(RP), intent(out) :: vec_out_y(2,2,2)
    real(RP), intent(out) :: vec_out_z(2,2,2)

    integer :: i, j, k, jk
    !----------------------------------------------------------

    ! X-dir

    do jk=1, 2**2
    do i=1, 2
        vec_out_x(i,jk) = Mat_x(i,1) * vec_in_(1,jk) &
                        + Mat_x(i,2) * vec_in_(2,jk)
    end do
    end do

    ! Y-dir
    do k=1, 2
    do j=1, 2
    do i=1, 2
        vec_out_y(i,j,k) = vec_in(i,1,k) * Mat_y_tr(1,j) &
                         + vec_in(i,2,k) * Mat_y_tr(2,j) 
    end do
    end do
    end do
    
    ! Z-dir
    do k=1, 2
    do j=1, 2
    do i=1, 2
        vec_out_z(i,j,k) = vec_in(i,1,k) * Mat_z_tr(1,j) &
                         + vec_in(i,j,2) * Mat_z_tr(2,k) 
    end do
    end do
    end do

    return
  end subroutine element_operation_tensorprod3D_kernel_matrix_vec_gradlike_dirXYZ_P1

!> Calculate a matrix-vector multiplication associated with mathematical operations in the x, y, and z direction (third dimension of vec_in) with p=2
!! For a matrix-vector multiplication (vec_d_out = Mat_d vec_in where d=x,y,z), the passed variables of Mat_y and Mat_z should be transposed.
!! Note that we assume that vec_in_ has same data as vec_in, but are reshaped via the call of this subroutine. 
!!
!OCL SERIAL
  subroutine element_operation_tensorprod3D_kernel_matrix_vec_gradlike_dirXYZ_P2( Mat_x, Mat_y_tr, Mat_z_tr, vec_in, vec_in_, &
    vec_out_x, vec_out_y, vec_out_z  )
    implicit none
    real(RP), intent(in) :: Mat_x(3,3)
    real(RP), intent(in) :: Mat_y_tr(3,3)
    real(RP), intent(in) :: Mat_z_tr(3,3)
    real(RP), intent(in) :: vec_in_(3,3**2)
    real(RP), intent(in) :: vec_in(3,3,3)
    real(RP), intent(out) :: vec_out_x(3,3**2)
    real(RP), intent(out) :: vec_out_y(3,3,3)
    real(RP), intent(out) :: vec_out_z(3,3,3)

    integer :: i, j, k, jk
    !----------------------------------------------------------

    ! X-dir

    do jk=1, 3**2
    do i=1, 3
        vec_out_x(i,jk) = Mat_x(i,1) * vec_in_(1,jk) &
                        + Mat_x(i,2) * vec_in_(2,jk) &
                        + Mat_x(i,3) * vec_in_(3,jk)
    end do
    end do

    ! Y-dir
    do k=1, 3
    do j=1, 3
    do i=1, 3
        vec_out_y(i,j,k) = vec_in(i,1,k) * Mat_y_tr(1,j) &
                         + vec_in(i,2,k) * Mat_y_tr(2,j) &
                         + vec_in(i,3,k) * Mat_y_tr(3,j) 
    end do
    end do
    end do
    
    ! Z-dir
    do k=1, 3
    do j=1, 3
    do i=1, 3
        vec_out_z(i,j,k) = vec_in(i,1,k) * Mat_z_tr(1,j) &
                         + vec_in(i,j,2) * Mat_z_tr(2,k) &
                         + vec_in(i,j,3) * Mat_z_tr(3,k) 
    end do
    end do
    end do

    return
  end subroutine element_operation_tensorprod3D_kernel_matrix_vec_gradlike_dirXYZ_P2

!> Calculate a matrix-vector multiplication associated with mathematical operations in the x, y, and z direction (third dimension of vec_in) with p=3
!! For a matrix-vector multiplication (vec_d_out = Mat_d vec_in where d=x,y,z), the passed variables of Mat_y and Mat_z should be transposed.
!! Note that we assume that vec_in_ has same data as vec_in, but are reshaped via the call of this subroutine. 
!!
!OCL SERIAL
  subroutine element_operation_tensorprod3D_kernel_matrix_vec_gradlike_dirXYZ_P3( Mat_x, Mat_y_tr, Mat_z_tr, vec_in, vec_in_, &
    vec_out_x, vec_out_y, vec_out_z  )
    implicit none
    real(RP), intent(in) :: Mat_x(4,4)
    real(RP), intent(in) :: Mat_y_tr(4,4)
    real(RP), intent(in) :: Mat_z_tr(4,4)
    real(RP), intent(in) :: vec_in_(4,4**2)
    real(RP), intent(in) :: vec_in(4,4,4)
    real(RP), intent(out) :: vec_out_x(4,4**2)
    real(RP), intent(out) :: vec_out_y(4,4,4)
    real(RP), intent(out) :: vec_out_z(4,4,4)

    integer :: i, j, k, jk
    !----------------------------------------------------------

    ! X-dir

    do jk=1, 4**2
    do i=1, 4
        vec_out_x(i,jk) = Mat_x(i,1) * vec_in_(1,jk) &
                        + Mat_x(i,2) * vec_in_(2,jk) &
                        + Mat_x(i,3) * vec_in_(3,jk) &
                        + Mat_x(i,4) * vec_in_(4,jk)
    end do
    end do

    ! Y-dir
    do k=1, 4
    do j=1, 4
    do i=1, 4
        vec_out_y(i,j,k) = vec_in(i,1,k) * Mat_y_tr(1,j) &
                         + vec_in(i,2,k) * Mat_y_tr(2,j) &
                         + vec_in(i,3,k) * Mat_y_tr(3,j) &
                         + vec_in(i,4,k) * Mat_y_tr(4,j) 
    end do
    end do
    end do
    
    ! Z-dir
    do k=1, 4
    do j=1, 4
    do i=1, 4
        vec_out_z(i,j,k) = vec_in(i,1,k) * Mat_z_tr(1,j) &
                         + vec_in(i,j,2) * Mat_z_tr(2,k) &
                         + vec_in(i,j,3) * Mat_z_tr(3,k) &
                         + vec_in(i,j,4) * Mat_z_tr(4,k) 
    end do
    end do
    end do

    return
  end subroutine element_operation_tensorprod3D_kernel_matrix_vec_gradlike_dirXYZ_P3

!> Calculate a matrix-vector multiplication associated with mathematical operations in the x, y, and z direction (third dimension of vec_in) with p=4
!! For a matrix-vector multiplication (vec_d_out = Mat_d vec_in where d=x,y,z), the passed variables of Mat_y and Mat_z should be transposed.
!! Note that we assume that vec_in_ has same data as vec_in, but are reshaped via the call of this subroutine. 
!!
!OCL SERIAL
  subroutine element_operation_tensorprod3D_kernel_matrix_vec_gradlike_dirXYZ_P4( Mat_x, Mat_y_tr, Mat_z_tr, vec_in, vec_in_, &
    vec_out_x, vec_out_y, vec_out_z  )
    implicit none
    real(RP), intent(in) :: Mat_x(5,5)
    real(RP), intent(in) :: Mat_y_tr(5,5)
    real(RP), intent(in) :: Mat_z_tr(5,5)
    real(RP), intent(in) :: vec_in_(5,5**2)
    real(RP), intent(in) :: vec_in(5,5,5)
    real(RP), intent(out) :: vec_out_x(5,5**2)
    real(RP), intent(out) :: vec_out_y(5,5,5)
    real(RP), intent(out) :: vec_out_z(5,5,5)

    integer :: i, j, k, jk
    !----------------------------------------------------------

    ! X-dir

    do jk=1, 5**2
    do i=1, 5
        vec_out_x(i,jk) = Mat_x(i,1) * vec_in_(1,jk) &
                        + Mat_x(i,2) * vec_in_(2,jk) &
                        + Mat_x(i,3) * vec_in_(3,jk) &
                        + Mat_x(i,4) * vec_in_(4,jk) &
                        + Mat_x(i,5) * vec_in_(5,jk)
    end do
    end do

    ! Y-dir
    do k=1, 5
    do j=1, 5
    do i=1, 5
        vec_out_y(i,j,k) = vec_in(i,1,k) * Mat_y_tr(1,j) &
                         + vec_in(i,2,k) * Mat_y_tr(2,j) &
                         + vec_in(i,3,k) * Mat_y_tr(3,j) &
                         + vec_in(i,4,k) * Mat_y_tr(4,j) &
                         + vec_in(i,5,k) * Mat_y_tr(5,j) 
    end do
    end do
    end do
    
    ! Z-dir
    do k=1, 5
    do j=1, 5
    do i=1, 5
        vec_out_z(i,j,k) = vec_in(i,1,k) * Mat_z_tr(1,j) &
                         + vec_in(i,j,2) * Mat_z_tr(2,k) &
                         + vec_in(i,j,3) * Mat_z_tr(3,k) &
                         + vec_in(i,j,4) * Mat_z_tr(4,k) &
                         + vec_in(i,j,5) * Mat_z_tr(5,k) 
    end do
    end do
    end do

    return
  end subroutine element_operation_tensorprod3D_kernel_matrix_vec_gradlike_dirXYZ_P4

!> Calculate a matrix-vector multiplication associated with mathematical operations in the x, y, and z direction (third dimension of vec_in) with p=5
!! For a matrix-vector multiplication (vec_d_out = Mat_d vec_in where d=x,y,z), the passed variables of Mat_y and Mat_z should be transposed.
!! Note that we assume that vec_in_ has same data as vec_in, but are reshaped via the call of this subroutine. 
!!
!OCL SERIAL
  subroutine element_operation_tensorprod3D_kernel_matrix_vec_gradlike_dirXYZ_P5( Mat_x, Mat_y_tr, Mat_z_tr, vec_in, vec_in_, &
    vec_out_x, vec_out_y, vec_out_z  )
    implicit none
    real(RP), intent(in) :: Mat_x(6,6)
    real(RP), intent(in) :: Mat_y_tr(6,6)
    real(RP), intent(in) :: Mat_z_tr(6,6)
    real(RP), intent(in) :: vec_in_(6,6**2)
    real(RP), intent(in) :: vec_in(6,6,6)
    real(RP), intent(out) :: vec_out_x(6,6**2)
    real(RP), intent(out) :: vec_out_y(6,6,6)
    real(RP), intent(out) :: vec_out_z(6,6,6)

    integer :: i, j, k, jk
    !----------------------------------------------------------

    ! X-dir

    do jk=1, 6**2
    do i=1, 6
        vec_out_x(i,jk) = Mat_x(i,1) * vec_in_(1,jk) &
                        + Mat_x(i,2) * vec_in_(2,jk) &
                        + Mat_x(i,3) * vec_in_(3,jk) &
                        + Mat_x(i,4) * vec_in_(4,jk) &
                        + Mat_x(i,5) * vec_in_(5,jk) &
                        + Mat_x(i,6) * vec_in_(6,jk)
    end do
    end do

    ! Y-dir
    do k=1, 6
    do j=1, 6
    do i=1, 6
        vec_out_y(i,j,k) = vec_in(i,1,k) * Mat_y_tr(1,j) &
                         + vec_in(i,2,k) * Mat_y_tr(2,j) &
                         + vec_in(i,3,k) * Mat_y_tr(3,j) &
                         + vec_in(i,4,k) * Mat_y_tr(4,j) &
                         + vec_in(i,5,k) * Mat_y_tr(5,j) &
                         + vec_in(i,6,k) * Mat_y_tr(6,j) 
    end do
    end do
    end do
    
    ! Z-dir
    do k=1, 6
    do j=1, 6
    do i=1, 6
        vec_out_z(i,j,k) = vec_in(i,1,k) * Mat_z_tr(1,j) &
                         + vec_in(i,j,2) * Mat_z_tr(2,k) &
                         + vec_in(i,j,3) * Mat_z_tr(3,k) &
                         + vec_in(i,j,4) * Mat_z_tr(4,k) &
                         + vec_in(i,j,5) * Mat_z_tr(5,k) &
                         + vec_in(i,j,6) * Mat_z_tr(6,k) 
    end do
    end do
    end do

    return
  end subroutine element_operation_tensorprod3D_kernel_matrix_vec_gradlike_dirXYZ_P5

!> Calculate a matrix-vector multiplication associated with mathematical operations in the x, y, and z direction (third dimension of vec_in) with p=6
!! For a matrix-vector multiplication (vec_d_out = Mat_d vec_in where d=x,y,z), the passed variables of Mat_y and Mat_z should be transposed.
!! Note that we assume that vec_in_ has same data as vec_in, but are reshaped via the call of this subroutine. 
!!
!OCL SERIAL
  subroutine element_operation_tensorprod3D_kernel_matrix_vec_gradlike_dirXYZ_P6( Mat_x, Mat_y_tr, Mat_z_tr, vec_in, vec_in_, &
    vec_out_x, vec_out_y, vec_out_z  )
    implicit none
    real(RP), intent(in) :: Mat_x(7,7)
    real(RP), intent(in) :: Mat_y_tr(7,7)
    real(RP), intent(in) :: Mat_z_tr(7,7)
    real(RP), intent(in) :: vec_in_(7,7**2)
    real(RP), intent(in) :: vec_in(7,7,7)
    real(RP), intent(out) :: vec_out_x(7,7**2)
    real(RP), intent(out) :: vec_out_y(7,7,7)
    real(RP), intent(out) :: vec_out_z(7,7,7)

    integer :: i, j, k, jk
    !----------------------------------------------------------

    ! X-dir

    do jk=1, 7**2
    do i=1, 7
        vec_out_x(i,jk) = Mat_x(i,1) * vec_in_(1,jk) &
                        + Mat_x(i,2) * vec_in_(2,jk) &
                        + Mat_x(i,3) * vec_in_(3,jk) &
                        + Mat_x(i,4) * vec_in_(4,jk) &
                        + Mat_x(i,5) * vec_in_(5,jk) &
                        + Mat_x(i,6) * vec_in_(6,jk) &
                        + Mat_x(i,7) * vec_in_(7,jk)
    end do
    end do

    ! Y-dir
    do k=1, 7
    do j=1, 7
    do i=1, 7
        vec_out_y(i,j,k) = vec_in(i,1,k) * Mat_y_tr(1,j) &
                         + vec_in(i,2,k) * Mat_y_tr(2,j) &
                         + vec_in(i,3,k) * Mat_y_tr(3,j) &
                         + vec_in(i,4,k) * Mat_y_tr(4,j) &
                         + vec_in(i,5,k) * Mat_y_tr(5,j) &
                         + vec_in(i,6,k) * Mat_y_tr(6,j) &
                         + vec_in(i,7,k) * Mat_y_tr(7,j) 
    end do
    end do
    end do
    
    ! Z-dir
    do k=1, 7
    do j=1, 7
    do i=1, 7
        vec_out_z(i,j,k) = vec_in(i,1,k) * Mat_z_tr(1,j) &
                         + vec_in(i,j,2) * Mat_z_tr(2,k) &
                         + vec_in(i,j,3) * Mat_z_tr(3,k) &
                         + vec_in(i,j,4) * Mat_z_tr(4,k) &
                         + vec_in(i,j,5) * Mat_z_tr(5,k) &
                         + vec_in(i,j,6) * Mat_z_tr(6,k) &
                         + vec_in(i,j,7) * Mat_z_tr(7,k) 
    end do
    end do
    end do

    return
  end subroutine element_operation_tensorprod3D_kernel_matrix_vec_gradlike_dirXYZ_P6

!> Calculate a matrix-vector multiplication associated with mathematical operations in the x, y, and z direction (third dimension of vec_in) with p=7
!! For a matrix-vector multiplication (vec_d_out = Mat_d vec_in where d=x,y,z), the passed variables of Mat_y and Mat_z should be transposed.
!! Note that we assume that vec_in_ has same data as vec_in, but are reshaped via the call of this subroutine. 
!!
!OCL SERIAL
  subroutine element_operation_tensorprod3D_kernel_matrix_vec_gradlike_dirXYZ_P7( Mat_x, Mat_y_tr, Mat_z_tr, vec_in, vec_in_, &
    vec_out_x, vec_out_y, vec_out_z  )
    implicit none
    real(RP), intent(in) :: Mat_x(8,8)
    real(RP), intent(in) :: Mat_y_tr(8,8)
    real(RP), intent(in) :: Mat_z_tr(8,8)
    real(RP), intent(in) :: vec_in_(8,8**2)
    real(RP), intent(in) :: vec_in(8,8,8)
    real(RP), intent(out) :: vec_out_x(8,8**2)
    real(RP), intent(out) :: vec_out_y(8,8,8)
    real(RP), intent(out) :: vec_out_z(8,8,8)

    integer :: i, j, k, jk
    !----------------------------------------------------------

    ! X-dir

    do jk=1, 8**2
    do i=1, 8
        vec_out_x(i,jk) = Mat_x(i,1) * vec_in_(1,jk) &
                        + Mat_x(i,2) * vec_in_(2,jk) &
                        + Mat_x(i,3) * vec_in_(3,jk) &
                        + Mat_x(i,4) * vec_in_(4,jk) &
                        + Mat_x(i,5) * vec_in_(5,jk) &
                        + Mat_x(i,6) * vec_in_(6,jk) &
                        + Mat_x(i,7) * vec_in_(7,jk) &
                        + Mat_x(i,8) * vec_in_(8,jk)
    end do
    end do

    ! Y-dir
    do k=1, 8
    do j=1, 8
    do i=1, 8
        vec_out_y(i,j,k) = vec_in(i,1,k) * Mat_y_tr(1,j) &
                         + vec_in(i,2,k) * Mat_y_tr(2,j) &
                         + vec_in(i,3,k) * Mat_y_tr(3,j) &
                         + vec_in(i,4,k) * Mat_y_tr(4,j) &
                         + vec_in(i,5,k) * Mat_y_tr(5,j) &
                         + vec_in(i,6,k) * Mat_y_tr(6,j) &
                         + vec_in(i,7,k) * Mat_y_tr(7,j) &
                         + vec_in(i,8,k) * Mat_y_tr(8,j) 
    end do
    end do
    end do
    
    ! Z-dir
    do k=1, 8
    do j=1, 8
    do i=1, 8
        vec_out_z(i,j,k) = vec_in(i,1,k) * Mat_z_tr(1,j) &
                         + vec_in(i,j,2) * Mat_z_tr(2,k) &
                         + vec_in(i,j,3) * Mat_z_tr(3,k) &
                         + vec_in(i,j,4) * Mat_z_tr(4,k) &
                         + vec_in(i,j,5) * Mat_z_tr(5,k) &
                         + vec_in(i,j,6) * Mat_z_tr(6,k) &
                         + vec_in(i,j,7) * Mat_z_tr(7,k) &
                         + vec_in(i,j,8) * Mat_z_tr(8,k) 
    end do
    end do
    end do

    return
  end subroutine element_operation_tensorprod3D_kernel_matrix_vec_gradlike_dirXYZ_P7

!> Calculate a matrix-vector multiplication associated with mathematical operations in the x, y, and z direction (third dimension of vec_in) with p=8
!! For a matrix-vector multiplication (vec_d_out = Mat_d vec_in where d=x,y,z), the passed variables of Mat_y and Mat_z should be transposed.
!! Note that we assume that vec_in_ has same data as vec_in, but are reshaped via the call of this subroutine. 
!!
!OCL SERIAL
  subroutine element_operation_tensorprod3D_kernel_matrix_vec_gradlike_dirXYZ_P8( Mat_x, Mat_y_tr, Mat_z_tr, vec_in, vec_in_, &
    vec_out_x, vec_out_y, vec_out_z  )
    implicit none
    real(RP), intent(in) :: Mat_x(9,9)
    real(RP), intent(in) :: Mat_y_tr(9,9)
    real(RP), intent(in) :: Mat_z_tr(9,9)
    real(RP), intent(in) :: vec_in_(9,9**2)
    real(RP), intent(in) :: vec_in(9,9,9)
    real(RP), intent(out) :: vec_out_x(9,9**2)
    real(RP), intent(out) :: vec_out_y(9,9,9)
    real(RP), intent(out) :: vec_out_z(9,9,9)

    integer :: i, j, k, jk
    !----------------------------------------------------------

    ! X-dir

    do jk=1, 9**2
    do i=1, 9
        vec_out_x(i,jk) = Mat_x(i,1) * vec_in_(1,jk) &
                        + Mat_x(i,2) * vec_in_(2,jk) &
                        + Mat_x(i,3) * vec_in_(3,jk) &
                        + Mat_x(i,4) * vec_in_(4,jk) &
                        + Mat_x(i,5) * vec_in_(5,jk) &
                        + Mat_x(i,6) * vec_in_(6,jk) &
                        + Mat_x(i,7) * vec_in_(7,jk) &
                        + Mat_x(i,8) * vec_in_(8,jk) &
                        + Mat_x(i,9) * vec_in_(9,jk)
    end do
    end do

    ! Y-dir
    do k=1, 9
    do j=1, 9
    do i=1, 9
        vec_out_y(i,j,k) = vec_in(i,1,k) * Mat_y_tr(1,j) &
                         + vec_in(i,2,k) * Mat_y_tr(2,j) &
                         + vec_in(i,3,k) * Mat_y_tr(3,j) &
                         + vec_in(i,4,k) * Mat_y_tr(4,j) &
                         + vec_in(i,5,k) * Mat_y_tr(5,j) &
                         + vec_in(i,6,k) * Mat_y_tr(6,j) &
                         + vec_in(i,7,k) * Mat_y_tr(7,j) &
                         + vec_in(i,8,k) * Mat_y_tr(8,j) &
                         + vec_in(i,9,k) * Mat_y_tr(9,j) 
    end do
    end do
    end do
    
    ! Z-dir
    do k=1, 9
    do j=1, 9
    do i=1, 9
        vec_out_z(i,j,k) = vec_in(i,1,k) * Mat_z_tr(1,j) &
                         + vec_in(i,j,2) * Mat_z_tr(2,k) &
                         + vec_in(i,j,3) * Mat_z_tr(3,k) &
                         + vec_in(i,j,4) * Mat_z_tr(4,k) &
                         + vec_in(i,j,5) * Mat_z_tr(5,k) &
                         + vec_in(i,j,6) * Mat_z_tr(6,k) &
                         + vec_in(i,j,7) * Mat_z_tr(7,k) &
                         + vec_in(i,j,8) * Mat_z_tr(8,k) &
                         + vec_in(i,j,9) * Mat_z_tr(9,k) 
    end do
    end do
    end do

    return
  end subroutine element_operation_tensorprod3D_kernel_matrix_vec_gradlike_dirXYZ_P8

!> Calculate a matrix-vector multiplication associated with mathematical operations in the x, y, and z direction (third dimension of vec_in) with p=9
!! For a matrix-vector multiplication (vec_d_out = Mat_d vec_in where d=x,y,z), the passed variables of Mat_y and Mat_z should be transposed.
!! Note that we assume that vec_in_ has same data as vec_in, but are reshaped via the call of this subroutine. 
!!
!OCL SERIAL
  subroutine element_operation_tensorprod3D_kernel_matrix_vec_gradlike_dirXYZ_P9( Mat_x, Mat_y_tr, Mat_z_tr, vec_in, vec_in_, &
    vec_out_x, vec_out_y, vec_out_z  )
    implicit none
    real(RP), intent(in) :: Mat_x(10,10)
    real(RP), intent(in) :: Mat_y_tr(10,10)
    real(RP), intent(in) :: Mat_z_tr(10,10)
    real(RP), intent(in) :: vec_in_(10,10**2)
    real(RP), intent(in) :: vec_in(10,10,10)
    real(RP), intent(out) :: vec_out_x(10,10**2)
    real(RP), intent(out) :: vec_out_y(10,10,10)
    real(RP), intent(out) :: vec_out_z(10,10,10)

    integer :: i, j, k, jk
    !----------------------------------------------------------

    ! X-dir

    do jk=1, 10**2
    do i=1, 10
        vec_out_x(i,jk) = Mat_x(i,1) * vec_in_(1,jk) &
                        + Mat_x(i,2) * vec_in_(2,jk) &
                        + Mat_x(i,3) * vec_in_(3,jk) &
                        + Mat_x(i,4) * vec_in_(4,jk) &
                        + Mat_x(i,5) * vec_in_(5,jk) &
                        + Mat_x(i,6) * vec_in_(6,jk) &
                        + Mat_x(i,7) * vec_in_(7,jk) &
                        + Mat_x(i,8) * vec_in_(8,jk) &
                        + Mat_x(i,9) * vec_in_(9,jk) &
                        + Mat_x(i,10) * vec_in_(10,jk)
    end do
    end do

    ! Y-dir
    do k=1, 10
    do j=1, 10
    do i=1, 10
        vec_out_y(i,j,k) = vec_in(i,1,k) * Mat_y_tr(1,j) &
                         + vec_in(i,2,k) * Mat_y_tr(2,j) &
                         + vec_in(i,3,k) * Mat_y_tr(3,j) &
                         + vec_in(i,4,k) * Mat_y_tr(4,j) &
                         + vec_in(i,5,k) * Mat_y_tr(5,j) &
                         + vec_in(i,6,k) * Mat_y_tr(6,j) &
                         + vec_in(i,7,k) * Mat_y_tr(7,j) &
                         + vec_in(i,8,k) * Mat_y_tr(8,j) &
                         + vec_in(i,9,k) * Mat_y_tr(9,j) &
                         + vec_in(i,10,k) * Mat_y_tr(10,j) 
    end do
    end do
    end do
    
    ! Z-dir
    do k=1, 10
    do j=1, 10
    do i=1, 10
        vec_out_z(i,j,k) = vec_in(i,1,k) * Mat_z_tr(1,j) &
                         + vec_in(i,j,2) * Mat_z_tr(2,k) &
                         + vec_in(i,j,3) * Mat_z_tr(3,k) &
                         + vec_in(i,j,4) * Mat_z_tr(4,k) &
                         + vec_in(i,j,5) * Mat_z_tr(5,k) &
                         + vec_in(i,j,6) * Mat_z_tr(6,k) &
                         + vec_in(i,j,7) * Mat_z_tr(7,k) &
                         + vec_in(i,j,8) * Mat_z_tr(8,k) &
                         + vec_in(i,j,9) * Mat_z_tr(9,k) &
                         + vec_in(i,j,10) * Mat_z_tr(10,k) 
    end do
    end do
    end do

    return
  end subroutine element_operation_tensorprod3D_kernel_matrix_vec_gradlike_dirXYZ_P9

!> Calculate a matrix-vector multiplication associated with mathematical operations in the x, y, and z direction (third dimension of vec_in) with p=10
!! For a matrix-vector multiplication (vec_d_out = Mat_d vec_in where d=x,y,z), the passed variables of Mat_y and Mat_z should be transposed.
!! Note that we assume that vec_in_ has same data as vec_in, but are reshaped via the call of this subroutine. 
!!
!OCL SERIAL
  subroutine element_operation_tensorprod3D_kernel_matrix_vec_gradlike_dirXYZ_P10( Mat_x, Mat_y_tr, Mat_z_tr, vec_in, vec_in_, &
    vec_out_x, vec_out_y, vec_out_z  )
    implicit none
    real(RP), intent(in) :: Mat_x(11,11)
    real(RP), intent(in) :: Mat_y_tr(11,11)
    real(RP), intent(in) :: Mat_z_tr(11,11)
    real(RP), intent(in) :: vec_in_(11,11**2)
    real(RP), intent(in) :: vec_in(11,11,11)
    real(RP), intent(out) :: vec_out_x(11,11**2)
    real(RP), intent(out) :: vec_out_y(11,11,11)
    real(RP), intent(out) :: vec_out_z(11,11,11)

    integer :: i, j, k, jk
    !----------------------------------------------------------

    ! X-dir

    do jk=1, 11**2
    do i=1, 11
        vec_out_x(i,jk) = Mat_x(i,1) * vec_in_(1,jk) &
                        + Mat_x(i,2) * vec_in_(2,jk) &
                        + Mat_x(i,3) * vec_in_(3,jk) &
                        + Mat_x(i,4) * vec_in_(4,jk) &
                        + Mat_x(i,5) * vec_in_(5,jk) &
                        + Mat_x(i,6) * vec_in_(6,jk) &
                        + Mat_x(i,7) * vec_in_(7,jk) &
                        + Mat_x(i,8) * vec_in_(8,jk) &
                        + Mat_x(i,9) * vec_in_(9,jk) &
                        + Mat_x(i,10) * vec_in_(10,jk) &
                        + Mat_x(i,11) * vec_in_(11,jk)
    end do
    end do

    ! Y-dir
    do k=1, 11
    do j=1, 11
    do i=1, 11
        vec_out_y(i,j,k) = vec_in(i,1,k) * Mat_y_tr(1,j) &
                         + vec_in(i,2,k) * Mat_y_tr(2,j) &
                         + vec_in(i,3,k) * Mat_y_tr(3,j) &
                         + vec_in(i,4,k) * Mat_y_tr(4,j) &
                         + vec_in(i,5,k) * Mat_y_tr(5,j) &
                         + vec_in(i,6,k) * Mat_y_tr(6,j) &
                         + vec_in(i,7,k) * Mat_y_tr(7,j) &
                         + vec_in(i,8,k) * Mat_y_tr(8,j) &
                         + vec_in(i,9,k) * Mat_y_tr(9,j) &
                         + vec_in(i,10,k) * Mat_y_tr(10,j) &
                         + vec_in(i,11,k) * Mat_y_tr(11,j) 
    end do
    end do
    end do
    
    ! Z-dir
    do k=1, 11
    do j=1, 11
    do i=1, 11
        vec_out_z(i,j,k) = vec_in(i,1,k) * Mat_z_tr(1,j) &
                         + vec_in(i,j,2) * Mat_z_tr(2,k) &
                         + vec_in(i,j,3) * Mat_z_tr(3,k) &
                         + vec_in(i,j,4) * Mat_z_tr(4,k) &
                         + vec_in(i,j,5) * Mat_z_tr(5,k) &
                         + vec_in(i,j,6) * Mat_z_tr(6,k) &
                         + vec_in(i,j,7) * Mat_z_tr(7,k) &
                         + vec_in(i,j,8) * Mat_z_tr(8,k) &
                         + vec_in(i,j,9) * Mat_z_tr(9,k) &
                         + vec_in(i,j,10) * Mat_z_tr(10,k) &
                         + vec_in(i,j,11) * Mat_z_tr(11,k) 
    end do
    end do
    end do

    return
  end subroutine element_operation_tensorprod3D_kernel_matrix_vec_gradlike_dirXYZ_P10

!> Calculate a matrix-vector multiplication associated with mathematical operations in the x, y, and z direction (third dimension of vec_in) with p=11
!! For a matrix-vector multiplication (vec_d_out = Mat_d vec_in where d=x,y,z), the passed variables of Mat_y and Mat_z should be transposed.
!! Note that we assume that vec_in_ has same data as vec_in, but are reshaped via the call of this subroutine. 
!!
!OCL SERIAL
  subroutine element_operation_tensorprod3D_kernel_matrix_vec_gradlike_dirXYZ_P11( Mat_x, Mat_y_tr, Mat_z_tr, vec_in, vec_in_, &
    vec_out_x, vec_out_y, vec_out_z  )
    implicit none
    real(RP), intent(in) :: Mat_x(12,12)
    real(RP), intent(in) :: Mat_y_tr(12,12)
    real(RP), intent(in) :: Mat_z_tr(12,12)
    real(RP), intent(in) :: vec_in_(12,12**2)
    real(RP), intent(in) :: vec_in(12,12,12)
    real(RP), intent(out) :: vec_out_x(12,12**2)
    real(RP), intent(out) :: vec_out_y(12,12,12)
    real(RP), intent(out) :: vec_out_z(12,12,12)

    integer :: i, j, k, jk
    !----------------------------------------------------------

    ! X-dir

    do jk=1, 12**2
    do i=1, 12
        vec_out_x(i,jk) = Mat_x(i,1) * vec_in_(1,jk) &
                        + Mat_x(i,2) * vec_in_(2,jk) &
                        + Mat_x(i,3) * vec_in_(3,jk) &
                        + Mat_x(i,4) * vec_in_(4,jk) &
                        + Mat_x(i,5) * vec_in_(5,jk) &
                        + Mat_x(i,6) * vec_in_(6,jk) &
                        + Mat_x(i,7) * vec_in_(7,jk) &
                        + Mat_x(i,8) * vec_in_(8,jk) &
                        + Mat_x(i,9) * vec_in_(9,jk) &
                        + Mat_x(i,10) * vec_in_(10,jk) &
                        + Mat_x(i,11) * vec_in_(11,jk) &
                        + Mat_x(i,12) * vec_in_(12,jk)
    end do
    end do

    ! Y-dir
    do k=1, 12
    do j=1, 12
    do i=1, 12
        vec_out_y(i,j,k) = vec_in(i,1,k) * Mat_y_tr(1,j) &
                         + vec_in(i,2,k) * Mat_y_tr(2,j) &
                         + vec_in(i,3,k) * Mat_y_tr(3,j) &
                         + vec_in(i,4,k) * Mat_y_tr(4,j) &
                         + vec_in(i,5,k) * Mat_y_tr(5,j) &
                         + vec_in(i,6,k) * Mat_y_tr(6,j) &
                         + vec_in(i,7,k) * Mat_y_tr(7,j) &
                         + vec_in(i,8,k) * Mat_y_tr(8,j) &
                         + vec_in(i,9,k) * Mat_y_tr(9,j) &
                         + vec_in(i,10,k) * Mat_y_tr(10,j) &
                         + vec_in(i,11,k) * Mat_y_tr(11,j) &
                         + vec_in(i,12,k) * Mat_y_tr(12,j) 
    end do
    end do
    end do
    
    ! Z-dir
    do k=1, 12
    do j=1, 12
    do i=1, 12
        vec_out_z(i,j,k) = vec_in(i,1,k) * Mat_z_tr(1,j) &
                         + vec_in(i,j,2) * Mat_z_tr(2,k) &
                         + vec_in(i,j,3) * Mat_z_tr(3,k) &
                         + vec_in(i,j,4) * Mat_z_tr(4,k) &
                         + vec_in(i,j,5) * Mat_z_tr(5,k) &
                         + vec_in(i,j,6) * Mat_z_tr(6,k) &
                         + vec_in(i,j,7) * Mat_z_tr(7,k) &
                         + vec_in(i,j,8) * Mat_z_tr(8,k) &
                         + vec_in(i,j,9) * Mat_z_tr(9,k) &
                         + vec_in(i,j,10) * Mat_z_tr(10,k) &
                         + vec_in(i,j,11) * Mat_z_tr(11,k) &
                         + vec_in(i,j,12) * Mat_z_tr(12,k) 
    end do
    end do
    end do

    return
  end subroutine element_operation_tensorprod3D_kernel_matrix_vec_gradlike_dirXYZ_P11

!> Calculate a matrix-vector multiplication associated with mathematical operations in the x, y, and z direction (third dimension of vec_in) with p=12
!! For a matrix-vector multiplication (vec_d_out = Mat_d vec_in where d=x,y,z), the passed variables of Mat_y and Mat_z should be transposed.
!! Note that we assume that vec_in_ has same data as vec_in, but are reshaped via the call of this subroutine. 
!!
!OCL SERIAL
  subroutine element_operation_tensorprod3D_kernel_matrix_vec_gradlike_dirXYZ_P12( Mat_x, Mat_y_tr, Mat_z_tr, vec_in, vec_in_, &
    vec_out_x, vec_out_y, vec_out_z  )
    implicit none
    real(RP), intent(in) :: Mat_x(13,13)
    real(RP), intent(in) :: Mat_y_tr(13,13)
    real(RP), intent(in) :: Mat_z_tr(13,13)
    real(RP), intent(in) :: vec_in_(13,13**2)
    real(RP), intent(in) :: vec_in(13,13,13)
    real(RP), intent(out) :: vec_out_x(13,13**2)
    real(RP), intent(out) :: vec_out_y(13,13,13)
    real(RP), intent(out) :: vec_out_z(13,13,13)

    integer :: i, j, k, jk
    !----------------------------------------------------------

    ! X-dir

    do jk=1, 13**2
    do i=1, 13
        vec_out_x(i,jk) = Mat_x(i,1) * vec_in_(1,jk) &
                        + Mat_x(i,2) * vec_in_(2,jk) &
                        + Mat_x(i,3) * vec_in_(3,jk) &
                        + Mat_x(i,4) * vec_in_(4,jk) &
                        + Mat_x(i,5) * vec_in_(5,jk) &
                        + Mat_x(i,6) * vec_in_(6,jk) &
                        + Mat_x(i,7) * vec_in_(7,jk) &
                        + Mat_x(i,8) * vec_in_(8,jk) &
                        + Mat_x(i,9) * vec_in_(9,jk) &
                        + Mat_x(i,10) * vec_in_(10,jk) &
                        + Mat_x(i,11) * vec_in_(11,jk) &
                        + Mat_x(i,12) * vec_in_(12,jk) &
                        + Mat_x(i,13) * vec_in_(13,jk)
    end do
    end do

    ! Y-dir
    do k=1, 13
    do j=1, 13
    do i=1, 13
        vec_out_y(i,j,k) = vec_in(i,1,k) * Mat_y_tr(1,j) &
                         + vec_in(i,2,k) * Mat_y_tr(2,j) &
                         + vec_in(i,3,k) * Mat_y_tr(3,j) &
                         + vec_in(i,4,k) * Mat_y_tr(4,j) &
                         + vec_in(i,5,k) * Mat_y_tr(5,j) &
                         + vec_in(i,6,k) * Mat_y_tr(6,j) &
                         + vec_in(i,7,k) * Mat_y_tr(7,j) &
                         + vec_in(i,8,k) * Mat_y_tr(8,j) &
                         + vec_in(i,9,k) * Mat_y_tr(9,j) &
                         + vec_in(i,10,k) * Mat_y_tr(10,j) &
                         + vec_in(i,11,k) * Mat_y_tr(11,j) &
                         + vec_in(i,12,k) * Mat_y_tr(12,j) &
                         + vec_in(i,13,k) * Mat_y_tr(13,j) 
    end do
    end do
    end do
    
    ! Z-dir
    do k=1, 13
    do j=1, 13
    do i=1, 13
        vec_out_z(i,j,k) = vec_in(i,1,k) * Mat_z_tr(1,j) &
                         + vec_in(i,j,2) * Mat_z_tr(2,k) &
                         + vec_in(i,j,3) * Mat_z_tr(3,k) &
                         + vec_in(i,j,4) * Mat_z_tr(4,k) &
                         + vec_in(i,j,5) * Mat_z_tr(5,k) &
                         + vec_in(i,j,6) * Mat_z_tr(6,k) &
                         + vec_in(i,j,7) * Mat_z_tr(7,k) &
                         + vec_in(i,j,8) * Mat_z_tr(8,k) &
                         + vec_in(i,j,9) * Mat_z_tr(9,k) &
                         + vec_in(i,j,10) * Mat_z_tr(10,k) &
                         + vec_in(i,j,11) * Mat_z_tr(11,k) &
                         + vec_in(i,j,12) * Mat_z_tr(12,k) &
                         + vec_in(i,j,13) * Mat_z_tr(13,k) 
    end do
    end do
    end do

    return
  end subroutine element_operation_tensorprod3D_kernel_matrix_vec_gradlike_dirXYZ_P12

!> Calculate a matrix-vector multiplication associated with mathematical operations in the x, y, and z direction (third dimension of vec_in) with p=13
!! For a matrix-vector multiplication (vec_d_out = Mat_d vec_in where d=x,y,z), the passed variables of Mat_y and Mat_z should be transposed.
!! Note that we assume that vec_in_ has same data as vec_in, but are reshaped via the call of this subroutine. 
!!
!OCL SERIAL
  subroutine element_operation_tensorprod3D_kernel_matrix_vec_gradlike_dirXYZ_P13( Mat_x, Mat_y_tr, Mat_z_tr, vec_in, vec_in_, &
    vec_out_x, vec_out_y, vec_out_z  )
    implicit none
    real(RP), intent(in) :: Mat_x(14,14)
    real(RP), intent(in) :: Mat_y_tr(14,14)
    real(RP), intent(in) :: Mat_z_tr(14,14)
    real(RP), intent(in) :: vec_in_(14,14**2)
    real(RP), intent(in) :: vec_in(14,14,14)
    real(RP), intent(out) :: vec_out_x(14,14**2)
    real(RP), intent(out) :: vec_out_y(14,14,14)
    real(RP), intent(out) :: vec_out_z(14,14,14)

    integer :: i, j, k, jk
    !----------------------------------------------------------

    ! X-dir

    do jk=1, 14**2
    do i=1, 14
        vec_out_x(i,jk) = Mat_x(i,1) * vec_in_(1,jk) &
                        + Mat_x(i,2) * vec_in_(2,jk) &
                        + Mat_x(i,3) * vec_in_(3,jk) &
                        + Mat_x(i,4) * vec_in_(4,jk) &
                        + Mat_x(i,5) * vec_in_(5,jk) &
                        + Mat_x(i,6) * vec_in_(6,jk) &
                        + Mat_x(i,7) * vec_in_(7,jk) &
                        + Mat_x(i,8) * vec_in_(8,jk) &
                        + Mat_x(i,9) * vec_in_(9,jk) &
                        + Mat_x(i,10) * vec_in_(10,jk) &
                        + Mat_x(i,11) * vec_in_(11,jk) &
                        + Mat_x(i,12) * vec_in_(12,jk) &
                        + Mat_x(i,13) * vec_in_(13,jk) &
                        + Mat_x(i,14) * vec_in_(14,jk)
    end do
    end do

    ! Y-dir
    do k=1, 14
    do j=1, 14
    do i=1, 14
        vec_out_y(i,j,k) = vec_in(i,1,k) * Mat_y_tr(1,j) &
                         + vec_in(i,2,k) * Mat_y_tr(2,j) &
                         + vec_in(i,3,k) * Mat_y_tr(3,j) &
                         + vec_in(i,4,k) * Mat_y_tr(4,j) &
                         + vec_in(i,5,k) * Mat_y_tr(5,j) &
                         + vec_in(i,6,k) * Mat_y_tr(6,j) &
                         + vec_in(i,7,k) * Mat_y_tr(7,j) &
                         + vec_in(i,8,k) * Mat_y_tr(8,j) &
                         + vec_in(i,9,k) * Mat_y_tr(9,j) &
                         + vec_in(i,10,k) * Mat_y_tr(10,j) &
                         + vec_in(i,11,k) * Mat_y_tr(11,j) &
                         + vec_in(i,12,k) * Mat_y_tr(12,j) &
                         + vec_in(i,13,k) * Mat_y_tr(13,j) &
                         + vec_in(i,14,k) * Mat_y_tr(14,j) 
    end do
    end do
    end do
    
    ! Z-dir
    do k=1, 14
    do j=1, 14
    do i=1, 14
        vec_out_z(i,j,k) = vec_in(i,1,k) * Mat_z_tr(1,j) &
                         + vec_in(i,j,2) * Mat_z_tr(2,k) &
                         + vec_in(i,j,3) * Mat_z_tr(3,k) &
                         + vec_in(i,j,4) * Mat_z_tr(4,k) &
                         + vec_in(i,j,5) * Mat_z_tr(5,k) &
                         + vec_in(i,j,6) * Mat_z_tr(6,k) &
                         + vec_in(i,j,7) * Mat_z_tr(7,k) &
                         + vec_in(i,j,8) * Mat_z_tr(8,k) &
                         + vec_in(i,j,9) * Mat_z_tr(9,k) &
                         + vec_in(i,j,10) * Mat_z_tr(10,k) &
                         + vec_in(i,j,11) * Mat_z_tr(11,k) &
                         + vec_in(i,j,12) * Mat_z_tr(12,k) &
                         + vec_in(i,j,13) * Mat_z_tr(13,k) &
                         + vec_in(i,j,14) * Mat_z_tr(14,k) 
    end do
    end do
    end do

    return
  end subroutine element_operation_tensorprod3D_kernel_matrix_vec_gradlike_dirXYZ_P13

end module scale_element_operation_tensorprod3D_kernel