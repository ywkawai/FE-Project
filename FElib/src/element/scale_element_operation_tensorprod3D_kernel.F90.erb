<% AUTOGEN_PMAX = 15 %>
!-------------------------------------------------------------------------------
! Warning: This file was generated from <%=__FILE__%>.
!          Do not edit this file.
!-------------------------------------------------------------------------------
!-------------------------------------------------------------------------------
!> module FElib / Element / Operation with 3D tensor product elements
!!
!! @par Description
!!           A module for providing kernels of matrix and vector operations assuming a 3D tensor product element with (p+1)^3 DOF
!!
!! @author Yuta Kawai, Xuanzhengbo Ren, and Team SCALE
!!
!<
#include "scaleFElib.h"
module scale_element_operation_tensorprod3D_kernel

  !-----------------------------------------------------------------------------
  !
  !++ used modules
  !
  use scale_precision

  use scale_element_base, only: &
    ElementBase3D, &
    ElementBase3D_Init, ElementBase3D_Final
  !-----------------------------------------------------------------------------
  implicit none
  private

  !-----------------------------------------------------------------------------
  !
  !++ Public type & procedure
  !  
% for p in 1..AUTOGEN_PMAX
  public :: element_operation_kernel_matvec_dirX_P<%=p%>
  public :: element_operation_kernel_matvec_dirY_P<%=p%>  
  public :: element_operation_kernel_matvec_dirZ_P<%=p%>
  public :: element_operation_kernel_matvec_Lift_hexahedral_P<%=p%>
  public :: element_operation_kernel_matvec_gradlike_dirXYZ_P<%=p%>
  public :: element_operation_kernel_matvec_divlike_dirXYZ_P<%=p%>
% end

contains
% for p in 1..AUTOGEN_PMAX
% np = p+1

!--- For p=<%=p%> ------------------------------------

!> Calculate a matrix-vector multiplication associated with mathematical operations in the x direction (first dimension of vec_in) with p=<%=p%>
!!
!OCL SERIAL
  subroutine element_operation_kernel_matvec_dirX_P<%=p%>( Mat_x, vec_in, vec_out )
    implicit none
    real(RP), intent(in) :: Mat_x(<%=np%>,<%=np%>)
    real(RP), intent(in) :: vec_in(<%=np%>,<%=np%>**2)
    real(RP), intent(out) :: vec_out(<%=np%>,<%=np%>**2)

    integer :: i, jk
    !----------------------------------------------------------

    do jk=1, <%=np%>**2
    do i=1, <%=np%>
        vec_out(i,jk) = Mat_x(i,1) * vec_in(1,jk) &
% for ii in 2..np-1
                      + Mat_x(i,<%=ii%>) * vec_in(<%=ii%>,jk) &
% end
                      + Mat_x(i,<%=np%>) * vec_in(<%=np%>,jk)
    end do
    end do

    return
  end subroutine element_operation_kernel_matvec_dirX_P<%=p%>

!> Calculate a matrix-vector multiplication associated with mathematical operations in the y direction (second dimension of vec_in) with p=<%=p%>
!! For a matrix-vector multiplication (vec_out = Mat_y vec_in), the passed variable of Mat_y should be transposed.
!!
!OCL SERIAL
  subroutine element_operation_kernel_matvec_dirY_P<%=p%>( Mat_y_tr, vec_in, vec_out )
    implicit none
    real(RP), intent(in) :: Mat_y_tr(<%=np%>,<%=np%>)
    real(RP), intent(in) :: vec_in(<%=np%>,<%=np%>,<%=np%>)
    real(RP), intent(out) :: vec_out(<%=np%>,<%=np%>,<%=np%>)

    integer :: i, j, k
    !----------------------------------------------------------

    do k=1, <%=np%>
    do j=1, <%=np%>
    do i=1, <%=np%>
        vec_out(i,j,k) = vec_in(i,1,k) * Mat_y_tr(1,j) &
% for jj in 2..np-1
                       + vec_in(i,<%=jj%>,k) * Mat_y_tr(<%=jj%>,j) &
% end
                       + vec_in(i,<%=np%>,k) * Mat_y_tr(<%=np%>,j) 
    end do
    end do
    end do

    return
  end subroutine element_operation_kernel_matvec_dirY_P<%=p%>

!> Calculate a matrix-vector multiplication associated with mathematical operations in the z direction (third dimension of vec_in) with p=<%=p%>
!! For a matrix-vector multiplication (vec_out = Mat_z vec_in), the passed variable of Mat_z should be transposed.
!!
!OCL SERIAL
  subroutine element_operation_kernel_matvec_dirZ_P<%=p%>( Mat_z_tr, vec_in, vec_out )
    implicit none
    real(RP), intent(in) :: Mat_z_tr(<%=np%>,<%=np%>)
    real(RP), intent(in) :: vec_in(<%=np%>,<%=np%>,<%=np%>)
    real(RP), intent(out) :: vec_out(<%=np%>,<%=np%>,<%=np%>)

    integer :: i, j, k
    !----------------------------------------------------------

    do k=1, <%=np%>
    do j=1, <%=np%>
    do i=1, <%=np%>
        vec_out(i,j,k) = vec_in(i,j,1) * Mat_z_tr(1,k) &
% for kk in 2..np-1
                       + vec_in(i,j,<%=kk%>) * Mat_z_tr(<%=kk%>,k) &
% end
                       + vec_in(i,j,<%=np%>) * Mat_z_tr(<%=np%>,k) 
    end do
    end do
    end do

    return
  end subroutine element_operation_kernel_matvec_dirZ_P<%=p%>

!> Calculate a matrix-vector multiplication associated with Lift operations with hexahedral element of p=<%=p%>
!!
!OCL SERIAL
  subroutine element_operation_kernel_matvec_Lift_hexahedral_P<%=p%>( Lift, vec_in, vec_out )
    implicit none
    real(RP), intent(in) :: Lift(<%=np%>,<%=np%>,<%=np%>,6)
    real(RP), intent(in) :: vec_in(<%=np%>,<%=np%>,6)
    real(RP), intent(out) :: vec_out(<%=np%>,<%=np%>,<%=np%>)

    integer :: i, j, k
    !----------------------------------------------------------

    do k=1, <%=np%>
    do j=1, <%=np%>
    do i=1, <%=np%>
        vec_out(i,j,k) = Lift(i,j,k,1) * vec_in(i,k,1) &
                       + Lift(i,j,k,2) * vec_in(j,k,2) &
                       + Lift(i,j,k,3) * vec_in(i,k,3) &
                       + Lift(i,j,k,4) * vec_in(j,k,4) &
                       + Lift(i,j,k,5) * vec_in(i,j,5) &
                       + Lift(i,j,k,6) * vec_in(i,j,6)
    end do
    end do
    end do

    return
  end subroutine element_operation_kernel_matvec_Lift_hexahedral_P<%=p%>
  
!> Calculate a matrix-vector multiplication associated with mathematical operations in the x, y, and z direction (third dimension of vec_in) with p=<%=p%>
!! For a matrix-vector multiplication (vec_d_out = Mat_d vec_in where d=x,y,z), the passed variables of Mat_y and Mat_z should be transposed.
!! Note that we assume that vec_in_ has same data as vec_in, but are reshaped via the call of this subroutine. 
!!
!OCL SERIAL
  subroutine element_operation_kernel_matvec_gradlike_dirXYZ_P<%=p%>( Mat, Mat_tr, vec_in, vec_in_, &
    vec_out_x, vec_out_y, vec_out_z  )
    implicit none
    real(RP), intent(in) :: Mat(<%=np%>,<%=np%>)
    real(RP), intent(in) :: Mat_tr(<%=np%>,<%=np%>)
    real(RP), intent(in) :: vec_in_(<%=np%>,<%=np%>**2)
    real(RP), intent(in) :: vec_in(<%=np%>,<%=np%>,<%=np%>)
    real(RP), intent(out) :: vec_out_x(<%=np%>,<%=np%>**2)
    real(RP), intent(out) :: vec_out_y(<%=np%>,<%=np%>,<%=np%>)
    real(RP), intent(out) :: vec_out_z(<%=np%>,<%=np%>,<%=np%>)

    integer :: i, j, k, jk
    !----------------------------------------------------------

    ! X-dir

    do jk=1, <%=np%>**2
    do i=1, <%=np%>
        vec_out_x(i,jk) = Mat(i,1) * vec_in_(1,jk) &
% for ii in 2..np-1
                        + Mat(i,<%=ii%>) * vec_in_(<%=ii%>,jk) &
% end
                        + Mat(i,<%=np%>) * vec_in_(<%=np%>,jk)
    end do
    end do

    ! Y-dir
    do k=1, <%=np%>
    do j=1, <%=np%>
    do i=1, <%=np%>
        vec_out_y(i,j,k) = vec_in(i,1,k) * Mat_tr(1,j) &
% for jj in 2..np-1
                         + vec_in(i,<%=jj%>,k) * Mat_tr(<%=jj%>,j) &
% end
                         + vec_in(i,<%=np%>,k) * Mat_tr(<%=np%>,j) 
    end do
    end do
    end do
    
    ! Z-dir
    do k=1, <%=np%>
    do j=1, <%=np%>
    do i=1, <%=np%>
        vec_out_z(i,j,k) = vec_in(i,1,k) * Mat_tr(1,j) &
% for kk in 2..np-1
                         + vec_in(i,j,<%=kk%>) * Mat_tr(<%=kk%>,k) &
% end
                         + vec_in(i,j,<%=np%>) * Mat_tr(<%=np%>,k) 
    end do
    end do
    end do

    return
  end subroutine element_operation_kernel_matvec_gradlike_dirXYZ_P<%=p%>

!> Calculate a matrix-vector multiplication associated with mathematical operations in the x, y, and z direction (third dimension of vec_in) with p=<%=p%>
!! For a matrix-vector multiplication (vec_d_out = Mat_d vec_d_in where d=x,y,z), the passed variables of Mat_y and Mat_z should be transposed.
!! Note that we assume that vec_in_ has same data as vec_in, but are reshaped via the call of this subroutine. 
!!
!OCL SERIAL
  subroutine element_operation_kernel_matvec_divlike_dirXYZ_P<%=p%>( &
    Mat, Mat_tr, vec_in_x, vec_in_y, vec_in_z, Escale, Gsqrt, vec_in_lift, sign_, &
    vec_out_x, vec_out_y, vec_out_z, vec_out  )
    implicit none
    real(RP), intent(in) :: Mat(<%=np%>,<%=np%>)
    real(RP), intent(in) :: Mat_tr(<%=np%>,<%=np%>)
    real(RP), intent(in) :: vec_in_x(<%=np%>,<%=np%>**2)
    real(RP), intent(in) :: vec_in_y(<%=np%>,<%=np%>,<%=np%>)
    real(RP), intent(in) :: vec_in_z(<%=np%>,<%=np%>,<%=np%>)
    real(RP), intent(in) :: Escale(3,<%=np%>,<%=np%>**2)
    real(RP), intent(in) :: Gsqrt(<%=np%>,<%=np%>**2)
    real(RP), intent(in) :: vec_in_lift(<%=np%>,<%=np%>**2)
    real(RP), intent(in) :: sign_
    real(RP), intent(out) :: vec_out_x(<%=np%>,<%=np%>**2)
    real(RP), intent(out) :: vec_out_y(<%=np%>,<%=np%>**2)
    real(RP), intent(out) :: vec_out_z(<%=np%>,<%=np%>**2)
    real(RP), intent(out) :: vec_out(<%=np%>,<%=np%>**2)

    integer :: i, j, k, jk
    !----------------------------------------------------------

    ! X-dir

    do jk=1, <%=np%>**2
    do i=1, <%=np%>
        vec_out_x(i,jk) = Mat(i,1) * vec_in_x(1,jk) &
% for ii in 2..np-1
                        + Mat(i,<%=ii%>) * vec_in_x(<%=ii%>,jk) &
% end
                        + Mat(i,<%=np%>) * vec_in_x(<%=np%>,jk)
    end do
    end do

    ! Y-dir
    do k=1, <%=np%>
    do j=1, <%=np%>
      jk = j + (k-1)*<%=np%>
      do i=1, <%=np%>
          vec_out_y(i,jk) = vec_in_y(i,1,k) * Mat_tr(1,j) &
% for jj in 2..np-1
                          + vec_in_y(i,<%=jj%>,k) * Mat_tr(<%=jj%>,j) &
% end
                          + vec_in_y(i,<%=np%>,k) * Mat_tr(<%=np%>,j) 
      end do
    end do
    end do
    
    ! Z-dir
    do k=1, <%=np%>
    do j=1, <%=np%>
      jk = j + (k-1)*<%=np%>
      do i=1, <%=np%>
          vec_out_z(i,jk) = vec_in_z(i,j,1) * Mat_tr(1,k) &
% for kk in 2..np-1
                          + vec_in_z(i,j,<%=kk%>) * Mat_tr(<%=kk%>,k) &
% end
                          + vec_in_z(i,j,<%=np%>) * Mat_tr(<%=np%>,k) 
      end do
    end do
    end do

    do jk=1, <%=np%>**2
    do i=1, <%=np%>
        vec_out(i,jk) = sign_ * (  Escale(1,i,jk) * vec_out_x(i,jk) + Escale(2,i,jk) * vec_out_y(i,jk) + Escale(3,i,jk) * vec_out_z(i,jk) &
                                 + vec_in_lift(i,jk) ) / Gsqrt(i,jk)
    end do
    end do
          
    return
  end subroutine element_operation_kernel_matvec_divlike_dirXYZ_P<%=p%>

% end

end module scale_element_operation_tensorprod3D_kernel