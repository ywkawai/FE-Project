<% AUTOGEN_VECMAX = 16 %>
!-------------------------------------------------------------------------------
! Warning: This file was generated from <%=__FILE__%>.
!          Do not edit this file.
!-------------------------------------------------------------------------------
!-------------------------------------------------------------------------------
!> module FElib / Fluid dyn solver / Atmosphere / HEVI / Common
!!
!! @par Description
!!      Computational kernels associated with linear algebra for vertical implicit solver
!!
!! @author Yuta Kawai, Team SCALE
!<
!-------------------------------------------------------------------------------
#include "scaleFElib.h"
module scale_atm_dyn_dgm_hevi_common_linalgebra
  !-----------------------------------------------------------------------------
  !
  !++ Used modules
  !
  use scale_precision
  use scale_io
  use scale_prc
  use scale_prof  
  !-----------------------------------------------------------------------------
  implicit none
  private
  !-----------------------------------------------------------------------------
  !
  !++ Public procedures
  !
  public :: atm_dyn_dgm_hevi_common_linalgebra_solve
  public :: atm_dyn_dgm_hevi_common_linalgebra_ludecomp

  !-----------------------------------------------------------------------------
  !
  !++ Public parameters & variables
  !
  
  !-----------------------------------------------------------------------------
  !
  !++ Private procedures & variables
  !
  !-------------------
contains
!OCL SERIAL
  subroutine atm_dyn_dgm_hevi_common_linalgebra_solve( D, b, ipiv, im, N )
    implicit none
    integer, intent(in) :: im
    integer, intent(in) :: N
    real(RP), intent(in) :: D(im,N,N)
    real(RP), intent(inout) :: b(im,N)
    integer, intent(out) :: ipiv(im,N)
    !------------------------------------------
    select case(im)
% for v in 1..AUTOGEN_VECMAX
    case( <%=v%> )
      call solve_vec<%=v%>( D, b, ipiv, N )
% end    
    case default
      LOG_INFO('atm_dyn_dgm_hevi_common_linalgebra_solve',*) "im > <%=AUTOGEN_VECMAX%> is not supported. Check!"
      call PRC_abort
    end select
    return
  end subroutine atm_dyn_dgm_hevi_common_linalgebra_solve

!OCL SERIAL
  subroutine atm_dyn_dgm_hevi_common_linalgebra_ludecomp( D, ipiv, im, N )
    implicit none
    integer, intent(in) :: im
    integer, intent(in) :: N
    real(RP), intent(inout) :: D(im,N,N)
    integer, intent(out) :: ipiv(im,N)
    !------------------------------------------
    select case(im)
% for v in 1..AUTOGEN_VECMAX
    case( <%=v%> )
      call ludecomp_vec<%=v%>( D, ipiv, N )
% end
    case default
      LOG_INFO('atm_dyn_dgm_hevi_common_linalgebra_ludecomp',*) "im > <%=AUTOGEN_VECMAX%> is not supported. Check!"
      call PRC_abort
    end select
    return
  end subroutine atm_dyn_dgm_hevi_common_linalgebra_ludecomp

!------
% for v in 1..AUTOGEN_VECMAX
!OCL SERIAL
  subroutine solve_vec<%=v%>( A, b, ipiv, N )
    implicit none
    integer, intent(in) :: N
    real(RP), intent(in) :: A(<%=v%>,N,N)
    real(RP), intent(inout) :: b(<%=v%>,N)
    integer, intent(out) :: ipiv(<%=v%>,N)

    integer :: k, i, j, v
    integer :: ip(<%=v%>)
    real(RP) :: tmp, tmpv(<%=v%>)
    !------------------------------
    do k=1, N-1
      ip(:) = ipiv(:,k)
      do v=1, <%=v%>
        tmp = b(v,k)
        b(v,k) = b(v,ip(v))
        b(v,ip(v)) = tmp
      end do
    end do
    do j=1, N-1
      tmpv(:) = b(:,j)
      do i=j+1, N
        b(:,i) = b(:,i) - tmpv(:) * A(:,i,j)
      end do
    end do
    do j=N, 1, -1
      b(:,j) = b(:,j) * A(:,j,j)
      do i=1, j-1
        b(:,i) = b(:,i) - A(:,i,j) * b(:,j)
      end do
    end do
    return
  end subroutine solve_vec<%=v%>

!OCL SERIAL
  subroutine ludecomp_vec<%=v%>( A, ipiv, N )
    implicit none
    integer, intent(in) :: N
    real(RP), intent(inout) :: A(<%=v%>,N,N)
    integer, intent(out) :: ipiv(<%=v%>,N)

    integer :: k, i, j, v
    integer :: ip(<%=v%>)
    real(RP) :: vmax(<%=v%>)
    real(RP) :: tmp
    real(RP) :: tmpv(<%=v%>)
    !------------------------------
    do k=1, N
      vmax(:) = abs(A(:,k,k))
      ip(:) = k
      do i=k+1, N
        do v=1, <%=v%>
          if ( abs(A(v,i,k)) > vmax(v) ) then
            ip(v) = i
            vmax(v) = abs(A(v,i,k))
          end if
        end do
      end do
      ipiv(:,k) = ip(:)
      do v=1, <%=v%>
        if (ip(v)/=k) then
          do j=1, N
            tmp = A(v,k,j)
            A(v,k,j) = A(v,ip(v),j)
            A(v,ip(v),j) = tmp
          end do
        end if
      end do
      !--
      tmpv(:) = 1.0_RP / A(:,k,k)
      A(:,k,k) = tmpv(:)
      do i=k+1, N
        A(:,i,k) = A(:,i,k) * tmpv(:)
      end do
      do j=k+1, N
        tmpv(:) = A(:,k,j)
        do i=k+1, N
          A(:,i,j) = A(:,i,j) - tmpv(:) * A(:,i,k)
        end do
      end do
    end do
    return
  end subroutine ludecomp_vec<%=v%>
% end

end module scale_atm_dyn_dgm_hevi_common_linalgebra
