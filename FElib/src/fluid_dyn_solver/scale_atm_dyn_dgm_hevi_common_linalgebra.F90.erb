<% AUTOGEN_VECMAX = 16 %>
<% VECLEN_list = { 2=>4, 3=>9, 4=>16, 5=>5, 6=>6, 7=>7, 8=>8, 9=>9, 10=>10, 11=>22, 12=>24, 13=>26, 14=>28, 15=>15, 16=>16 } %>
!-------------------------------------------------------------------------------
! Warning: This file was generated from <%=__FILE__%>.
!          Do not edit this file.
!-------------------------------------------------------------------------------
!-------------------------------------------------------------------------------
!> module FElib / Fluid dyn solver / Atmosphere / HEVI / Common
!!
!! @par Description
!!      Computational kernels associated with linear algebra for vertical implicit solvers
!!
!! @author Yuta Kawai, Xuanzhengbo Ren, and Team SCALE
!<
!-------------------------------------------------------------------------------
#include "scaleFElib.h"
module scale_atm_dyn_dgm_hevi_common_linalgebra
  !-----------------------------------------------------------------------------
  !
  !++ Used modules
  !
  use scale_precision
  use scale_io
  use scale_prc
  use scale_prof  
  !-----------------------------------------------------------------------------
  implicit none
  private
  !-----------------------------------------------------------------------------
  !
  !++ Public procedures
  !
  public :: atm_dyn_dgm_hevi_common_linalgebra_get_param
  public :: atm_dyn_dgm_hevi_common_linalgebra_solve_uv
  public :: atm_dyn_dgm_hevi_common_linalgebra_solve_var3

  !-----------------------------------------------------------------------------
  !
  !++ Public parameters & variables
  !
  
  !-----------------------------------------------------------------------------
  !
  !++ Private procedures & variables
  !
  !-------------------
contains
!OCL SERIAL
  subroutine atm_dyn_dgm_hevi_common_linalgebra_get_param( im, jm, Nnode_h1D )
    implicit none
    integer, intent(out) :: im
    integer, intent(out) :: jm
    integer, intent(in) :: Nnode_h1D
    !-----------------------------------------------------------
    select case(Nnode_h1D)
% for n in 2..AUTOGEN_VECMAX
    case( <%=n%> )
      im = <%=VECLEN_list[n]%>
% end
    end select
    jm = Nnode_h1D**2/im

    return
  end subroutine atm_dyn_dgm_hevi_common_linalgebra_get_param

!OCL SERIAL
  subroutine atm_dyn_dgm_hevi_common_linalgebra_solve_uv( D, b, G, Nnode_v, im, jm, Ne2D, is_top )
    implicit none
    integer, intent(in) :: Nnode_v
    integer, intent(in) :: im, jm
    integer, intent(in) :: Ne2D
    real(RP), intent(in) :: D(im,Nnode_v,Nnode_v,jm,Ne2D)
    real(RP), intent(inout) :: b(im,Nnode_v,2,jm,Ne2D)
    real(RP), intent(inout) :: G(im,Nnode_v,jm,Ne2D)
    logical, intent(in) :: is_top
    !------------------------------------------
    select case(Nnode_v)
% for n in 2..AUTOGEN_VECMAX
%  veclen=VECLEN_list[n]
    case( <%=n%> )
      if ( im == <%=veclen%> ) then
        call solve_Nnode<%=n%>_uv( D, b, G, Nnode_v, jm, Ne2D, is_top )
      else
        call solve_uv_im( D, b, G, Nnode_v, im, jm, Ne2D, is_top )
      end if
% end        
    case default
      LOG_INFO('atm_dyn_dgm_hevi_common_linalgebra_solve_uv',*) "im > <%=AUTOGEN_VECMAX%> is not supported. Check!"
      call PRC_abort
    end select
    return
  end subroutine atm_dyn_dgm_hevi_common_linalgebra_solve_uv

!OCL SERIAL
  subroutine atm_dyn_dgm_hevi_common_linalgebra_solve_var3( D, b, G, Nnode_v, im, jm, Ne2D, is_top)
    implicit none
    integer, intent(in) :: Nnode_v
    integer, intent(in) :: im, jm
    integer, intent(in) :: Ne2D
    real(RP), intent(in) :: D(im,3*Nnode_v,3*Nnode_v,jm,Ne2D)
    real(RP), intent(inout) :: b(im,3*Nnode_v,jm,Ne2D)
    real(RP), intent(inout) :: G(im,3*Nnode_v,3,jm,Ne2D)
    logical, intent(in) :: is_top
    !------------------------------------------
    select case(Nnode_v)
% for n in 2..AUTOGEN_VECMAX
%   veclen=VECLEN_list[n]
      case( <%=n%> )
        if ( im == <%=veclen%> ) then
          call solve_Nnode<%=n%>_var3( D, b, G, Nnode_v, jm, Ne2D, is_top )
        else
          call solve_var3_im( D, b, G, Nnode_v, im, jm, Ne2D, is_top )
        end if
% end    
      case default
        LOG_INFO('atm_dyn_dgm_hevi_common_linalgebra_solve',*) "im > <%=AUTOGEN_VECMAX%> is not supported. Check!"
        call PRC_abort
    end select
    return
  end subroutine atm_dyn_dgm_hevi_common_linalgebra_solve_var3

!------
% for n in 2..AUTOGEN_VECMAX
%   veclen=VECLEN_list[n]
!OCL SERIAL
  subroutine solve_Nnode<%=n%>_uv( D, b, G, Nnode_v, jm, Ne2D, is_top )
    implicit none
    integer, intent(in) :: Nnode_v
    integer, intent(in) :: jm
    integer, intent(in) :: Ne2D
    real(RP), intent(in) :: D(<%=veclen%>,<%=n%>,<%=n%>,jm,Ne2D)
    real(RP), intent(inout) :: b(<%=veclen%>,<%=n%>,2,jm,Ne2D)
    real(RP), intent(inout) :: G(<%=veclen%>,<%=n%>,jm,Ne2D)
    logical, intent(in) :: is_top

    integer :: ke_xy
    integer :: v2
    integer :: k, i, j, v, r
    integer :: ip
    integer :: ipiv(<%=veclen%>,<%=n%>)
    real(RP) :: tmpv(<%=veclen%>)
    real(RP) :: tmpv2(<%=veclen%>)
    real(RP) :: A(<%=veclen%>,<%=n%>,<%=n%>)
    real(RP) :: bb(<%=veclen%>,3,<%=n%>)
    real(RP) :: tmpb(<%=veclen%>,3)
    real(RP) :: tmp
    !------------------------------

    !$omp parallel do private(ke_xy,v2,k,i,j,v,r,ip,ipiv,tmpv,tmpv2,tmpb,tmp,bb,A) collapse(2)
    do ke_xy=1, Ne2D
    do v2=1, jm
      A(:,:,:) = D(:,:,:,v2,ke_xy)
      do k=1, <%=n%>
        tmpv(:) = abs(A(:,k,k))
        ipiv(:,k) = k
        do i=k+1, <%=n%>
          do v=1, <%=veclen%>
            tmp = abs(A(v,i,k)) 
            if (  tmp > tmpv(v) ) then
              ipiv(v,k) = i
              tmpv(v) = tmp
            end if
          end do
        end do
        do v=1, <%=veclen%>
          ip = ipiv(v,k) 
          if ( ip /= k ) then
            do j=1, <%=n%>
              tmp = A(v,k,j)
              A(v,k,j) = A(v,ip,j)
              A(v,ip,j) = tmp
          end do
          end if
        end do
        !--
        tmpv(:) = 1.0_RP / A(:,k,k)
        A(:,k,k) = tmpv(:)      
        do i=k+1, <%=n%>
          A(:,i,k) = A(:,i,k) * tmpv(:)
        end do
        do j=k+1, <%=n%>      
          do i=k+1, <%=n%>
            do v=1, <%=veclen%>
              A(v,i,j) = A(v,i,j) - A(v,i,k) * A(v,k,j)
            end do
          end do
        end do
      end do
      !---------------------------
      if ( is_top ) then
        do i=1, <%=n%>-1
          do v=1, <%=veclen%>
            ip = ipiv(v,i)
            if (ip /= i) then
              tmp = b(v,i,1,v2,ke_xy)
              b(v,i,1,v2,ke_xy) = b(v,ip,1,v2,ke_xy)
              b(v,ip,1,v2,ke_xy) = tmp
              tmp = b(v,i,2,v2,ke_xy)
              b(v,i,2,v2,ke_xy) = b(v,ip,2,v2,ke_xy)
              b(v,ip,2,v2,ke_xy) = tmp
            end if
          end do
        end do
        do i=1, <%=n%>
          tmpv (:) = b(:,i,1,v2,ke_xy)
          tmpv2(:) = b(:,i,2,v2,ke_xy)
          do j=1, i-1
            tmpv (:) = tmpv (:) - b(:,j,1,v2,ke_xy) * A(:,i,j)
            tmpv2(:) = tmpv2(:) - b(:,j,2,v2,ke_xy) * A(:,i,j)
          end do
          b(:,i,1,v2,ke_xy) = tmpv (:)
          b(:,i,2,v2,ke_xy) = tmpv2(:)
        end do
        do i=<%=n%>, 1, -1
          tmpv (:) = b(:,i,1,v2,ke_xy)
          tmpv2(:) = b(:,i,2,v2,ke_xy)
          do j=i+1, <%=n%>
            tmpv (:) = tmpv (:) - A(:,i,j) * b(:,j,1,v2,ke_xy)
            tmpv2(:) = tmpv2(:) - A(:,i,j) * b(:,j,2,v2,ke_xy)
          end do
          b(:,i,1,v2,ke_xy) = tmpv (:) * A(:,i,i)
          b(:,i,2,v2,ke_xy) = tmpv2(:) * A(:,i,i)
        end do
      else
        do i=1, <%=n%>-1
          do v=1, <%=veclen%>
            ip = ipiv(v,i)
            if (ip /= i) then
              tmp = b(v,i,1,v2,ke_xy)
              b(v,i,1,v2,ke_xy) = b(v,ip,1,v2,ke_xy)
              b(v,ip,1,v2,ke_xy) = tmp
              tmp = b(v,i,2,v2,ke_xy)
              b(v,i,2,v2,ke_xy) = b(v,ip,2,v2,ke_xy)
              b(v,ip,2,v2,ke_xy) = tmp

              tmp = G(v,i,v2,ke_xy)
              G(v,i,v2,ke_xy) = G(v,ip,v2,ke_xy)
              G(v,ip,v2,ke_xy) = tmp
            end if
          end do
        end do        
        do i=1, <%=n%>
          do v=1,<%=veclen%>
            bb(v,1,i) = b(v,i,1,v2,ke_xy)
            bb(v,2,i) = b(v,i,2,v2,ke_xy)
            bb(v,3,i) = G(v,i,v2,ke_xy)
          end do
        end do
        do i=1, <%=n%>
          tmpb(:,:) = bb(:,:,i)
          do j=1, i-1
            do r=1, 3
              tmpb(:,r) = tmpb(:,r) - bb(:,r,j) * A(:,i,j)
            end do
          end do
          bb(:,:,i) = tmpb(:,:)
        end do
        do i=<%=n%>, 1, -1
          tmpb(:,:) = bb(:,:,i)
          do j=i+1, <%=n%>
            do r=1, 3
              tmpb(:,r) = tmpb(:,r) - A(:,i,j) * bb(:,r,j)
            end do
          end do
          do r=1, 3
            bb(:,r,i) = tmpb(:,r) * A(:,i,i)
          end do
        end do
        do i=1, <%=n%>
          b(:,i,1,v2,ke_xy) = bb(:,1,i)
          b(:,i,2,v2,ke_xy) = bb(:,2,i)
          G(:,i,v2,ke_xy) = bb(:,3,i)
        end do
      end if
    end do
    end do
    return
  end subroutine solve_Nnode<%=n%>_uv
!OCL SERIAL
  subroutine solve_Nnode<%=n%>_var3( D, b, G, Nnode_v, jm, Ne2D, is_top )
    implicit none
    integer, intent(in) :: Nnode_v
    integer, intent(in) :: jm
    integer, intent(in) :: Ne2D
    real(RP), intent(in) :: D(<%=veclen%>,<%=3*n%>,<%=3*n%>,jm,Ne2D)
    real(RP), intent(inout) :: b(<%=veclen%>,<%=3*n%>,jm,Ne2D)
    real(RP), intent(inout) :: G(<%=veclen%>,<%=3*n%>,3,jm,Ne2D)
    logical, intent(in) :: is_top

    integer :: ke_xy
    integer :: v2
    integer :: k, i, j, v, r
    integer :: ip
    integer :: ipiv(<%=veclen%>,<%=3*n%>)
    real(RP) :: tmpv(<%=veclen%>)
    real(RP) :: A(<%=veclen%>,<%=3*n%>,<%=3*n%>)
    real(RP) :: bb(<%=veclen%>,4,<%=3*n%>)
    real(RP) :: tmpb(<%=veclen%>,4)
    real(RP) :: tmp
    !------------------------------

    !$omp parallel do collapse(2) private(ke_xy,v2,k,i,j,v,r,ip,ipiv,tmpv,tmpb,tmp,bb,A)
    do ke_xy=1, Ne2D
    do v2=1, jm
      A(:,:,:) = D(:,:,:,v2,ke_xy)
      do k=1, <%=3*n%>
        tmpv(:) = abs(A(:,k,k))
        ipiv(:,k) = k
        do i=k+1, <%=3*n%>
          do v=1, <%=veclen%>
            tmp = abs(A(v,i,k)) 
            if (  tmp > tmpv(v) ) then
              ipiv(v,k) = i
              tmpv(v) = tmp
            end if
          end do
        end do
        do v=1, <%=veclen%>
          ip = ipiv(v,k) 
          if ( ip /= k ) then
            do j=1, <%=3*n%>
              tmp = A(v,k,j)
              A(v,k,j) = A(v,ip,j)
              A(v,ip,j) = tmp
          end do
          end if
        end do
        !--
        tmpv(:) = 1.0_RP / A(:,k,k)
        A(:,k,k) = tmpv(:)      
        do i=k+1, <%=3*n%>
          do v=1, <%=veclen%>
            A(v,i,k) = A(v,i,k) * tmpv(v)
          end do
        end do
        do j=k+1, <%=3*n%>      
          do i=k+1, <%=3*n%>
            do v=1, <%=veclen%>
              A(v,i,j) = A(v,i,j) - A(v,i,k) * A(v,k,j)
            end do
          end do
        end do
      end do
      !---------------------------
      if ( is_top ) then
        do i=1, <%=3*n%>-1
          do v=1, <%=veclen%>
            ip = ipiv(v,i)
            if (ip /= i) then
              tmp = b(v,i,v2,ke_xy)
              b(v,i,v2,ke_xy) = b(v,ip,v2,ke_xy)
              b(v,ip,v2,ke_xy) = tmp
            end if
          end do
        end do
        do i=1, <%=3*n%>
          tmpv(:) = b(:,i,v2,ke_xy)
          do j=1, i-1
            tmpv(:) = tmpv(:) - b(:,j,v2,ke_xy) * A(:,i,j)
          end do
          b(:,i,v2,ke_xy) = tmpv(:)
        end do
        do i=<%=3*n%>, 1, -1
          tmpv(:) = b(:,i,v2,ke_xy)
          do j=i+1, <%=3*n%>
            tmpv(:) = tmpv(:) - A(:,i,j) * b(:,j,v2,ke_xy)
          end do
          b(:,i,v2,ke_xy) = tmpv(:) * A(:,i,i)
        end do
      else
        do i=1, <%=3*n%>-1
          do v=1, <%=veclen%>
            ip = ipiv(v,i)
            if (ip /= i) then
              tmp = b(v,i,v2,ke_xy)
              b(v,i,v2,ke_xy) = b(v,ip,v2,ke_xy)
              b(v,ip,v2,ke_xy) = tmp

              tmp = G(v,i,1,v2,ke_xy)
              G(v,i,1,v2,ke_xy) = G(v,ip,1,v2,ke_xy)
              G(v,ip,1,v2,ke_xy) = tmp
              tmp = G(v,i,2,v2,ke_xy)
              G(v,i,2,v2,ke_xy) = G(v,ip,2,v2,ke_xy)
              G(v,ip,2,v2,ke_xy) = tmp
              tmp = G(v,i,3,v2,ke_xy)
              G(v,i,3,v2,ke_xy) = G(v,ip,3,v2,ke_xy)
              G(v,ip,3,v2,ke_xy) = tmp
            end if
          end do
        end do        
        do i=1, <%=3*n%>
          do v=1,<%=veclen%>
            bb(v,1,i) = b(v,i,v2,ke_xy)
            bb(v,2,i) = G(v,i,1,v2,ke_xy)
            bb(v,3,i) = G(v,i,2,v2,ke_xy)
            bb(v,4,i) = G(v,i,3,v2,ke_xy)
          end do
        end do
        do i=1, <%=3*n%>
          tmpb(:,:) = bb(:,:,i)
          do j=1, i-1
            do r=1, 4
              tmpb(:,r) = tmpb(:,r) - bb(:,r,j) * A(:,i,j)
            end do
          end do
          bb(:,:,i) = tmpb(:,:)
        end do
        do i=<%=3*n%>, 1, -1
          tmpb(:,:) = bb(:,:,i)
          do j=i+1, <%=3*n%>
            do r=1, 4
              tmpb(:,r) = tmpb(:,r) - A(:,i,j) * bb(:,r,j)
            end do
          end do
          do r=1, 4
            bb(:,r,i) = tmpb(:,r) * A(:,i,i)
          end do
        end do
        do i=1, <%=3*n%>
          b(:,i,v2,ke_xy) = bb(:,1,i)
          G(:,i,1,v2,ke_xy) = bb(:,2,i)
          G(:,i,2,v2,ke_xy) = bb(:,3,i)
          G(:,i,3,v2,ke_xy) = bb(:,4,i)
        end do
      end if
    end do
    end do
    return
  end subroutine solve_Nnode<%=n%>_var3  
% end
!OCL SERIAL
  subroutine solve_uv_im( D, b, G, Nnode_v, im, jm, Ne2D, is_top )
    implicit none
    integer, intent(in) :: Nnode_v
    integer, intent(in) :: im, jm
    integer, intent(in) :: Ne2D
    real(RP), intent(in) :: D(im,Nnode_v,Nnode_v,jm,Ne2D)
    real(RP), intent(inout) :: b(im,Nnode_v,2,jm,Ne2D)
    real(RP), intent(inout) :: G(im,Nnode_v,jm,Ne2D)
    logical, intent(in) :: is_top

    integer :: ke_xy
    integer :: v2
    integer :: k, i, j, v, r
    integer :: ip
    integer :: ipiv(im,Nnode_v)
    real(RP) :: tmpv(im)
    real(RP) :: tmpv2(im)
    real(RP) :: A(im,Nnode_v,Nnode_v)
    real(RP) :: bb(im,3,Nnode_v)
    real(RP) :: tmpb(im,3)
    real(RP) :: tmp
    !------------------------------

    !$omp parallel do private(ke_xy,v2,k,i,j,v,r,ip,ipiv,tmpv,tmpv2,tmpb,tmp,bb,A) collapse(2)
    do ke_xy=1, Ne2D
    do v2=1, jm
      A(:,:,:) = D(:,:,:,v2,ke_xy)
      do k=1, Nnode_v
        tmpv(:) = abs(A(:,k,k))
        ipiv(:,k) = k
        do i=k+1, Nnode_v
          do v=1, im
            tmp = abs(A(v,i,k)) 
            if (  tmp > tmpv(v) ) then
              ipiv(v,k) = i
              tmpv(v) = tmp
            end if
          end do
        end do
        do v=1, im
          ip = ipiv(v,k) 
          if ( ip /= k ) then
            do j=1, Nnode_v
              tmp = A(v,k,j)
              A(v,k,j) = A(v,ip,j)
              A(v,ip,j) = tmp
          end do
          end if
        end do
        !--
        tmpv(:) = 1.0_RP / A(:,k,k)
        A(:,k,k) = tmpv(:)      
        do i=k+1, Nnode_v
          A(:,i,k) = A(:,i,k) * tmpv(:)
        end do
        do j=k+1, Nnode_v     
          do i=k+1, Nnode_v
            do v=1, im
              A(v,i,j) = A(v,i,j) - A(v,i,k) * A(v,k,j)
            end do
          end do
        end do
      end do
      !---------------------------
      if ( is_top ) then
        do i=1, Nnode_v-1
          do v=1, im
            ip = ipiv(v,i)
            if (ip /= i) then
              tmp = b(v,i,1,v2,ke_xy)
              b(v,i,1,v2,ke_xy) = b(v,ip,1,v2,ke_xy)
              b(v,ip,1,v2,ke_xy) = tmp
              tmp = b(v,i,2,v2,ke_xy)
              b(v,i,2,v2,ke_xy) = b(v,ip,2,v2,ke_xy)
              b(v,ip,2,v2,ke_xy) = tmp
            end if
          end do
        end do
        do i=1, Nnode_v
          tmpv (:) = b(:,i,1,v2,ke_xy)
          tmpv2(:) = b(:,i,2,v2,ke_xy)
          do j=1, i-1
            tmpv (:) = tmpv (:) - b(:,j,1,v2,ke_xy) * A(:,i,j)
            tmpv2(:) = tmpv2(:) - b(:,j,2,v2,ke_xy) * A(:,i,j)
          end do
          b(:,i,1,v2,ke_xy) = tmpv (:)
          b(:,i,2,v2,ke_xy) = tmpv2(:)
        end do
        do i=Nnode_v, 1, -1
          tmpv (:) = b(:,i,1,v2,ke_xy)
          tmpv2(:) = b(:,i,2,v2,ke_xy)
          do j=i+1, Nnode_v
            tmpv (:) = tmpv (:) - A(:,i,j) * b(:,j,1,v2,ke_xy)
            tmpv2(:) = tmpv2(:) - A(:,i,j) * b(:,j,2,v2,ke_xy)
          end do
          b(:,i,1,v2,ke_xy) = tmpv (:) * A(:,i,i)
          b(:,i,2,v2,ke_xy) = tmpv2(:) * A(:,i,i)
        end do
      else
        do i=1, Nnode_v-1
          do v=1, im
            ip = ipiv(v,i)
            if (ip /= i) then
              tmp = b(v,i,1,v2,ke_xy)
              b(v,i,1,v2,ke_xy) = b(v,ip,1,v2,ke_xy)
              b(v,ip,1,v2,ke_xy) = tmp
              tmp = b(v,i,2,v2,ke_xy)
              b(v,i,2,v2,ke_xy) = b(v,ip,2,v2,ke_xy)
              b(v,ip,2,v2,ke_xy) = tmp

              tmp = G(v,i,v2,ke_xy)
              G(v,i,v2,ke_xy) = G(v,ip,v2,ke_xy)
              G(v,ip,v2,ke_xy) = tmp
            end if
          end do
        end do        
        do i=1, Nnode_v
          do v=1,im
            bb(v,1,i) = b(v,i,1,v2,ke_xy)
            bb(v,2,i) = b(v,i,2,v2,ke_xy)
            bb(v,3,i) = G(v,i,v2,ke_xy)
          end do
        end do
        do i=1, Nnode_v
          tmpb(:,:) = bb(:,:,i)
          do j=1, i-1
            do r=1, 3
              tmpb(:,r) = tmpb(:,r) - bb(:,r,j) * A(:,i,j)
            end do
          end do
          bb(:,:,i) = tmpb(:,:)
        end do
        do i=Nnode_v, 1, -1
          tmpb(:,:) = bb(:,:,i)
          do j=i+1, Nnode_v
            do r=1, 3
              tmpb(:,r) = tmpb(:,r) - A(:,i,j) * bb(:,r,j)
            end do
          end do
          do r=1, 3
            bb(:,r,i) = tmpb(:,r) * A(:,i,i)
          end do
        end do
        do i=1, Nnode_v
          b(:,i,1,v2,ke_xy) = bb(:,1,i)
          b(:,i,2,v2,ke_xy) = bb(:,2,i)
          G(:,i,v2,ke_xy) = bb(:,3,i)
        end do
      end if
    end do
    end do
    return
  end subroutine solve_uv_im

!OCL SERIAL
  subroutine solve_var3_im( D, b, G, Nnode_v, im, jm, Ne2D, is_top )
    implicit none
    integer, intent(in) :: Nnode_v
    integer, intent(in) :: im, jm
    integer, intent(in) :: Ne2D
    real(RP), intent(in) :: D(im,3*Nnode_v,3*Nnode_v,jm,Ne2D)
    real(RP), intent(inout) :: b(im,3*Nnode_v,jm,Ne2D)
    real(RP), intent(inout) :: G(im,3*Nnode_v,3,jm,Ne2D)
    logical, intent(in) :: is_top

    integer :: ke_xy
    integer :: v2
    integer :: k, i, j, v, r
    integer :: ip
    integer :: ipiv(im,3*Nnode_v)
    real(RP) :: tmpv(im)
    real(RP) :: A(im,3*Nnode_v,3*Nnode_v)
    real(RP) :: bb(im,4,3*Nnode_v)
    real(RP) :: tmpb(im,4)
    real(RP) :: tmp
    integer :: Nnode_vx3
    !------------------------------

    Nnode_vx3 = Nnode_v * 3

    !$omp parallel do private(ke_xy,v2,k,i,j,v,r,ip,ipiv,tmpv,tmpb,tmp,bb,A) collapse(2)
    do ke_xy=1, Ne2D
    do v2=1, jm
      A(:,:,:) = D(:,:,:,v2,ke_xy)
      do k=1, Nnode_vx3
        tmpv(:) = abs(A(:,k,k))
        ipiv(:,k) = k
        do i=k+1, Nnode_vx3
          do v=1, im
            tmp = abs(A(v,i,k)) 
            if (  tmp > tmpv(v) ) then
              ipiv(v,k) = i
              tmpv(v) = tmp
            end if
          end do
        end do
        do v=1, im
          ip = ipiv(v,k) 
          if ( ip /= k ) then
            do j=1, Nnode_vx3
              tmp = A(v,k,j)
              A(v,k,j) = A(v,ip,j)
              A(v,ip,j) = tmp
          end do
          end if
        end do
        !--
        tmpv(:) = 1.0_RP / A(:,k,k)
        A(:,k,k) = tmpv(:)      
        do i=k+1, Nnode_vx3
          A(:,i,k) = A(:,i,k) * tmpv(:)
        end do
        do j=k+1, Nnode_vx3
          do i=k+1, Nnode_vx3
            do v=1, im
              A(v,i,j) = A(v,i,j) - A(v,i,k) * A(v,k,j)
            end do
          end do
        end do
      end do
      !---------------------------
      if ( is_top ) then
        do i=1, Nnode_vx3-1
          do v=1, im
            ip = ipiv(v,i)
            if (ip /= i) then
              tmp = b(v,i,v2,ke_xy)
              b(v,i,v2,ke_xy) = b(v,ip,v2,ke_xy)
              b(v,ip,v2,ke_xy) = tmp
            end if
          end do
        end do
        do i=1, Nnode_vx3
          tmpv(:) = b(:,i,v2,ke_xy)
          do j=1, i-1
            tmpv(:) = tmpv(:) - b(:,j,v2,ke_xy) * A(:,i,j)
          end do
          b(:,i,v2,ke_xy) = tmpv(:)
        end do
        do i=Nnode_vx3, 1, -1
          tmpv(:) = b(:,i,v2,ke_xy)
          do j=i+1, Nnode_vx3
            tmpv(:) = tmpv(:) - A(:,i,j) * b(:,j,v2,ke_xy)
          end do
          b(:,i,v2,ke_xy) = tmpv(:) * A(:,i,i)
        end do
      else
        do i=1, Nnode_vx3-1
          do v=1, im
            ip = ipiv(v,i)
            if (ip /= i) then
              tmp = b(v,i,v2,ke_xy)
              b(v,i,v2,ke_xy) = b(v,ip,v2,ke_xy)
              b(v,ip,v2,ke_xy) = tmp

              tmp = G(v,i,1,v2,ke_xy)
              G(v,i,1,v2,ke_xy) = G(v,ip,1,v2,ke_xy)
              G(v,ip,1,v2,ke_xy) = tmp
              tmp = G(v,i,2,v2,ke_xy)
              G(v,i,2,v2,ke_xy) = G(v,ip,2,v2,ke_xy)
              G(v,ip,2,v2,ke_xy) = tmp
              tmp = G(v,i,3,v2,ke_xy)
              G(v,i,3,v2,ke_xy) = G(v,ip,3,v2,ke_xy)
              G(v,ip,3,v2,ke_xy) = tmp
            end if
          end do
        end do        
        do i=1, Nnode_vx3
          do v=1, im
            bb(v,1,i) = b(v,i,v2,ke_xy)
            bb(v,2,i) = G(v,i,1,v2,ke_xy)
            bb(v,3,i) = G(v,i,2,v2,ke_xy)
            bb(v,4,i) = G(v,i,3,v2,ke_xy)
          end do
        end do
        do i=1, Nnode_vx3
          tmpb(:,:) = bb(:,:,i)
          do j=1, i-1
            do r=1, 4
              tmpb(:,r) = tmpb(:,r) - bb(:,r,j) * A(:,i,j)
            end do
          end do
          bb(:,:,i) = tmpb(:,:)
        end do
        do i=Nnode_vx3, 1, -1
          tmpb(:,:) = bb(:,:,i)
          do j=i+1, Nnode_vx3
            do r=1, 4
              tmpb(:,r) = tmpb(:,r) - A(:,i,j) * bb(:,r,j)
            end do
          end do
          do r=1, 4
            bb(:,r,i) = tmpb(:,r) * A(:,i,i)
          end do
        end do
        do i=1, Nnode_vx3
          b(:,i,v2,ke_xy) = bb(:,1,i)
          G(:,i,1,v2,ke_xy) = bb(:,2,i)
          G(:,i,2,v2,ke_xy) = bb(:,3,i)
          G(:,i,3,v2,ke_xy) = bb(:,4,i)
        end do
      end if
    end do
    end do
    return
  end subroutine solve_var3_im  

end module scale_atm_dyn_dgm_hevi_common_linalgebra
