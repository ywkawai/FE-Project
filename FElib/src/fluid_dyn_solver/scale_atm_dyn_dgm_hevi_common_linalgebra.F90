
!-------------------------------------------------------------------------------
! Warning: This file was generated from fluid_dyn_solver/scale_atm_dyn_dgm_hevi_common_linalgebra.F90.erb.
!          Do not edit this file.
!-------------------------------------------------------------------------------
!-------------------------------------------------------------------------------
!> module FElib / Fluid dyn solver / Atmosphere / HEVI / Common
!!
!! @par Description
!!      Computational kernels associated with linear algebra for vertical implicit solver
!!
!! @author Yuta Kawai, Team SCALE
!<
!-------------------------------------------------------------------------------
#include "scaleFElib.h"
module scale_atm_dyn_dgm_hevi_common_linalgebra
  !-----------------------------------------------------------------------------
  !
  !++ Used modules
  !
  use scale_precision
  use scale_io
  use scale_prc
  use scale_prof  
  !-----------------------------------------------------------------------------
  implicit none
  private
  !-----------------------------------------------------------------------------
  !
  !++ Public procedures
  !
  public :: atm_dyn_dgm_hevi_common_linalgebra_solve
  public :: atm_dyn_dgm_hevi_common_linalgebra_ludecomp

  !-----------------------------------------------------------------------------
  !
  !++ Public parameters & variables
  !
  
  !-----------------------------------------------------------------------------
  !
  !++ Private procedures & variables
  !
  !-------------------
contains
!OCL SERIAL
  subroutine atm_dyn_dgm_hevi_common_linalgebra_solve( D, b, ipiv, im, N )
    implicit none
    integer, intent(in) :: im
    integer, intent(in) :: N
    real(RP), intent(in) :: D(im,N,N)
    real(RP), intent(inout) :: b(im,N)
    integer, intent(out) :: ipiv(im,N)
    !------------------------------------------
    select case(im)
    case( 1 )
      call solve_vec1( D, b, ipiv, N )
    case( 2 )
      call solve_vec2( D, b, ipiv, N )
    case( 3 )
      call solve_vec3( D, b, ipiv, N )
    case( 4 )
      call solve_vec4( D, b, ipiv, N )
    case( 5 )
      call solve_vec5( D, b, ipiv, N )
    case( 6 )
      call solve_vec6( D, b, ipiv, N )
    case( 7 )
      call solve_vec7( D, b, ipiv, N )
    case( 8 )
      call solve_vec8( D, b, ipiv, N )
    case( 9 )
      call solve_vec9( D, b, ipiv, N )
    case( 10 )
      call solve_vec10( D, b, ipiv, N )
    case( 11 )
      call solve_vec11( D, b, ipiv, N )
    case( 12 )
      call solve_vec12( D, b, ipiv, N )
    case( 13 )
      call solve_vec13( D, b, ipiv, N )
    case( 14 )
      call solve_vec14( D, b, ipiv, N )
    case( 15 )
      call solve_vec15( D, b, ipiv, N )
    case( 16 )
      call solve_vec16( D, b, ipiv, N )
    case default
      LOG_INFO('atm_dyn_dgm_hevi_common_linalgebra_solve',*) "im > 16 is not supported. Check!"
      call PRC_abort
    end select
    return
  end subroutine atm_dyn_dgm_hevi_common_linalgebra_solve

!OCL SERIAL
  subroutine atm_dyn_dgm_hevi_common_linalgebra_ludecomp( D, ipiv, im, N )
    implicit none
    integer, intent(in) :: im
    integer, intent(in) :: N
    real(RP), intent(inout) :: D(im,N,N)
    integer, intent(out) :: ipiv(im,N)
    !------------------------------------------
    select case(im)
    case( 1 )
      call ludecomp_vec1( D, ipiv, N )
    case( 2 )
      call ludecomp_vec2( D, ipiv, N )
    case( 3 )
      call ludecomp_vec3( D, ipiv, N )
    case( 4 )
      call ludecomp_vec4( D, ipiv, N )
    case( 5 )
      call ludecomp_vec5( D, ipiv, N )
    case( 6 )
      call ludecomp_vec6( D, ipiv, N )
    case( 7 )
      call ludecomp_vec7( D, ipiv, N )
    case( 8 )
      call ludecomp_vec8( D, ipiv, N )
    case( 9 )
      call ludecomp_vec9( D, ipiv, N )
    case( 10 )
      call ludecomp_vec10( D, ipiv, N )
    case( 11 )
      call ludecomp_vec11( D, ipiv, N )
    case( 12 )
      call ludecomp_vec12( D, ipiv, N )
    case( 13 )
      call ludecomp_vec13( D, ipiv, N )
    case( 14 )
      call ludecomp_vec14( D, ipiv, N )
    case( 15 )
      call ludecomp_vec15( D, ipiv, N )
    case( 16 )
      call ludecomp_vec16( D, ipiv, N )
    case default
      LOG_INFO('atm_dyn_dgm_hevi_common_linalgebra_ludecomp',*) "im > 16 is not supported. Check!"
      call PRC_abort
    end select
    return
  end subroutine atm_dyn_dgm_hevi_common_linalgebra_ludecomp

!------
!OCL SERIAL
  subroutine solve_vec1( A, b, ipiv, N )
    implicit none
    integer, intent(in) :: N
    real(RP), intent(in) :: A(1,N,N)
    real(RP), intent(inout) :: b(1,N)
    integer, intent(out) :: ipiv(1,N)

    integer :: k, i, j, v
    integer :: ip(1)
    real(RP) :: tmp, tmpv(1)
    !------------------------------
    do k=1, N-1
      ip(:) = ipiv(:,k)
      do v=1, 1
        tmp = b(v,k)
        b(v,k) = b(v,ip(v))
        b(v,ip(v)) = tmp
      end do
    end do
    do j=1, N-1
      tmpv(:) = b(:,j)
      do i=j+1, N
        b(:,i) = b(:,i) - tmpv(:) * A(:,i,j)
      end do
    end do
    do j=N, 1, -1
      b(:,j) = b(:,j) * A(:,j,j)
      do i=1, j-1
        b(:,i) = b(:,i) - A(:,i,j) * b(:,j)
      end do
    end do
    return
  end subroutine solve_vec1

!OCL SERIAL
  subroutine ludecomp_vec1( A, ipiv, N )
    implicit none
    integer, intent(in) :: N
    real(RP), intent(inout) :: A(1,N,N)
    integer, intent(out) :: ipiv(1,N)

    integer :: k, i, j, v
    integer :: ip(1)
    real(RP) :: vmax(1)
    real(RP) :: tmp
    real(RP) :: tmpv(1)
    !------------------------------
    do k=1, N
      vmax(:) = abs(A(:,k,k))
      ip(:) = k
      do i=k+1, N
        do v=1, 1
          if ( abs(A(v,i,k)) > vmax(v) ) then
            ip(v) = i
            vmax(v) = abs(A(v,i,k))
          end if
        end do
      end do
      ipiv(:,k) = ip(:)
      do v=1, 1
        if (ip(v)/=k) then
          do j=1, N
            tmp = A(v,k,j)
            A(v,k,j) = A(v,ip(v),j)
            A(v,ip(v),j) = tmp
          end do
        end if
      end do
      !--
      tmpv(:) = 1.0_RP / A(:,k,k)
      A(:,k,k) = tmpv(:)
      do i=k+1, N
        A(:,i,k) = A(:,i,k) * tmpv(:)
      end do
      do j=k+1, N
        tmpv(:) = A(:,k,j)
        do i=k+1, N
          A(:,i,j) = A(:,i,j) - tmpv(:) * A(:,i,k)
        end do
      end do
    end do
    return
  end subroutine ludecomp_vec1
!OCL SERIAL
  subroutine solve_vec2( A, b, ipiv, N )
    implicit none
    integer, intent(in) :: N
    real(RP), intent(in) :: A(2,N,N)
    real(RP), intent(inout) :: b(2,N)
    integer, intent(out) :: ipiv(2,N)

    integer :: k, i, j, v
    integer :: ip(2)
    real(RP) :: tmp, tmpv(2)
    !------------------------------
    do k=1, N-1
      ip(:) = ipiv(:,k)
      do v=1, 2
        tmp = b(v,k)
        b(v,k) = b(v,ip(v))
        b(v,ip(v)) = tmp
      end do
    end do
    do j=1, N-1
      tmpv(:) = b(:,j)
      do i=j+1, N
        b(:,i) = b(:,i) - tmpv(:) * A(:,i,j)
      end do
    end do
    do j=N, 1, -1
      b(:,j) = b(:,j) * A(:,j,j)
      do i=1, j-1
        b(:,i) = b(:,i) - A(:,i,j) * b(:,j)
      end do
    end do
    return
  end subroutine solve_vec2

!OCL SERIAL
  subroutine ludecomp_vec2( A, ipiv, N )
    implicit none
    integer, intent(in) :: N
    real(RP), intent(inout) :: A(2,N,N)
    integer, intent(out) :: ipiv(2,N)

    integer :: k, i, j, v
    integer :: ip(2)
    real(RP) :: vmax(2)
    real(RP) :: tmp
    real(RP) :: tmpv(2)
    !------------------------------
    do k=1, N
      vmax(:) = abs(A(:,k,k))
      ip(:) = k
      do i=k+1, N
        do v=1, 2
          if ( abs(A(v,i,k)) > vmax(v) ) then
            ip(v) = i
            vmax(v) = abs(A(v,i,k))
          end if
        end do
      end do
      ipiv(:,k) = ip(:)
      do v=1, 2
        if (ip(v)/=k) then
          do j=1, N
            tmp = A(v,k,j)
            A(v,k,j) = A(v,ip(v),j)
            A(v,ip(v),j) = tmp
          end do
        end if
      end do
      !--
      tmpv(:) = 1.0_RP / A(:,k,k)
      A(:,k,k) = tmpv(:)
      do i=k+1, N
        A(:,i,k) = A(:,i,k) * tmpv(:)
      end do
      do j=k+1, N
        tmpv(:) = A(:,k,j)
        do i=k+1, N
          A(:,i,j) = A(:,i,j) - tmpv(:) * A(:,i,k)
        end do
      end do
    end do
    return
  end subroutine ludecomp_vec2
!OCL SERIAL
  subroutine solve_vec3( A, b, ipiv, N )
    implicit none
    integer, intent(in) :: N
    real(RP), intent(in) :: A(3,N,N)
    real(RP), intent(inout) :: b(3,N)
    integer, intent(out) :: ipiv(3,N)

    integer :: k, i, j, v
    integer :: ip(3)
    real(RP) :: tmp, tmpv(3)
    !------------------------------
    do k=1, N-1
      ip(:) = ipiv(:,k)
      do v=1, 3
        tmp = b(v,k)
        b(v,k) = b(v,ip(v))
        b(v,ip(v)) = tmp
      end do
    end do
    do j=1, N-1
      tmpv(:) = b(:,j)
      do i=j+1, N
        b(:,i) = b(:,i) - tmpv(:) * A(:,i,j)
      end do
    end do
    do j=N, 1, -1
      b(:,j) = b(:,j) * A(:,j,j)
      do i=1, j-1
        b(:,i) = b(:,i) - A(:,i,j) * b(:,j)
      end do
    end do
    return
  end subroutine solve_vec3

!OCL SERIAL
  subroutine ludecomp_vec3( A, ipiv, N )
    implicit none
    integer, intent(in) :: N
    real(RP), intent(inout) :: A(3,N,N)
    integer, intent(out) :: ipiv(3,N)

    integer :: k, i, j, v
    integer :: ip(3)
    real(RP) :: vmax(3)
    real(RP) :: tmp
    real(RP) :: tmpv(3)
    !------------------------------
    do k=1, N
      vmax(:) = abs(A(:,k,k))
      ip(:) = k
      do i=k+1, N
        do v=1, 3
          if ( abs(A(v,i,k)) > vmax(v) ) then
            ip(v) = i
            vmax(v) = abs(A(v,i,k))
          end if
        end do
      end do
      ipiv(:,k) = ip(:)
      do v=1, 3
        if (ip(v)/=k) then
          do j=1, N
            tmp = A(v,k,j)
            A(v,k,j) = A(v,ip(v),j)
            A(v,ip(v),j) = tmp
          end do
        end if
      end do
      !--
      tmpv(:) = 1.0_RP / A(:,k,k)
      A(:,k,k) = tmpv(:)
      do i=k+1, N
        A(:,i,k) = A(:,i,k) * tmpv(:)
      end do
      do j=k+1, N
        tmpv(:) = A(:,k,j)
        do i=k+1, N
          A(:,i,j) = A(:,i,j) - tmpv(:) * A(:,i,k)
        end do
      end do
    end do
    return
  end subroutine ludecomp_vec3
!OCL SERIAL
  subroutine solve_vec4( A, b, ipiv, N )
    implicit none
    integer, intent(in) :: N
    real(RP), intent(in) :: A(4,N,N)
    real(RP), intent(inout) :: b(4,N)
    integer, intent(out) :: ipiv(4,N)

    integer :: k, i, j, v
    integer :: ip(4)
    real(RP) :: tmp, tmpv(4)
    !------------------------------
    do k=1, N-1
      ip(:) = ipiv(:,k)
      do v=1, 4
        tmp = b(v,k)
        b(v,k) = b(v,ip(v))
        b(v,ip(v)) = tmp
      end do
    end do
    do j=1, N-1
      tmpv(:) = b(:,j)
      do i=j+1, N
        b(:,i) = b(:,i) - tmpv(:) * A(:,i,j)
      end do
    end do
    do j=N, 1, -1
      b(:,j) = b(:,j) * A(:,j,j)
      do i=1, j-1
        b(:,i) = b(:,i) - A(:,i,j) * b(:,j)
      end do
    end do
    return
  end subroutine solve_vec4

!OCL SERIAL
  subroutine ludecomp_vec4( A, ipiv, N )
    implicit none
    integer, intent(in) :: N
    real(RP), intent(inout) :: A(4,N,N)
    integer, intent(out) :: ipiv(4,N)

    integer :: k, i, j, v
    integer :: ip(4)
    real(RP) :: vmax(4)
    real(RP) :: tmp
    real(RP) :: tmpv(4)
    !------------------------------
    do k=1, N
      vmax(:) = abs(A(:,k,k))
      ip(:) = k
      do i=k+1, N
        do v=1, 4
          if ( abs(A(v,i,k)) > vmax(v) ) then
            ip(v) = i
            vmax(v) = abs(A(v,i,k))
          end if
        end do
      end do
      ipiv(:,k) = ip(:)
      do v=1, 4
        if (ip(v)/=k) then
          do j=1, N
            tmp = A(v,k,j)
            A(v,k,j) = A(v,ip(v),j)
            A(v,ip(v),j) = tmp
          end do
        end if
      end do
      !--
      tmpv(:) = 1.0_RP / A(:,k,k)
      A(:,k,k) = tmpv(:)
      do i=k+1, N
        A(:,i,k) = A(:,i,k) * tmpv(:)
      end do
      do j=k+1, N
        tmpv(:) = A(:,k,j)
        do i=k+1, N
          A(:,i,j) = A(:,i,j) - tmpv(:) * A(:,i,k)
        end do
      end do
    end do
    return
  end subroutine ludecomp_vec4
!OCL SERIAL
  subroutine solve_vec5( A, b, ipiv, N )
    implicit none
    integer, intent(in) :: N
    real(RP), intent(in) :: A(5,N,N)
    real(RP), intent(inout) :: b(5,N)
    integer, intent(out) :: ipiv(5,N)

    integer :: k, i, j, v
    integer :: ip(5)
    real(RP) :: tmp, tmpv(5)
    !------------------------------
    do k=1, N-1
      ip(:) = ipiv(:,k)
      do v=1, 5
        tmp = b(v,k)
        b(v,k) = b(v,ip(v))
        b(v,ip(v)) = tmp
      end do
    end do
    do j=1, N-1
      tmpv(:) = b(:,j)
      do i=j+1, N
        b(:,i) = b(:,i) - tmpv(:) * A(:,i,j)
      end do
    end do
    do j=N, 1, -1
      b(:,j) = b(:,j) * A(:,j,j)
      do i=1, j-1
        b(:,i) = b(:,i) - A(:,i,j) * b(:,j)
      end do
    end do
    return
  end subroutine solve_vec5

!OCL SERIAL
  subroutine ludecomp_vec5( A, ipiv, N )
    implicit none
    integer, intent(in) :: N
    real(RP), intent(inout) :: A(5,N,N)
    integer, intent(out) :: ipiv(5,N)

    integer :: k, i, j, v
    integer :: ip(5)
    real(RP) :: vmax(5)
    real(RP) :: tmp
    real(RP) :: tmpv(5)
    !------------------------------
    do k=1, N
      vmax(:) = abs(A(:,k,k))
      ip(:) = k
      do i=k+1, N
        do v=1, 5
          if ( abs(A(v,i,k)) > vmax(v) ) then
            ip(v) = i
            vmax(v) = abs(A(v,i,k))
          end if
        end do
      end do
      ipiv(:,k) = ip(:)
      do v=1, 5
        if (ip(v)/=k) then
          do j=1, N
            tmp = A(v,k,j)
            A(v,k,j) = A(v,ip(v),j)
            A(v,ip(v),j) = tmp
          end do
        end if
      end do
      !--
      tmpv(:) = 1.0_RP / A(:,k,k)
      A(:,k,k) = tmpv(:)
      do i=k+1, N
        A(:,i,k) = A(:,i,k) * tmpv(:)
      end do
      do j=k+1, N
        tmpv(:) = A(:,k,j)
        do i=k+1, N
          A(:,i,j) = A(:,i,j) - tmpv(:) * A(:,i,k)
        end do
      end do
    end do
    return
  end subroutine ludecomp_vec5
!OCL SERIAL
  subroutine solve_vec6( A, b, ipiv, N )
    implicit none
    integer, intent(in) :: N
    real(RP), intent(in) :: A(6,N,N)
    real(RP), intent(inout) :: b(6,N)
    integer, intent(out) :: ipiv(6,N)

    integer :: k, i, j, v
    integer :: ip(6)
    real(RP) :: tmp, tmpv(6)
    !------------------------------
    do k=1, N-1
      ip(:) = ipiv(:,k)
      do v=1, 6
        tmp = b(v,k)
        b(v,k) = b(v,ip(v))
        b(v,ip(v)) = tmp
      end do
    end do
    do j=1, N-1
      tmpv(:) = b(:,j)
      do i=j+1, N
        b(:,i) = b(:,i) - tmpv(:) * A(:,i,j)
      end do
    end do
    do j=N, 1, -1
      b(:,j) = b(:,j) * A(:,j,j)
      do i=1, j-1
        b(:,i) = b(:,i) - A(:,i,j) * b(:,j)
      end do
    end do
    return
  end subroutine solve_vec6

!OCL SERIAL
  subroutine ludecomp_vec6( A, ipiv, N )
    implicit none
    integer, intent(in) :: N
    real(RP), intent(inout) :: A(6,N,N)
    integer, intent(out) :: ipiv(6,N)

    integer :: k, i, j, v
    integer :: ip(6)
    real(RP) :: vmax(6)
    real(RP) :: tmp
    real(RP) :: tmpv(6)
    !------------------------------
    do k=1, N
      vmax(:) = abs(A(:,k,k))
      ip(:) = k
      do i=k+1, N
        do v=1, 6
          if ( abs(A(v,i,k)) > vmax(v) ) then
            ip(v) = i
            vmax(v) = abs(A(v,i,k))
          end if
        end do
      end do
      ipiv(:,k) = ip(:)
      do v=1, 6
        if (ip(v)/=k) then
          do j=1, N
            tmp = A(v,k,j)
            A(v,k,j) = A(v,ip(v),j)
            A(v,ip(v),j) = tmp
          end do
        end if
      end do
      !--
      tmpv(:) = 1.0_RP / A(:,k,k)
      A(:,k,k) = tmpv(:)
      do i=k+1, N
        A(:,i,k) = A(:,i,k) * tmpv(:)
      end do
      do j=k+1, N
        tmpv(:) = A(:,k,j)
        do i=k+1, N
          A(:,i,j) = A(:,i,j) - tmpv(:) * A(:,i,k)
        end do
      end do
    end do
    return
  end subroutine ludecomp_vec6
!OCL SERIAL
  subroutine solve_vec7( A, b, ipiv, N )
    implicit none
    integer, intent(in) :: N
    real(RP), intent(in) :: A(7,N,N)
    real(RP), intent(inout) :: b(7,N)
    integer, intent(out) :: ipiv(7,N)

    integer :: k, i, j, v
    integer :: ip(7)
    real(RP) :: tmp, tmpv(7)
    !------------------------------
    do k=1, N-1
      ip(:) = ipiv(:,k)
      do v=1, 7
        tmp = b(v,k)
        b(v,k) = b(v,ip(v))
        b(v,ip(v)) = tmp
      end do
    end do
    do j=1, N-1
      tmpv(:) = b(:,j)
      do i=j+1, N
        b(:,i) = b(:,i) - tmpv(:) * A(:,i,j)
      end do
    end do
    do j=N, 1, -1
      b(:,j) = b(:,j) * A(:,j,j)
      do i=1, j-1
        b(:,i) = b(:,i) - A(:,i,j) * b(:,j)
      end do
    end do
    return
  end subroutine solve_vec7

!OCL SERIAL
  subroutine ludecomp_vec7( A, ipiv, N )
    implicit none
    integer, intent(in) :: N
    real(RP), intent(inout) :: A(7,N,N)
    integer, intent(out) :: ipiv(7,N)

    integer :: k, i, j, v
    integer :: ip(7)
    real(RP) :: vmax(7)
    real(RP) :: tmp
    real(RP) :: tmpv(7)
    !------------------------------
    do k=1, N
      vmax(:) = abs(A(:,k,k))
      ip(:) = k
      do i=k+1, N
        do v=1, 7
          if ( abs(A(v,i,k)) > vmax(v) ) then
            ip(v) = i
            vmax(v) = abs(A(v,i,k))
          end if
        end do
      end do
      ipiv(:,k) = ip(:)
      do v=1, 7
        if (ip(v)/=k) then
          do j=1, N
            tmp = A(v,k,j)
            A(v,k,j) = A(v,ip(v),j)
            A(v,ip(v),j) = tmp
          end do
        end if
      end do
      !--
      tmpv(:) = 1.0_RP / A(:,k,k)
      A(:,k,k) = tmpv(:)
      do i=k+1, N
        A(:,i,k) = A(:,i,k) * tmpv(:)
      end do
      do j=k+1, N
        tmpv(:) = A(:,k,j)
        do i=k+1, N
          A(:,i,j) = A(:,i,j) - tmpv(:) * A(:,i,k)
        end do
      end do
    end do
    return
  end subroutine ludecomp_vec7
!OCL SERIAL
  subroutine solve_vec8( A, b, ipiv, N )
    implicit none
    integer, intent(in) :: N
    real(RP), intent(in) :: A(8,N,N)
    real(RP), intent(inout) :: b(8,N)
    integer, intent(out) :: ipiv(8,N)

    integer :: k, i, j, v
    integer :: ip(8)
    real(RP) :: tmp, tmpv(8)
    !------------------------------
    do k=1, N-1
      ip(:) = ipiv(:,k)
      do v=1, 8
        tmp = b(v,k)
        b(v,k) = b(v,ip(v))
        b(v,ip(v)) = tmp
      end do
    end do
    do j=1, N-1
      tmpv(:) = b(:,j)
      do i=j+1, N
        b(:,i) = b(:,i) - tmpv(:) * A(:,i,j)
      end do
    end do
    do j=N, 1, -1
      b(:,j) = b(:,j) * A(:,j,j)
      do i=1, j-1
        b(:,i) = b(:,i) - A(:,i,j) * b(:,j)
      end do
    end do
    return
  end subroutine solve_vec8

!OCL SERIAL
  subroutine ludecomp_vec8( A, ipiv, N )
    implicit none
    integer, intent(in) :: N
    real(RP), intent(inout) :: A(8,N,N)
    integer, intent(out) :: ipiv(8,N)

    integer :: k, i, j, v
    integer :: ip(8)
    real(RP) :: vmax(8)
    real(RP) :: tmp
    real(RP) :: tmpv(8)
    !------------------------------
    do k=1, N
      vmax(:) = abs(A(:,k,k))
      ip(:) = k
      do i=k+1, N
        do v=1, 8
          if ( abs(A(v,i,k)) > vmax(v) ) then
            ip(v) = i
            vmax(v) = abs(A(v,i,k))
          end if
        end do
      end do
      ipiv(:,k) = ip(:)
      do v=1, 8
        if (ip(v)/=k) then
          do j=1, N
            tmp = A(v,k,j)
            A(v,k,j) = A(v,ip(v),j)
            A(v,ip(v),j) = tmp
          end do
        end if
      end do
      !--
      tmpv(:) = 1.0_RP / A(:,k,k)
      A(:,k,k) = tmpv(:)
      do i=k+1, N
        A(:,i,k) = A(:,i,k) * tmpv(:)
      end do
      do j=k+1, N
        tmpv(:) = A(:,k,j)
        do i=k+1, N
          A(:,i,j) = A(:,i,j) - tmpv(:) * A(:,i,k)
        end do
      end do
    end do
    return
  end subroutine ludecomp_vec8
!OCL SERIAL
  subroutine solve_vec9( A, b, ipiv, N )
    implicit none
    integer, intent(in) :: N
    real(RP), intent(in) :: A(9,N,N)
    real(RP), intent(inout) :: b(9,N)
    integer, intent(out) :: ipiv(9,N)

    integer :: k, i, j, v
    integer :: ip(9)
    real(RP) :: tmp, tmpv(9)
    !------------------------------
    do k=1, N-1
      ip(:) = ipiv(:,k)
      do v=1, 9
        tmp = b(v,k)
        b(v,k) = b(v,ip(v))
        b(v,ip(v)) = tmp
      end do
    end do
    do j=1, N-1
      tmpv(:) = b(:,j)
      do i=j+1, N
        b(:,i) = b(:,i) - tmpv(:) * A(:,i,j)
      end do
    end do
    do j=N, 1, -1
      b(:,j) = b(:,j) * A(:,j,j)
      do i=1, j-1
        b(:,i) = b(:,i) - A(:,i,j) * b(:,j)
      end do
    end do
    return
  end subroutine solve_vec9

!OCL SERIAL
  subroutine ludecomp_vec9( A, ipiv, N )
    implicit none
    integer, intent(in) :: N
    real(RP), intent(inout) :: A(9,N,N)
    integer, intent(out) :: ipiv(9,N)

    integer :: k, i, j, v
    integer :: ip(9)
    real(RP) :: vmax(9)
    real(RP) :: tmp
    real(RP) :: tmpv(9)
    !------------------------------
    do k=1, N
      vmax(:) = abs(A(:,k,k))
      ip(:) = k
      do i=k+1, N
        do v=1, 9
          if ( abs(A(v,i,k)) > vmax(v) ) then
            ip(v) = i
            vmax(v) = abs(A(v,i,k))
          end if
        end do
      end do
      ipiv(:,k) = ip(:)
      do v=1, 9
        if (ip(v)/=k) then
          do j=1, N
            tmp = A(v,k,j)
            A(v,k,j) = A(v,ip(v),j)
            A(v,ip(v),j) = tmp
          end do
        end if
      end do
      !--
      tmpv(:) = 1.0_RP / A(:,k,k)
      A(:,k,k) = tmpv(:)
      do i=k+1, N
        A(:,i,k) = A(:,i,k) * tmpv(:)
      end do
      do j=k+1, N
        tmpv(:) = A(:,k,j)
        do i=k+1, N
          A(:,i,j) = A(:,i,j) - tmpv(:) * A(:,i,k)
        end do
      end do
    end do
    return
  end subroutine ludecomp_vec9
!OCL SERIAL
  subroutine solve_vec10( A, b, ipiv, N )
    implicit none
    integer, intent(in) :: N
    real(RP), intent(in) :: A(10,N,N)
    real(RP), intent(inout) :: b(10,N)
    integer, intent(out) :: ipiv(10,N)

    integer :: k, i, j, v
    integer :: ip(10)
    real(RP) :: tmp, tmpv(10)
    !------------------------------
    do k=1, N-1
      ip(:) = ipiv(:,k)
      do v=1, 10
        tmp = b(v,k)
        b(v,k) = b(v,ip(v))
        b(v,ip(v)) = tmp
      end do
    end do
    do j=1, N-1
      tmpv(:) = b(:,j)
      do i=j+1, N
        b(:,i) = b(:,i) - tmpv(:) * A(:,i,j)
      end do
    end do
    do j=N, 1, -1
      b(:,j) = b(:,j) * A(:,j,j)
      do i=1, j-1
        b(:,i) = b(:,i) - A(:,i,j) * b(:,j)
      end do
    end do
    return
  end subroutine solve_vec10

!OCL SERIAL
  subroutine ludecomp_vec10( A, ipiv, N )
    implicit none
    integer, intent(in) :: N
    real(RP), intent(inout) :: A(10,N,N)
    integer, intent(out) :: ipiv(10,N)

    integer :: k, i, j, v
    integer :: ip(10)
    real(RP) :: vmax(10)
    real(RP) :: tmp
    real(RP) :: tmpv(10)
    !------------------------------
    do k=1, N
      vmax(:) = abs(A(:,k,k))
      ip(:) = k
      do i=k+1, N
        do v=1, 10
          if ( abs(A(v,i,k)) > vmax(v) ) then
            ip(v) = i
            vmax(v) = abs(A(v,i,k))
          end if
        end do
      end do
      ipiv(:,k) = ip(:)
      do v=1, 10
        if (ip(v)/=k) then
          do j=1, N
            tmp = A(v,k,j)
            A(v,k,j) = A(v,ip(v),j)
            A(v,ip(v),j) = tmp
          end do
        end if
      end do
      !--
      tmpv(:) = 1.0_RP / A(:,k,k)
      A(:,k,k) = tmpv(:)
      do i=k+1, N
        A(:,i,k) = A(:,i,k) * tmpv(:)
      end do
      do j=k+1, N
        tmpv(:) = A(:,k,j)
        do i=k+1, N
          A(:,i,j) = A(:,i,j) - tmpv(:) * A(:,i,k)
        end do
      end do
    end do
    return
  end subroutine ludecomp_vec10
!OCL SERIAL
  subroutine solve_vec11( A, b, ipiv, N )
    implicit none
    integer, intent(in) :: N
    real(RP), intent(in) :: A(11,N,N)
    real(RP), intent(inout) :: b(11,N)
    integer, intent(out) :: ipiv(11,N)

    integer :: k, i, j, v
    integer :: ip(11)
    real(RP) :: tmp, tmpv(11)
    !------------------------------
    do k=1, N-1
      ip(:) = ipiv(:,k)
      do v=1, 11
        tmp = b(v,k)
        b(v,k) = b(v,ip(v))
        b(v,ip(v)) = tmp
      end do
    end do
    do j=1, N-1
      tmpv(:) = b(:,j)
      do i=j+1, N
        b(:,i) = b(:,i) - tmpv(:) * A(:,i,j)
      end do
    end do
    do j=N, 1, -1
      b(:,j) = b(:,j) * A(:,j,j)
      do i=1, j-1
        b(:,i) = b(:,i) - A(:,i,j) * b(:,j)
      end do
    end do
    return
  end subroutine solve_vec11

!OCL SERIAL
  subroutine ludecomp_vec11( A, ipiv, N )
    implicit none
    integer, intent(in) :: N
    real(RP), intent(inout) :: A(11,N,N)
    integer, intent(out) :: ipiv(11,N)

    integer :: k, i, j, v
    integer :: ip(11)
    real(RP) :: vmax(11)
    real(RP) :: tmp
    real(RP) :: tmpv(11)
    !------------------------------
    do k=1, N
      vmax(:) = abs(A(:,k,k))
      ip(:) = k
      do i=k+1, N
        do v=1, 11
          if ( abs(A(v,i,k)) > vmax(v) ) then
            ip(v) = i
            vmax(v) = abs(A(v,i,k))
          end if
        end do
      end do
      ipiv(:,k) = ip(:)
      do v=1, 11
        if (ip(v)/=k) then
          do j=1, N
            tmp = A(v,k,j)
            A(v,k,j) = A(v,ip(v),j)
            A(v,ip(v),j) = tmp
          end do
        end if
      end do
      !--
      tmpv(:) = 1.0_RP / A(:,k,k)
      A(:,k,k) = tmpv(:)
      do i=k+1, N
        A(:,i,k) = A(:,i,k) * tmpv(:)
      end do
      do j=k+1, N
        tmpv(:) = A(:,k,j)
        do i=k+1, N
          A(:,i,j) = A(:,i,j) - tmpv(:) * A(:,i,k)
        end do
      end do
    end do
    return
  end subroutine ludecomp_vec11
!OCL SERIAL
  subroutine solve_vec12( A, b, ipiv, N )
    implicit none
    integer, intent(in) :: N
    real(RP), intent(in) :: A(12,N,N)
    real(RP), intent(inout) :: b(12,N)
    integer, intent(out) :: ipiv(12,N)

    integer :: k, i, j, v
    integer :: ip(12)
    real(RP) :: tmp, tmpv(12)
    !------------------------------
    do k=1, N-1
      ip(:) = ipiv(:,k)
      do v=1, 12
        tmp = b(v,k)
        b(v,k) = b(v,ip(v))
        b(v,ip(v)) = tmp
      end do
    end do
    do j=1, N-1
      tmpv(:) = b(:,j)
      do i=j+1, N
        b(:,i) = b(:,i) - tmpv(:) * A(:,i,j)
      end do
    end do
    do j=N, 1, -1
      b(:,j) = b(:,j) * A(:,j,j)
      do i=1, j-1
        b(:,i) = b(:,i) - A(:,i,j) * b(:,j)
      end do
    end do
    return
  end subroutine solve_vec12

!OCL SERIAL
  subroutine ludecomp_vec12( A, ipiv, N )
    implicit none
    integer, intent(in) :: N
    real(RP), intent(inout) :: A(12,N,N)
    integer, intent(out) :: ipiv(12,N)

    integer :: k, i, j, v
    integer :: ip(12)
    real(RP) :: vmax(12)
    real(RP) :: tmp
    real(RP) :: tmpv(12)
    !------------------------------
    do k=1, N
      vmax(:) = abs(A(:,k,k))
      ip(:) = k
      do i=k+1, N
        do v=1, 12
          if ( abs(A(v,i,k)) > vmax(v) ) then
            ip(v) = i
            vmax(v) = abs(A(v,i,k))
          end if
        end do
      end do
      ipiv(:,k) = ip(:)
      do v=1, 12
        if (ip(v)/=k) then
          do j=1, N
            tmp = A(v,k,j)
            A(v,k,j) = A(v,ip(v),j)
            A(v,ip(v),j) = tmp
          end do
        end if
      end do
      !--
      tmpv(:) = 1.0_RP / A(:,k,k)
      A(:,k,k) = tmpv(:)
      do i=k+1, N
        A(:,i,k) = A(:,i,k) * tmpv(:)
      end do
      do j=k+1, N
        tmpv(:) = A(:,k,j)
        do i=k+1, N
          A(:,i,j) = A(:,i,j) - tmpv(:) * A(:,i,k)
        end do
      end do
    end do
    return
  end subroutine ludecomp_vec12
!OCL SERIAL
  subroutine solve_vec13( A, b, ipiv, N )
    implicit none
    integer, intent(in) :: N
    real(RP), intent(in) :: A(13,N,N)
    real(RP), intent(inout) :: b(13,N)
    integer, intent(out) :: ipiv(13,N)

    integer :: k, i, j, v
    integer :: ip(13)
    real(RP) :: tmp, tmpv(13)
    !------------------------------
    do k=1, N-1
      ip(:) = ipiv(:,k)
      do v=1, 13
        tmp = b(v,k)
        b(v,k) = b(v,ip(v))
        b(v,ip(v)) = tmp
      end do
    end do
    do j=1, N-1
      tmpv(:) = b(:,j)
      do i=j+1, N
        b(:,i) = b(:,i) - tmpv(:) * A(:,i,j)
      end do
    end do
    do j=N, 1, -1
      b(:,j) = b(:,j) * A(:,j,j)
      do i=1, j-1
        b(:,i) = b(:,i) - A(:,i,j) * b(:,j)
      end do
    end do
    return
  end subroutine solve_vec13

!OCL SERIAL
  subroutine ludecomp_vec13( A, ipiv, N )
    implicit none
    integer, intent(in) :: N
    real(RP), intent(inout) :: A(13,N,N)
    integer, intent(out) :: ipiv(13,N)

    integer :: k, i, j, v
    integer :: ip(13)
    real(RP) :: vmax(13)
    real(RP) :: tmp
    real(RP) :: tmpv(13)
    !------------------------------
    do k=1, N
      vmax(:) = abs(A(:,k,k))
      ip(:) = k
      do i=k+1, N
        do v=1, 13
          if ( abs(A(v,i,k)) > vmax(v) ) then
            ip(v) = i
            vmax(v) = abs(A(v,i,k))
          end if
        end do
      end do
      ipiv(:,k) = ip(:)
      do v=1, 13
        if (ip(v)/=k) then
          do j=1, N
            tmp = A(v,k,j)
            A(v,k,j) = A(v,ip(v),j)
            A(v,ip(v),j) = tmp
          end do
        end if
      end do
      !--
      tmpv(:) = 1.0_RP / A(:,k,k)
      A(:,k,k) = tmpv(:)
      do i=k+1, N
        A(:,i,k) = A(:,i,k) * tmpv(:)
      end do
      do j=k+1, N
        tmpv(:) = A(:,k,j)
        do i=k+1, N
          A(:,i,j) = A(:,i,j) - tmpv(:) * A(:,i,k)
        end do
      end do
    end do
    return
  end subroutine ludecomp_vec13
!OCL SERIAL
  subroutine solve_vec14( A, b, ipiv, N )
    implicit none
    integer, intent(in) :: N
    real(RP), intent(in) :: A(14,N,N)
    real(RP), intent(inout) :: b(14,N)
    integer, intent(out) :: ipiv(14,N)

    integer :: k, i, j, v
    integer :: ip(14)
    real(RP) :: tmp, tmpv(14)
    !------------------------------
    do k=1, N-1
      ip(:) = ipiv(:,k)
      do v=1, 14
        tmp = b(v,k)
        b(v,k) = b(v,ip(v))
        b(v,ip(v)) = tmp
      end do
    end do
    do j=1, N-1
      tmpv(:) = b(:,j)
      do i=j+1, N
        b(:,i) = b(:,i) - tmpv(:) * A(:,i,j)
      end do
    end do
    do j=N, 1, -1
      b(:,j) = b(:,j) * A(:,j,j)
      do i=1, j-1
        b(:,i) = b(:,i) - A(:,i,j) * b(:,j)
      end do
    end do
    return
  end subroutine solve_vec14

!OCL SERIAL
  subroutine ludecomp_vec14( A, ipiv, N )
    implicit none
    integer, intent(in) :: N
    real(RP), intent(inout) :: A(14,N,N)
    integer, intent(out) :: ipiv(14,N)

    integer :: k, i, j, v
    integer :: ip(14)
    real(RP) :: vmax(14)
    real(RP) :: tmp
    real(RP) :: tmpv(14)
    !------------------------------
    do k=1, N
      vmax(:) = abs(A(:,k,k))
      ip(:) = k
      do i=k+1, N
        do v=1, 14
          if ( abs(A(v,i,k)) > vmax(v) ) then
            ip(v) = i
            vmax(v) = abs(A(v,i,k))
          end if
        end do
      end do
      ipiv(:,k) = ip(:)
      do v=1, 14
        if (ip(v)/=k) then
          do j=1, N
            tmp = A(v,k,j)
            A(v,k,j) = A(v,ip(v),j)
            A(v,ip(v),j) = tmp
          end do
        end if
      end do
      !--
      tmpv(:) = 1.0_RP / A(:,k,k)
      A(:,k,k) = tmpv(:)
      do i=k+1, N
        A(:,i,k) = A(:,i,k) * tmpv(:)
      end do
      do j=k+1, N
        tmpv(:) = A(:,k,j)
        do i=k+1, N
          A(:,i,j) = A(:,i,j) - tmpv(:) * A(:,i,k)
        end do
      end do
    end do
    return
  end subroutine ludecomp_vec14
!OCL SERIAL
  subroutine solve_vec15( A, b, ipiv, N )
    implicit none
    integer, intent(in) :: N
    real(RP), intent(in) :: A(15,N,N)
    real(RP), intent(inout) :: b(15,N)
    integer, intent(out) :: ipiv(15,N)

    integer :: k, i, j, v
    integer :: ip(15)
    real(RP) :: tmp, tmpv(15)
    !------------------------------
    do k=1, N-1
      ip(:) = ipiv(:,k)
      do v=1, 15
        tmp = b(v,k)
        b(v,k) = b(v,ip(v))
        b(v,ip(v)) = tmp
      end do
    end do
    do j=1, N-1
      tmpv(:) = b(:,j)
      do i=j+1, N
        b(:,i) = b(:,i) - tmpv(:) * A(:,i,j)
      end do
    end do
    do j=N, 1, -1
      b(:,j) = b(:,j) * A(:,j,j)
      do i=1, j-1
        b(:,i) = b(:,i) - A(:,i,j) * b(:,j)
      end do
    end do
    return
  end subroutine solve_vec15

!OCL SERIAL
  subroutine ludecomp_vec15( A, ipiv, N )
    implicit none
    integer, intent(in) :: N
    real(RP), intent(inout) :: A(15,N,N)
    integer, intent(out) :: ipiv(15,N)

    integer :: k, i, j, v
    integer :: ip(15)
    real(RP) :: vmax(15)
    real(RP) :: tmp
    real(RP) :: tmpv(15)
    !------------------------------
    do k=1, N
      vmax(:) = abs(A(:,k,k))
      ip(:) = k
      do i=k+1, N
        do v=1, 15
          if ( abs(A(v,i,k)) > vmax(v) ) then
            ip(v) = i
            vmax(v) = abs(A(v,i,k))
          end if
        end do
      end do
      ipiv(:,k) = ip(:)
      do v=1, 15
        if (ip(v)/=k) then
          do j=1, N
            tmp = A(v,k,j)
            A(v,k,j) = A(v,ip(v),j)
            A(v,ip(v),j) = tmp
          end do
        end if
      end do
      !--
      tmpv(:) = 1.0_RP / A(:,k,k)
      A(:,k,k) = tmpv(:)
      do i=k+1, N
        A(:,i,k) = A(:,i,k) * tmpv(:)
      end do
      do j=k+1, N
        tmpv(:) = A(:,k,j)
        do i=k+1, N
          A(:,i,j) = A(:,i,j) - tmpv(:) * A(:,i,k)
        end do
      end do
    end do
    return
  end subroutine ludecomp_vec15
!OCL SERIAL
  subroutine solve_vec16( A, b, ipiv, N )
    implicit none
    integer, intent(in) :: N
    real(RP), intent(in) :: A(16,N,N)
    real(RP), intent(inout) :: b(16,N)
    integer, intent(out) :: ipiv(16,N)

    integer :: k, i, j, v
    integer :: ip(16)
    real(RP) :: tmp, tmpv(16)
    !------------------------------
    do k=1, N-1
      ip(:) = ipiv(:,k)
      do v=1, 16
        tmp = b(v,k)
        b(v,k) = b(v,ip(v))
        b(v,ip(v)) = tmp
      end do
    end do
    do j=1, N-1
      tmpv(:) = b(:,j)
      do i=j+1, N
        b(:,i) = b(:,i) - tmpv(:) * A(:,i,j)
      end do
    end do
    do j=N, 1, -1
      b(:,j) = b(:,j) * A(:,j,j)
      do i=1, j-1
        b(:,i) = b(:,i) - A(:,i,j) * b(:,j)
      end do
    end do
    return
  end subroutine solve_vec16

!OCL SERIAL
  subroutine ludecomp_vec16( A, ipiv, N )
    implicit none
    integer, intent(in) :: N
    real(RP), intent(inout) :: A(16,N,N)
    integer, intent(out) :: ipiv(16,N)

    integer :: k, i, j, v
    integer :: ip(16)
    real(RP) :: vmax(16)
    real(RP) :: tmp
    real(RP) :: tmpv(16)
    !------------------------------
    do k=1, N
      vmax(:) = abs(A(:,k,k))
      ip(:) = k
      do i=k+1, N
        do v=1, 16
          if ( abs(A(v,i,k)) > vmax(v) ) then
            ip(v) = i
            vmax(v) = abs(A(v,i,k))
          end if
        end do
      end do
      ipiv(:,k) = ip(:)
      do v=1, 16
        if (ip(v)/=k) then
          do j=1, N
            tmp = A(v,k,j)
            A(v,k,j) = A(v,ip(v),j)
            A(v,ip(v),j) = tmp
          end do
        end if
      end do
      !--
      tmpv(:) = 1.0_RP / A(:,k,k)
      A(:,k,k) = tmpv(:)
      do i=k+1, N
        A(:,i,k) = A(:,i,k) * tmpv(:)
      end do
      do j=k+1, N
        tmpv(:) = A(:,k,j)
        do i=k+1, N
          A(:,i,j) = A(:,i,j) - tmpv(:) * A(:,i,k)
        end do
      end do
    end do
    return
  end subroutine ludecomp_vec16

end module scale_atm_dyn_dgm_hevi_common_linalgebra
